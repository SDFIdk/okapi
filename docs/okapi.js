var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/proj4/dist/proj4.js
var require_proj4 = __commonJS({
  "node_modules/proj4/dist/proj4.js"(exports, module) {
    !function(t, s) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = s() : "function" == typeof define && define.amd ? define(s) : (t = "undefined" != typeof globalThis ? globalThis : t || self).proj4 = s();
    }(exports, function() {
      "use strict";
      var t = 6378137, s = 0.0066943799901413165, i = 484813681109536e-20, a = Math.PI / 2, h = 1e-10, e = 0.017453292519943295, n = 57.29577951308232, r = Math.PI / 4, o = 2 * Math.PI, l = 3.14159265359, c = { greenwich: 0, lisbon: -9.131906111111, paris: 2.337229166667, bogota: -74.080916666667, madrid: -3.687938888889, rome: 12.452333333333, bern: 7.439583333333, jakarta: 106.807719444444, ferro: -17.666666666667, brussels: 4.367975, stockholm: 18.058277777778, athens: 23.7163375, oslo: 10.722916666667 }, _ = { mm: { to_meter: 1e-3 }, cm: { to_meter: 0.01 }, ft: { to_meter: 0.3048 }, "us-ft": { to_meter: 1200 / 3937 }, fath: { to_meter: 1.8288 }, kmi: { to_meter: 1852 }, "us-ch": { to_meter: 20.1168402336805 }, "us-mi": { to_meter: 1609.34721869444 }, km: { to_meter: 1e3 }, "ind-ft": { to_meter: 0.30479841 }, "ind-yd": { to_meter: 0.91439523 }, mi: { to_meter: 1609.344 }, yd: { to_meter: 0.9144 }, ch: { to_meter: 20.1168 }, link: { to_meter: 0.201168 }, dm: { to_meter: 0.1 }, in: { to_meter: 0.0254 }, "ind-ch": { to_meter: 20.11669506 }, "us-in": { to_meter: 0.025400050800101 }, "us-yd": { to_meter: 0.914401828803658 } }, u = /[\s_\-\/\(\)]/g;
      function M(t2, s2) {
        if (t2[s2]) return t2[s2];
        for (var i2, a3 = Object.keys(t2), h2 = s2.toLowerCase().replace(u, ""), e2 = -1; ++e2 < a3.length; ) if ((i2 = a3[e2]).toLowerCase().replace(u, "") === h2) return t2[i2];
      }
      function g(t2) {
        var s2, i2, a3, h2 = {}, n2 = t2.split("+").map(function(t3) {
          return t3.trim();
        }).filter(function(t3) {
          return t3;
        }).reduce(function(t3, s3) {
          var i3 = s3.split("=");
          return i3.push(true), t3[i3[0].toLowerCase()] = i3[1], t3;
        }, {}), r2 = { proj: "projName", datum: "datumCode", rf: function(t3) {
          h2.rf = parseFloat(t3);
        }, lat_0: function(t3) {
          h2.lat0 = t3 * e;
        }, lat_1: function(t3) {
          h2.lat1 = t3 * e;
        }, lat_2: function(t3) {
          h2.lat2 = t3 * e;
        }, lat_ts: function(t3) {
          h2.lat_ts = t3 * e;
        }, lon_0: function(t3) {
          h2.long0 = t3 * e;
        }, lon_1: function(t3) {
          h2.long1 = t3 * e;
        }, lon_2: function(t3) {
          h2.long2 = t3 * e;
        }, alpha: function(t3) {
          h2.alpha = parseFloat(t3) * e;
        }, gamma: function(t3) {
          h2.rectified_grid_angle = parseFloat(t3) * e;
        }, lonc: function(t3) {
          h2.longc = t3 * e;
        }, x_0: function(t3) {
          h2.x0 = parseFloat(t3);
        }, y_0: function(t3) {
          h2.y0 = parseFloat(t3);
        }, k_0: function(t3) {
          h2.k0 = parseFloat(t3);
        }, k: function(t3) {
          h2.k0 = parseFloat(t3);
        }, a: function(t3) {
          h2.a = parseFloat(t3);
        }, b: function(t3) {
          h2.b = parseFloat(t3);
        }, r: function(t3) {
          h2.a = h2.b = parseFloat(t3);
        }, r_a: function() {
          h2.R_A = true;
        }, zone: function(t3) {
          h2.zone = parseInt(t3, 10);
        }, south: function() {
          h2.utmSouth = true;
        }, towgs84: function(t3) {
          h2.datum_params = t3.split(",").map(function(t4) {
            return parseFloat(t4);
          });
        }, to_meter: function(t3) {
          h2.to_meter = parseFloat(t3);
        }, units: function(t3) {
          h2.units = t3;
          var s3 = M(_, t3);
          s3 && (h2.to_meter = s3.to_meter);
        }, from_greenwich: function(t3) {
          h2.from_greenwich = t3 * e;
        }, pm: function(t3) {
          var s3 = M(c, t3);
          h2.from_greenwich = (s3 || parseFloat(t3)) * e;
        }, nadgrids: function(t3) {
          "@null" === t3 ? h2.datumCode = "none" : h2.nadgrids = t3;
        }, axis: function(t3) {
          var s3 = "ewnsud";
          3 === t3.length && -1 !== s3.indexOf(t3.substr(0, 1)) && -1 !== s3.indexOf(t3.substr(1, 1)) && -1 !== s3.indexOf(t3.substr(2, 1)) && (h2.axis = t3);
        }, approx: function() {
          h2.approx = true;
        } };
        for (s2 in n2) i2 = n2[s2], s2 in r2 ? "function" == typeof (a3 = r2[s2]) ? a3(i2) : h2[a3] = i2 : h2[s2] = i2;
        return "string" == typeof h2.datumCode && "WGS84" !== h2.datumCode && (h2.datumCode = h2.datumCode.toLowerCase()), h2;
      }
      class f {
        static getId(t2) {
          const s2 = t2.find((t3) => Array.isArray(t3) && "ID" === t3[0]);
          return s2 && s2.length >= 3 ? { authority: s2[1], code: parseInt(s2[2], 10) } : null;
        }
        static convertUnit(t2, s2 = "unit") {
          if (!t2 || t2.length < 3) return { type: s2, name: "unknown", conversion_factor: null };
          const i2 = t2[1], a3 = parseFloat(t2[2]) || null, h2 = t2.find((t3) => Array.isArray(t3) && "ID" === t3[0]);
          return { type: s2, name: i2, conversion_factor: a3, id: h2 ? { authority: h2[1], code: parseInt(h2[2], 10) } : null };
        }
        static convertAxis(t2) {
          const s2 = t2[1] || "Unknown";
          let i2;
          const a3 = s2.match(/^\((.)\)$/);
          if (a3) {
            const t3 = a3[1].toUpperCase();
            if ("E" === t3) i2 = "east";
            else if ("N" === t3) i2 = "north";
            else {
              if ("U" !== t3) throw new Error(`Unknown axis abbreviation: ${t3}`);
              i2 = "up";
            }
          } else i2 = t2[2]?.toLowerCase() || "unknown";
          const h2 = t2.find((t3) => Array.isArray(t3) && "ORDER" === t3[0]), e2 = h2 ? parseInt(h2[1], 10) : null, n2 = t2.find((t3) => Array.isArray(t3) && ("LENGTHUNIT" === t3[0] || "ANGLEUNIT" === t3[0] || "SCALEUNIT" === t3[0]));
          return { name: s2, direction: i2, unit: this.convertUnit(n2), order: e2 };
        }
        static extractAxes(t2) {
          return t2.filter((t3) => Array.isArray(t3) && "AXIS" === t3[0]).map((t3) => this.convertAxis(t3)).sort((t3, s2) => (t3.order || 0) - (s2.order || 0));
        }
        static convert(t2, s2 = {}) {
          switch (t2[0]) {
            case "PROJCRS":
              s2.type = "ProjectedCRS", s2.name = t2[1], s2.base_crs = t2.find((t3) => Array.isArray(t3) && "BASEGEOGCRS" === t3[0]) ? this.convert(t2.find((t3) => Array.isArray(t3) && "BASEGEOGCRS" === t3[0])) : null, s2.conversion = t2.find((t3) => Array.isArray(t3) && "CONVERSION" === t3[0]) ? this.convert(t2.find((t3) => Array.isArray(t3) && "CONVERSION" === t3[0])) : null;
              const i2 = t2.find((t3) => Array.isArray(t3) && "CS" === t3[0]);
              i2 && (s2.coordinate_system = { type: i2[1], axis: this.extractAxes(t2) });
              const a3 = t2.find((t3) => Array.isArray(t3) && "LENGTHUNIT" === t3[0]);
              if (a3) {
                const t3 = this.convertUnit(a3);
                s2.coordinate_system.unit = t3;
              }
              s2.id = this.getId(t2);
              break;
            case "BASEGEOGCRS":
            case "GEOGCRS":
              s2.type = "GeographicCRS", s2.name = t2[1];
              const h2 = t2.find((t3) => Array.isArray(t3) && ("DATUM" === t3[0] || "ENSEMBLE" === t3[0]));
              if (h2) {
                const i3 = this.convert(h2);
                "ENSEMBLE" === h2[0] ? s2.datum_ensemble = i3 : s2.datum = i3;
                const a4 = t2.find((t3) => Array.isArray(t3) && "PRIMEM" === t3[0]);
                a4 && "Greenwich" !== a4[1] && (i3.prime_meridian = { name: a4[1], longitude: parseFloat(a4[2]) });
              }
              s2.coordinate_system = { type: "ellipsoidal", axis: this.extractAxes(t2) }, s2.id = this.getId(t2);
              break;
            case "DATUM":
              s2.type = "GeodeticReferenceFrame", s2.name = t2[1], s2.ellipsoid = t2.find((t3) => Array.isArray(t3) && "ELLIPSOID" === t3[0]) ? this.convert(t2.find((t3) => Array.isArray(t3) && "ELLIPSOID" === t3[0])) : null;
              break;
            case "ENSEMBLE":
              s2.type = "DatumEnsemble", s2.name = t2[1], s2.members = t2.filter((t3) => Array.isArray(t3) && "MEMBER" === t3[0]).map((t3) => ({ type: "DatumEnsembleMember", name: t3[1], id: this.getId(t3) }));
              const e2 = t2.find((t3) => Array.isArray(t3) && "ENSEMBLEACCURACY" === t3[0]);
              e2 && (s2.accuracy = parseFloat(e2[1]));
              const n2 = t2.find((t3) => Array.isArray(t3) && "ELLIPSOID" === t3[0]);
              n2 && (s2.ellipsoid = this.convert(n2)), s2.id = this.getId(t2);
              break;
            case "ELLIPSOID":
              s2.type = "Ellipsoid", s2.name = t2[1], s2.semi_major_axis = parseFloat(t2[2]), s2.inverse_flattening = parseFloat(t2[3]), t2.find((t3) => Array.isArray(t3) && "LENGTHUNIT" === t3[0]) && this.convert(t2.find((t3) => Array.isArray(t3) && "LENGTHUNIT" === t3[0]), s2);
              break;
            case "CONVERSION":
              s2.type = "Conversion", s2.name = t2[1], s2.method = t2.find((t3) => Array.isArray(t3) && "METHOD" === t3[0]) ? this.convert(t2.find((t3) => Array.isArray(t3) && "METHOD" === t3[0])) : null, s2.parameters = t2.filter((t3) => Array.isArray(t3) && "PARAMETER" === t3[0]).map((t3) => this.convert(t3));
              break;
            case "METHOD":
              s2.type = "Method", s2.name = t2[1], s2.id = this.getId(t2);
              break;
            case "PARAMETER":
              s2.type = "Parameter", s2.name = t2[1], s2.value = parseFloat(t2[2]), s2.unit = this.convertUnit(t2.find((t3) => Array.isArray(t3) && ("LENGTHUNIT" === t3[0] || "ANGLEUNIT" === t3[0] || "SCALEUNIT" === t3[0]))), s2.id = this.getId(t2);
              break;
            case "BOUNDCRS":
              s2.type = "BoundCRS";
              const r2 = t2.find((t3) => Array.isArray(t3) && "SOURCECRS" === t3[0]);
              if (r2) {
                const t3 = r2.find((t4) => Array.isArray(t4));
                s2.source_crs = t3 ? this.convert(t3) : null;
              }
              const o2 = t2.find((t3) => Array.isArray(t3) && "TARGETCRS" === t3[0]);
              if (o2) {
                const t3 = o2.find((t4) => Array.isArray(t4));
                s2.target_crs = t3 ? this.convert(t3) : null;
              }
              const l2 = t2.find((t3) => Array.isArray(t3) && "ABRIDGEDTRANSFORMATION" === t3[0]);
              s2.transformation = l2 ? this.convert(l2) : null;
              break;
            case "ABRIDGEDTRANSFORMATION":
              if (s2.type = "Transformation", s2.name = t2[1], s2.method = t2.find((t3) => Array.isArray(t3) && "METHOD" === t3[0]) ? this.convert(t2.find((t3) => Array.isArray(t3) && "METHOD" === t3[0])) : null, s2.parameters = t2.filter((t3) => Array.isArray(t3) && ("PARAMETER" === t3[0] || "PARAMETERFILE" === t3[0])).map((t3) => "PARAMETER" === t3[0] ? this.convert(t3) : "PARAMETERFILE" === t3[0] ? { name: t3[1], value: t3[2], id: { authority: "EPSG", code: 8656 } } : void 0), 7 === s2.parameters.length) {
                const t3 = s2.parameters[6];
                "Scale difference" === t3.name && (t3.value = Math.round(1e12 * (t3.value - 1)) / 1e6);
              }
              s2.id = this.getId(t2);
              break;
            case "AXIS":
              s2.coordinate_system || (s2.coordinate_system = { type: "unspecified", axis: [] }), s2.coordinate_system.axis.push(this.convertAxis(t2));
              break;
            case "LENGTHUNIT":
              const c2 = this.convertUnit(t2, "LinearUnit");
              s2.coordinate_system && s2.coordinate_system.axis && s2.coordinate_system.axis.forEach((t3) => {
                t3.unit || (t3.unit = c2);
              }), c2.conversion_factor && 1 !== c2.conversion_factor && s2.semi_major_axis && (s2.semi_major_axis = { value: s2.semi_major_axis, unit: c2 });
              break;
            default:
              s2.keyword = t2[0];
          }
          return s2;
        }
      }
      class d extends f {
        static convert(t2, s2 = {}) {
          return super.convert(t2, s2), "Cartesian" === s2.coordinate_system?.subtype && delete s2.coordinate_system, s2.usage && delete s2.usage, s2;
        }
      }
      class p extends f {
        static convert(t2, s2 = {}) {
          super.convert(t2, s2);
          const i2 = t2.find((t3) => Array.isArray(t3) && "CS" === t3[0]);
          i2 && (s2.coordinate_system = { subtype: i2[1], axis: this.extractAxes(t2) });
          const a3 = t2.find((t3) => Array.isArray(t3) && "USAGE" === t3[0]);
          return a3 && (s2.usage = { scope: a3.find((t3) => Array.isArray(t3) && "SCOPE" === t3[0])?.[1], area: a3.find((t3) => Array.isArray(t3) && "AREA" === t3[0])?.[1], bbox: a3.find((t3) => Array.isArray(t3) && "BBOX" === t3[0])?.slice(1) }), s2;
        }
      }
      function m(t2) {
        const s2 = function(t3) {
          return t3.find((t4) => Array.isArray(t4) && "USAGE" === t4[0]) ? "2019" : (t3.find((t4) => Array.isArray(t4) && "CS" === t4[0]) || "BOUNDCRS" === t3[0] || "PROJCRS" === t3[0] || t3[0], "2015");
        }(t2);
        return ("2019" === s2 ? p : d).convert(t2);
      }
      var y = /\s/, S = /[A-Za-z]/, E4 = /[A-Za-z84_]/, w = /[,\]]/, v = /[\d\.E\-\+]/;
      function G(t2) {
        if ("string" != typeof t2) throw new Error("not a string");
        this.text = t2.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = 1;
      }
      function x(t2, s2, i2) {
        Array.isArray(s2) && (i2.unshift(s2), s2 = null);
        var a3 = s2 ? {} : t2, h2 = i2.reduce(function(t3, s3) {
          return P(s3, t3), t3;
        }, a3);
        s2 && (t2[s2] = h2);
      }
      function P(t2, s2) {
        if (Array.isArray(t2)) {
          var i2 = t2.shift();
          if ("PARAMETER" === i2 && (i2 = t2.shift()), 1 === t2.length) return Array.isArray(t2[0]) ? (s2[i2] = {}, void P(t2[0], s2[i2])) : void (s2[i2] = t2[0]);
          if (t2.length) if ("TOWGS84" !== i2) {
            if ("AXIS" === i2) return i2 in s2 || (s2[i2] = []), void s2[i2].push(t2);
            var a3;
            switch (Array.isArray(i2) || (s2[i2] = {}), i2) {
              case "UNIT":
              case "PRIMEM":
              case "VERT_DATUM":
                return s2[i2] = { name: t2[0].toLowerCase(), convert: t2[1] }, void (3 === t2.length && P(t2[2], s2[i2]));
              case "SPHEROID":
              case "ELLIPSOID":
                return s2[i2] = { name: t2[0], a: t2[1], rf: t2[2] }, void (4 === t2.length && P(t2[3], s2[i2]));
              case "EDATUM":
              case "ENGINEERINGDATUM":
              case "LOCAL_DATUM":
              case "DATUM":
              case "VERT_CS":
              case "VERTCRS":
              case "VERTICALCRS":
                return t2[0] = ["name", t2[0]], void x(s2, i2, t2);
              case "COMPD_CS":
              case "COMPOUNDCRS":
              case "FITTED_CS":
              case "PROJECTEDCRS":
              case "PROJCRS":
              case "GEOGCS":
              case "GEOCCS":
              case "PROJCS":
              case "LOCAL_CS":
              case "GEODCRS":
              case "GEODETICCRS":
              case "GEODETICDATUM":
              case "ENGCRS":
              case "ENGINEERINGCRS":
                return t2[0] = ["name", t2[0]], x(s2, i2, t2), void (s2[i2].type = i2);
              default:
                for (a3 = -1; ++a3 < t2.length; ) if (!Array.isArray(t2[a3])) return P(t2, s2[i2]);
                return x(s2, i2, t2);
            }
          } else s2[i2] = t2;
          else s2[i2] = true;
        } else s2[t2] = true;
      }
      G.prototype.readCharicter = function() {
        var t2 = this.text[this.place++];
        if (4 !== this.state) for (; y.test(t2); ) {
          if (this.place >= this.text.length) return;
          t2 = this.text[this.place++];
        }
        switch (this.state) {
          case 1:
            return this.neutral(t2);
          case 2:
            return this.keyword(t2);
          case 4:
            return this.quoted(t2);
          case 5:
            return this.afterquote(t2);
          case 3:
            return this.number(t2);
          case -1:
            return;
        }
      }, G.prototype.afterquote = function(t2) {
        if ('"' === t2) return this.word += '"', void (this.state = 4);
        if (w.test(t2)) return this.word = this.word.trim(), void this.afterItem(t2);
        throw new Error(`havn't handled "` + t2 + '" in afterquote yet, index ' + this.place);
      }, G.prototype.afterItem = function(t2) {
        return "," === t2 ? (null !== this.word && this.currentObject.push(this.word), this.word = null, void (this.state = 1)) : "]" === t2 ? (this.level--, null !== this.word && (this.currentObject.push(this.word), this.word = null), this.state = 1, this.currentObject = this.stack.pop(), void (this.currentObject || (this.state = -1))) : void 0;
      }, G.prototype.number = function(t2) {
        if (!v.test(t2)) {
          if (w.test(t2)) return this.word = parseFloat(this.word), void this.afterItem(t2);
          throw new Error(`havn't handled "` + t2 + '" in number yet, index ' + this.place);
        }
        this.word += t2;
      }, G.prototype.quoted = function(t2) {
        '"' !== t2 ? this.word += t2 : this.state = 5;
      }, G.prototype.keyword = function(t2) {
        if (E4.test(t2)) this.word += t2;
        else {
          if ("[" === t2) {
            var s2 = [];
            return s2.push(this.word), this.level++, null === this.root ? this.root = s2 : this.currentObject.push(s2), this.stack.push(this.currentObject), this.currentObject = s2, void (this.state = 1);
          }
          if (!w.test(t2)) throw new Error(`havn't handled "` + t2 + '" in keyword yet, index ' + this.place);
          this.afterItem(t2);
        }
      }, G.prototype.neutral = function(t2) {
        if (S.test(t2)) return this.word = t2, void (this.state = 2);
        if ('"' === t2) return this.word = "", void (this.state = 4);
        if (v.test(t2)) return this.word = t2, void (this.state = 3);
        if (!w.test(t2)) throw new Error(`havn't handled "` + t2 + '" in neutral yet, index ' + this.place);
        this.afterItem(t2);
      }, G.prototype.output = function() {
        for (; this.place < this.text.length; ) this.readCharicter();
        if (-1 === this.state) return this.root;
        throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
      };
      function b(t2) {
        return 0.017453292519943295 * t2;
      }
      function A(t2) {
        const s2 = (t2.projName || "").toLowerCase().replace(/_/g, " ");
        t2.long0 || !t2.longc || "albers conic equal area" !== s2 && "lambert azimuthal equal area" !== s2 || (t2.long0 = t2.longc), t2.lat_ts || !t2.lat1 || "stereographic south pole" !== s2 && "polar stereographic (variant b)" !== s2 ? t2.lat_ts || !t2.lat0 || "polar stereographic" !== s2 && "polar stereographic (variant a)" !== s2 || (t2.lat_ts = t2.lat0, t2.lat0 = b(t2.lat0 > 0 ? 90 : -90), delete t2.lat1) : (t2.lat0 = b(t2.lat1 > 0 ? 90 : -90), t2.lat_ts = t2.lat1, delete t2.lat1);
      }
      function C(t2) {
        let s2 = { units: null, to_meter: void 0 };
        return "string" == typeof t2 ? (s2.units = t2.toLowerCase(), "metre" === s2.units && (s2.units = "meter"), "meter" === s2.units && (s2.to_meter = 1)) : t2?.name && (s2.units = t2.name.toLowerCase(), "metre" === s2.units && (s2.units = "meter"), s2.to_meter = t2.conversion_factor), s2;
      }
      function N(t2) {
        return "object" == typeof t2 ? t2.value * t2.unit.conversion_factor : t2;
      }
      function I(t2, s2) {
        t2.ellipsoid.radius ? (s2.a = t2.ellipsoid.radius, s2.rf = 0) : (s2.a = N(t2.ellipsoid.semi_major_axis), void 0 !== t2.ellipsoid.inverse_flattening ? s2.rf = t2.ellipsoid.inverse_flattening : void 0 !== t2.ellipsoid.semi_major_axis && void 0 !== t2.ellipsoid.semi_minor_axis && (s2.rf = s2.a / (s2.a - N(t2.ellipsoid.semi_minor_axis))));
      }
      function L(t2, s2 = {}) {
        return t2 && "object" == typeof t2 ? "BoundCRS" === t2.type ? (L(t2.source_crs, s2), t2.transformation && ("NTv2" === t2.transformation.method?.name ? s2.nadgrids = t2.transformation.parameters[0].value : s2.datum_params = t2.transformation.parameters.map((t3) => t3.value)), s2) : (Object.keys(t2).forEach((i2) => {
          const a3 = t2[i2];
          if (null !== a3) switch (i2) {
            case "name":
              if (s2.srsCode) break;
              s2.name = a3, s2.srsCode = a3;
              break;
            case "type":
              "GeographicCRS" === a3 ? s2.projName = "longlat" : "ProjectedCRS" === a3 && (s2.projName = t2.conversion?.method?.name);
              break;
            case "datum":
            case "datum_ensemble":
              a3.ellipsoid && (s2.ellps = a3.ellipsoid.name, I(a3, s2)), a3.prime_meridian && (s2.from_greenwich = a3.prime_meridian.longitude * Math.PI / 180);
              break;
            case "ellipsoid":
              s2.ellps = a3.name, I(a3, s2);
              break;
            case "prime_meridian":
              s2.long0 = (a3.longitude || 0) * Math.PI / 180;
              break;
            case "coordinate_system":
              if (a3.axis) {
                if (s2.axis = a3.axis.map((t3) => {
                  const s3 = t3.direction;
                  if ("east" === s3) return "e";
                  if ("north" === s3) return "n";
                  if ("west" === s3) return "w";
                  if ("south" === s3) return "s";
                  throw new Error(`Unknown axis direction: ${s3}`);
                }).join("") + "u", a3.unit) {
                  const { units: t3, to_meter: i3 } = C(a3.unit);
                  s2.units = t3, s2.to_meter = i3;
                } else if (a3.axis[0]?.unit) {
                  const { units: t3, to_meter: i3 } = C(a3.axis[0].unit);
                  s2.units = t3, s2.to_meter = i3;
                }
              }
              break;
            case "id":
              a3.authority && a3.code && (s2.title = a3.authority + ":" + a3.code);
              break;
            case "conversion":
              a3.method && a3.method.name && (s2.projName = a3.method.name), a3.parameters && a3.parameters.forEach((t3) => {
                const i3 = t3.name.toLowerCase().replace(/\s+/g, "_"), a4 = t3.value;
                t3.unit && t3.unit.conversion_factor ? s2[i3] = a4 * t3.unit.conversion_factor : "degree" === t3.unit ? s2[i3] = a4 * Math.PI / 180 : s2[i3] = a4;
              });
              break;
            case "unit":
              a3.name && (s2.units = a3.name.toLowerCase(), "metre" === s2.units && (s2.units = "meter")), a3.conversion_factor && (s2.to_meter = a3.conversion_factor);
              break;
            case "base_crs":
              L(a3, s2), s2.datumCode = a3.id ? a3.id.authority + "_" + a3.id.code : a3.name;
          }
        }), void 0 !== s2.latitude_of_false_origin && (s2.lat0 = s2.latitude_of_false_origin), void 0 !== s2.longitude_of_false_origin && (s2.long0 = s2.longitude_of_false_origin), void 0 !== s2.latitude_of_standard_parallel && (s2.lat0 = s2.latitude_of_standard_parallel, s2.lat1 = s2.latitude_of_standard_parallel), void 0 !== s2.latitude_of_1st_standard_parallel && (s2.lat1 = s2.latitude_of_1st_standard_parallel), void 0 !== s2.latitude_of_2nd_standard_parallel && (s2.lat2 = s2.latitude_of_2nd_standard_parallel), void 0 !== s2.latitude_of_projection_centre && (s2.lat0 = s2.latitude_of_projection_centre), void 0 !== s2.longitude_of_projection_centre && (s2.longc = s2.longitude_of_projection_centre), void 0 !== s2.easting_at_false_origin && (s2.x0 = s2.easting_at_false_origin), void 0 !== s2.northing_at_false_origin && (s2.y0 = s2.northing_at_false_origin), void 0 !== s2.latitude_of_natural_origin && (s2.lat0 = s2.latitude_of_natural_origin), void 0 !== s2.longitude_of_natural_origin && (s2.long0 = s2.longitude_of_natural_origin), void 0 !== s2.longitude_of_origin && (s2.long0 = s2.longitude_of_origin), void 0 !== s2.false_easting && (s2.x0 = s2.false_easting), s2.easting_at_projection_centre && (s2.x0 = s2.easting_at_projection_centre), void 0 !== s2.false_northing && (s2.y0 = s2.false_northing), s2.northing_at_projection_centre && (s2.y0 = s2.northing_at_projection_centre), void 0 !== s2.standard_parallel_1 && (s2.lat1 = s2.standard_parallel_1), void 0 !== s2.standard_parallel_2 && (s2.lat2 = s2.standard_parallel_2), void 0 !== s2.scale_factor_at_natural_origin && (s2.k0 = s2.scale_factor_at_natural_origin), void 0 !== s2.scale_factor_at_projection_centre && (s2.k0 = s2.scale_factor_at_projection_centre), void 0 !== s2.scale_factor_on_pseudo_standard_parallel && (s2.k0 = s2.scale_factor_on_pseudo_standard_parallel), void 0 !== s2.azimuth && (s2.alpha = s2.azimuth), void 0 !== s2.azimuth_at_projection_centre && (s2.alpha = s2.azimuth_at_projection_centre), s2.angle_from_rectified_to_skew_grid && (s2.rectified_grid_angle = s2.angle_from_rectified_to_skew_grid), A(s2), s2) : t2;
      }
      var O = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
      function R2(t2) {
        for (var s2 = Object.keys(t2), i2 = 0, a3 = s2.length; i2 < a3; ++i2) {
          var h2 = s2[i2];
          -1 !== O.indexOf(h2) && q(t2[h2]), "object" == typeof t2[h2] && R2(t2[h2]);
        }
      }
      function q(t2) {
        if (t2.AUTHORITY) {
          var s2 = Object.keys(t2.AUTHORITY)[0];
          s2 && s2 in t2.AUTHORITY && (t2.title = s2 + ":" + t2.AUTHORITY[s2]);
        }
        if ("GEOGCS" === t2.type ? t2.projName = "longlat" : "LOCAL_CS" === t2.type ? (t2.projName = "identity", t2.local = true) : "object" == typeof t2.PROJECTION ? t2.projName = Object.keys(t2.PROJECTION)[0] : t2.projName = t2.PROJECTION, t2.AXIS) {
          for (var i2 = "", a3 = 0, h2 = t2.AXIS.length; a3 < h2; ++a3) {
            var e2 = [t2.AXIS[a3][0].toLowerCase(), t2.AXIS[a3][1].toLowerCase()];
            -1 !== e2[0].indexOf("north") || ("y" === e2[0] || "lat" === e2[0]) && "north" === e2[1] ? i2 += "n" : -1 !== e2[0].indexOf("south") || ("y" === e2[0] || "lat" === e2[0]) && "south" === e2[1] ? i2 += "s" : -1 !== e2[0].indexOf("east") || ("x" === e2[0] || "lon" === e2[0]) && "east" === e2[1] ? i2 += "e" : -1 === e2[0].indexOf("west") && ("x" !== e2[0] && "lon" !== e2[0] || "west" !== e2[1]) || (i2 += "w");
          }
          2 === i2.length && (i2 += "u"), 3 === i2.length && (t2.axis = i2);
        }
        t2.UNIT && (t2.units = t2.UNIT.name.toLowerCase(), "metre" === t2.units && (t2.units = "meter"), t2.UNIT.convert && ("GEOGCS" === t2.type ? t2.DATUM && t2.DATUM.SPHEROID && (t2.to_meter = t2.UNIT.convert * t2.DATUM.SPHEROID.a) : t2.to_meter = t2.UNIT.convert));
        var n2 = t2.GEOGCS;
        function r2(s3) {
          return s3 * (t2.to_meter || 1);
        }
        "GEOGCS" === t2.type && (n2 = t2), n2 && (n2.DATUM ? t2.datumCode = n2.DATUM.name.toLowerCase() : t2.datumCode = n2.name.toLowerCase(), "d_" === t2.datumCode.slice(0, 2) && (t2.datumCode = t2.datumCode.slice(2)), "new_zealand_1949" === t2.datumCode && (t2.datumCode = "nzgd49"), "wgs_1984" !== t2.datumCode && "world_geodetic_system_1984" !== t2.datumCode || ("Mercator_Auxiliary_Sphere" === t2.PROJECTION && (t2.sphere = true), t2.datumCode = "wgs84"), "belge_1972" === t2.datumCode && (t2.datumCode = "rnb72"), n2.DATUM && n2.DATUM.SPHEROID && (t2.ellps = n2.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), "international" === t2.ellps.toLowerCase().slice(0, 13) && (t2.ellps = "intl"), t2.a = n2.DATUM.SPHEROID.a, t2.rf = parseFloat(n2.DATUM.SPHEROID.rf, 10)), n2.DATUM && n2.DATUM.TOWGS84 && (t2.datum_params = n2.DATUM.TOWGS84), ~t2.datumCode.indexOf("osgb_1936") && (t2.datumCode = "osgb36"), ~t2.datumCode.indexOf("osni_1952") && (t2.datumCode = "osni52"), (~t2.datumCode.indexOf("tm65") || ~t2.datumCode.indexOf("geodetic_datum_of_1965")) && (t2.datumCode = "ire65"), "ch1903+" === t2.datumCode && (t2.datumCode = "ch1903"), ~t2.datumCode.indexOf("israel") && (t2.datumCode = "isr93")), t2.b && !isFinite(t2.b) && (t2.b = t2.a), t2.rectified_grid_angle && (t2.rectified_grid_angle = b(t2.rectified_grid_angle));
        [["standard_parallel_1", "Standard_Parallel_1"], ["standard_parallel_1", "Latitude of 1st standard parallel"], ["standard_parallel_2", "Standard_Parallel_2"], ["standard_parallel_2", "Latitude of 2nd standard parallel"], ["false_easting", "False_Easting"], ["false_easting", "False easting"], ["false-easting", "Easting at false origin"], ["false_northing", "False_Northing"], ["false_northing", "False northing"], ["false_northing", "Northing at false origin"], ["central_meridian", "Central_Meridian"], ["central_meridian", "Longitude of natural origin"], ["central_meridian", "Longitude of false origin"], ["latitude_of_origin", "Latitude_Of_Origin"], ["latitude_of_origin", "Central_Parallel"], ["latitude_of_origin", "Latitude of natural origin"], ["latitude_of_origin", "Latitude of false origin"], ["scale_factor", "Scale_Factor"], ["k0", "scale_factor"], ["latitude_of_center", "Latitude_Of_Center"], ["latitude_of_center", "Latitude_of_center"], ["lat0", "latitude_of_center", b], ["longitude_of_center", "Longitude_Of_Center"], ["longitude_of_center", "Longitude_of_center"], ["longc", "longitude_of_center", b], ["x0", "false_easting", r2], ["y0", "false_northing", r2], ["long0", "central_meridian", b], ["lat0", "latitude_of_origin", b], ["lat0", "standard_parallel_1", b], ["lat1", "standard_parallel_1", b], ["lat2", "standard_parallel_2", b], ["azimuth", "Azimuth"], ["alpha", "azimuth", b], ["srsCode", "name"]].forEach(function(s3) {
          return function(t3, s4) {
            var i3 = s4[0], a4 = s4[1];
            !(i3 in t3) && a4 in t3 && (t3[i3] = t3[a4], 3 === s4.length && (t3[i3] = s4[2](t3[i3])));
          }(t2, s3);
        }), A(t2);
      }
      function T(t2) {
        if ("object" == typeof t2) return L(t2);
        const s2 = function(t3) {
          const s3 = t3.toUpperCase();
          return s3.includes("PROJCRS") || s3.includes("GEOGCRS") || s3.includes("BOUNDCRS") || s3.includes("VERTCRS") || s3.includes("LENGTHUNIT") || s3.includes("ANGLEUNIT") || s3.includes("SCALEUNIT") ? "WKT2" : (s3.includes("PROJCS") || s3.includes("GEOGCS") || s3.includes("LOCAL_CS") || s3.includes("VERT_CS") || s3.includes("UNIT"), "WKT1");
        }(t2);
        var i2 = new G(t2).output();
        if ("WKT2" === s2) {
          return L(m(i2));
        }
        var a3 = i2[0], h2 = {};
        return P(i2, h2), R2(h2), h2[a3];
      }
      function k(t2) {
        var s2 = this;
        if (2 === arguments.length) {
          var i2 = arguments[1];
          "string" == typeof i2 ? "+" === i2.charAt(0) ? k[t2] = g(arguments[1]) : k[t2] = T(arguments[1]) : k[t2] = i2;
        } else if (1 === arguments.length) {
          if (Array.isArray(t2)) return t2.map(function(t3) {
            Array.isArray(t3) ? k.apply(s2, t3) : k(t3);
          });
          if ("string" == typeof t2) {
            if (t2 in k) return k[t2];
          } else "EPSG" in t2 ? k["EPSG:" + t2.EPSG] = t2 : "ESRI" in t2 ? k["ESRI:" + t2.ESRI] = t2 : "IAU2000" in t2 ? k["IAU2000:" + t2.IAU2000] = t2 : console.log(t2);
          return;
        }
      }
      !function(t2) {
        t2("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), t2("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), t2("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
        for (var s2 = 1; s2 <= 60; ++s2) t2("EPSG:" + (32600 + s2), "+proj=utm +zone=" + s2 + " +datum=WGS84 +units=m"), t2("EPSG:" + (32700 + s2), "+proj=utm +zone=" + s2 + " +south +datum=WGS84 +units=m");
        t2.WGS84 = t2["EPSG:4326"], t2["EPSG:3785"] = t2["EPSG:3857"], t2.GOOGLE = t2["EPSG:3857"], t2["EPSG:900913"] = t2["EPSG:3857"], t2["EPSG:102113"] = t2["EPSG:3857"];
      }(k);
      var D = ["3857", "900913", "3785", "102113"];
      function j(t2) {
        if (!/* @__PURE__ */ function(t3) {
          return "string" == typeof t3;
        }(t2)) return t2.projName ? t2 : T(t2);
        if (function(t3) {
          return t3 in k;
        }(t2)) return k[t2];
        if (function(t3) {
          return 0 !== t3.indexOf("+") && -1 !== t3.indexOf("[") || "object" == typeof t3 && !("srsCode" in t3);
        }(t2)) {
          var s2 = T(t2);
          if (function(t3) {
            var s3 = M(t3, "authority");
            if (s3) {
              var i3 = M(s3, "epsg");
              return i3 && D.indexOf(i3) > -1;
            }
          }(s2)) return k["EPSG:3857"];
          var i2 = function(t3) {
            var s3 = M(t3, "extension");
            if (s3) return M(s3, "proj4");
          }(s2);
          return i2 ? g(i2) : s2;
        }
        return function(t3) {
          return "+" === t3[0];
        }(t2) ? g(t2) : void 0;
      }
      function U(t2, s2) {
        var i2, a3;
        if (t2 = t2 || {}, !s2) return t2;
        for (a3 in s2) void 0 !== (i2 = s2[a3]) && (t2[a3] = i2);
        return t2;
      }
      function F(t2, s2, i2) {
        var a3 = t2 * s2;
        return i2 / Math.sqrt(1 - a3 * a3);
      }
      function B(t2) {
        return t2 < 0 ? -1 : 1;
      }
      function z(t2) {
        return Math.abs(t2) <= l ? t2 : t2 - B(t2) * o;
      }
      function H(t2, s2, i2) {
        var h2 = t2 * i2, e2 = 0.5 * t2;
        return h2 = Math.pow((1 - h2) / (1 + h2), e2), Math.tan(0.5 * (a - s2)) / h2;
      }
      function W(t2, s2) {
        for (var i2, h2, e2 = 0.5 * t2, n2 = a - 2 * Math.atan(s2), r2 = 0; r2 <= 15; r2++) if (i2 = t2 * Math.sin(n2), n2 += h2 = a - 2 * Math.atan(s2 * Math.pow((1 - i2) / (1 + i2), e2)) - n2, Math.abs(h2) <= 1e-10) return n2;
        return -9999;
      }
      function Q(t2) {
        return t2;
      }
      var K = [{ init: function() {
        var t2 = this.b / this.a;
        this.es = 1 - t2 * t2, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = F(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
      }, forward: function(t2) {
        var s2, i2, e2 = t2.x, o2 = t2.y;
        if (o2 * n > 90 && o2 * n < -90 && e2 * n > 180 && e2 * n < -180) return null;
        if (Math.abs(Math.abs(o2) - a) <= h) return null;
        if (this.sphere) s2 = this.x0 + this.a * this.k0 * z(e2 - this.long0), i2 = this.y0 + this.a * this.k0 * Math.log(Math.tan(r + 0.5 * o2));
        else {
          var l2 = Math.sin(o2), c2 = H(this.e, o2, l2);
          s2 = this.x0 + this.a * this.k0 * z(e2 - this.long0), i2 = this.y0 - this.a * this.k0 * Math.log(c2);
        }
        return t2.x = s2, t2.y = i2, t2;
      }, inverse: function(t2) {
        var s2, i2, h2 = t2.x - this.x0, e2 = t2.y - this.y0;
        if (this.sphere) i2 = a - 2 * Math.atan(Math.exp(-e2 / (this.a * this.k0)));
        else {
          var n2 = Math.exp(-e2 / (this.a * this.k0));
          if (-9999 === (i2 = W(this.e, n2))) return null;
        }
        return s2 = z(this.long0 + h2 / (this.a * this.k0)), t2.x = s2, t2.y = i2, t2;
      }, names: ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "Mercator_Variant_A", "merc"] }, { init: function() {
      }, forward: Q, inverse: Q, names: ["longlat", "identity"] }], X = {}, V = [];
      function J(t2, s2) {
        var i2 = V.length;
        return t2.names ? (V[i2] = t2, t2.names.forEach(function(t3) {
          X[t3.toLowerCase()] = i2;
        }), this) : (console.log(s2), true);
      }
      function Z(t2) {
        return t2.replace(/[-\(\)\s]+/g, " ").trim().replace(/ /g, "_");
      }
      var Y = { start: function() {
        K.forEach(J);
      }, add: J, get: function(t2) {
        if (!t2) return false;
        var s2 = t2.toLowerCase();
        return void 0 !== X[s2] && V[X[s2]] || (s2 = Z(s2)) in X && V[X[s2]] ? V[X[s2]] : void 0;
      } }, $ = { MERIT: { a: 6378137, rf: 298.257, ellipseName: "MERIT 1983" }, SGS85: { a: 6378136, rf: 298.257, ellipseName: "Soviet Geodetic System 85" }, GRS80: { a: 6378137, rf: 298.257222101, ellipseName: "GRS 1980(IUGG, 1980)" }, IAU76: { a: 6378140, rf: 298.257, ellipseName: "IAU 1976" }, airy: { a: 6377563396e-3, b: 635625691e-2, ellipseName: "Airy 1830" }, APL4: { a: 6378137, rf: 298.25, ellipseName: "Appl. Physics. 1965" }, NWL9D: { a: 6378145, rf: 298.25, ellipseName: "Naval Weapons Lab., 1965" }, mod_airy: { a: 6377340189e-3, b: 6356034446e-3, ellipseName: "Modified Airy" }, andrae: { a: 637710443e-2, rf: 300, ellipseName: "Andrae 1876 (Den., Iclnd.)" }, aust_SA: { a: 6378160, rf: 298.25, ellipseName: "Australian Natl & S. Amer. 1969" }, GRS67: { a: 6378160, rf: 298.247167427, ellipseName: "GRS 67(IUGG 1967)" }, bessel: { a: 6377397155e-3, rf: 299.1528128, ellipseName: "Bessel 1841" }, bess_nam: { a: 6377483865e-3, rf: 299.1528128, ellipseName: "Bessel 1841 (Namibia)" }, clrk66: { a: 63782064e-1, b: 63565838e-1, ellipseName: "Clarke 1866" }, clrk80: { a: 6378249145e-3, rf: 293.4663, ellipseName: "Clarke 1880 mod." }, clrk80ign: { a: 63782492e-1, b: 6356515, rf: 293.4660213, ellipseName: "Clarke 1880 (IGN)" }, clrk58: { a: 6378293645208759e-9, rf: 294.2606763692654, ellipseName: "Clarke 1858" }, CPM: { a: 63757387e-1, rf: 334.29, ellipseName: "Comm. des Poids et Mesures 1799" }, delmbr: { a: 6376428, rf: 311.5, ellipseName: "Delambre 1810 (Belgium)" }, engelis: { a: 637813605e-2, rf: 298.2566, ellipseName: "Engelis 1985" }, evrst30: { a: 6377276345e-3, rf: 300.8017, ellipseName: "Everest 1830" }, evrst48: { a: 6377304063e-3, rf: 300.8017, ellipseName: "Everest 1948" }, evrst56: { a: 6377301243e-3, rf: 300.8017, ellipseName: "Everest 1956" }, evrst69: { a: 6377295664e-3, rf: 300.8017, ellipseName: "Everest 1969" }, evrstSS: { a: 6377298556e-3, rf: 300.8017, ellipseName: "Everest (Sabah & Sarawak)" }, fschr60: { a: 6378166, rf: 298.3, ellipseName: "Fischer (Mercury Datum) 1960" }, fschr60m: { a: 6378155, rf: 298.3, ellipseName: "Fischer 1960" }, fschr68: { a: 6378150, rf: 298.3, ellipseName: "Fischer 1968" }, helmert: { a: 6378200, rf: 298.3, ellipseName: "Helmert 1906" }, hough: { a: 6378270, rf: 297, ellipseName: "Hough" }, intl: { a: 6378388, rf: 297, ellipseName: "International 1909 (Hayford)" }, kaula: { a: 6378163, rf: 298.24, ellipseName: "Kaula 1961" }, lerch: { a: 6378139, rf: 298.257, ellipseName: "Lerch 1979" }, mprts: { a: 6397300, rf: 191, ellipseName: "Maupertius 1738" }, new_intl: { a: 63781575e-1, b: 63567722e-1, ellipseName: "New International 1967" }, plessis: { a: 6376523, rf: 6355863, ellipseName: "Plessis 1817 (France)" }, krass: { a: 6378245, rf: 298.3, ellipseName: "Krassovsky, 1942" }, SEasia: { a: 6378155, b: 63567733205e-4, ellipseName: "Southeast Asia" }, walbeck: { a: 6376896, b: 63558348467e-4, ellipseName: "Walbeck" }, WGS60: { a: 6378165, rf: 298.3, ellipseName: "WGS 60" }, WGS66: { a: 6378145, rf: 298.25, ellipseName: "WGS 66" }, WGS7: { a: 6378135, rf: 298.26, ellipseName: "WGS 72" }, WGS84: { a: 6378137, rf: 298.257223563, ellipseName: "WGS 84" }, sphere: { a: 6370997, b: 6370997, ellipseName: "Normal Sphere (r=6370997)" } };
      const tt = $.WGS84;
      var st = { wgs84: { towgs84: "0,0,0", ellipse: "WGS84", datumName: "WGS84" }, ch1903: { towgs84: "674.374,15.056,405.346", ellipse: "bessel", datumName: "swiss" }, ggrs87: { towgs84: "-199.87,74.79,246.62", ellipse: "GRS80", datumName: "Greek_Geodetic_Reference_System_1987" }, nad83: { towgs84: "0,0,0", ellipse: "GRS80", datumName: "North_American_Datum_1983" }, nad27: { nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat", ellipse: "clrk66", datumName: "North_American_Datum_1927" }, potsdam: { towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7", ellipse: "bessel", datumName: "Potsdam Rauenberg 1950 DHDN" }, carthage: { towgs84: "-263.0,6.0,431.0", ellipse: "clark80", datumName: "Carthage 1934 Tunisia" }, hermannskogel: { towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232", ellipse: "bessel", datumName: "Hermannskogel" }, mgi: { towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232", ellipse: "bessel", datumName: "Militar-Geographische Institut" }, osni52: { towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15", ellipse: "airy", datumName: "Irish National" }, ire65: { towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15", ellipse: "mod_airy", datumName: "Ireland 1965" }, rassadiran: { towgs84: "-133.63,-157.5,-158.62", ellipse: "intl", datumName: "Rassadiran" }, nzgd49: { towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993", ellipse: "intl", datumName: "New Zealand Geodetic Datum 1949" }, osgb36: { towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894", ellipse: "airy", datumName: "Ordnance Survey of Great Britain 1936" }, s_jtsk: { towgs84: "589,76,480", ellipse: "bessel", datumName: "S-JTSK (Ferro)" }, beduaram: { towgs84: "-106,-87,188", ellipse: "clrk80", datumName: "Beduaram" }, gunung_segara: { towgs84: "-403,684,41", ellipse: "bessel", datumName: "Gunung Segara Jakarta" }, rnb72: { towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1", ellipse: "intl", datumName: "Reseau National Belge 1972" }, EPSG_5451: { towgs84: "6.41,-49.05,-11.28,1.5657,0.5242,6.9718,-5.7649" }, IGNF_LURESG: { towgs84: "-192.986,13.673,-39.309,-0.4099,-2.9332,2.6881,0.43" }, EPSG_4614: { towgs84: "-119.4248,-303.65872,-11.00061,1.164298,0.174458,1.096259,3.657065" }, EPSG_4615: { towgs84: "-494.088,-312.129,279.877,-1.423,-1.013,1.59,-0.748" }, ESRI_37241: { towgs84: "-76.822,257.457,-12.817,2.136,-0.033,-2.392,-0.031" }, ESRI_37249: { towgs84: "-440.296,58.548,296.265,1.128,10.202,4.559,-0.438" }, ESRI_37245: { towgs84: "-511.151,-181.269,139.609,1.05,2.703,1.798,3.071" }, EPSG_4178: { towgs84: "24.9,-126.4,-93.2,-0.063,-0.247,-0.041,1.01" }, EPSG_4622: { towgs84: "-472.29,-5.63,-304.12,0.4362,-0.8374,0.2563,1.8984" }, EPSG_4625: { towgs84: "126.93,547.94,130.41,-2.7867,5.1612,-0.8584,13.8227" }, EPSG_5252: { towgs84: "0.023,0.036,-0.068,0.00176,0.00912,-0.01136,0.00439" }, EPSG_4314: { towgs84: "597.1,71.4,412.1,0.894,0.068,-1.563,7.58" }, EPSG_4282: { towgs84: "-178.3,-316.7,-131.5,5.278,6.077,10.979,19.166" }, EPSG_4231: { towgs84: "-83.11,-97.38,-117.22,0.0276,-0.2167,0.2147,0.1218" }, EPSG_4274: { towgs84: "-230.994,102.591,25.199,0.633,-0.239,0.9,1.95" }, EPSG_4134: { towgs84: "-180.624,-225.516,173.919,-0.81,-1.898,8.336,16.71006" }, EPSG_4254: { towgs84: "18.38,192.45,96.82,0.056,-0.142,-0.2,-0.0013" }, EPSG_4159: { towgs84: "-194.513,-63.978,-25.759,-3.4027,3.756,-3.352,-0.9175" }, EPSG_4687: { towgs84: "0.072,-0.507,-0.245,0.0183,-0.0003,0.007,-0.0093" }, EPSG_4227: { towgs84: "-83.58,-397.54,458.78,-17.595,-2.847,4.256,3.225" }, EPSG_4746: { towgs84: "599.4,72.4,419.2,-0.062,-0.022,-2.723,6.46" }, EPSG_4745: { towgs84: "612.4,77,440.2,-0.054,0.057,-2.797,2.55" }, EPSG_6311: { towgs84: "8.846,-4.394,-1.122,-0.00237,-0.146528,0.130428,0.783926" }, EPSG_4289: { towgs84: "565.7381,50.4018,465.2904,-1.91514,1.60363,-9.09546,4.07244" }, EPSG_4230: { towgs84: "-68.863,-134.888,-111.49,-0.53,-0.14,0.57,-3.4" }, EPSG_4154: { towgs84: "-123.02,-158.95,-168.47" }, EPSG_4156: { towgs84: "570.8,85.7,462.8,4.998,1.587,5.261,3.56" }, EPSG_4299: { towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15" }, EPSG_4179: { towgs84: "33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84" }, EPSG_4313: { towgs84: "-106.8686,52.2978,-103.7239,0.3366,-0.457,1.8422,-1.2747" }, EPSG_4194: { towgs84: "163.511,127.533,-159.789" }, EPSG_4195: { towgs84: "105,326,-102.5" }, EPSG_4196: { towgs84: "-45,417,-3.5" }, EPSG_4611: { towgs84: "-162.619,-276.959,-161.764,0.067753,-2.243649,-1.158827,-1.094246" }, EPSG_4633: { towgs84: "137.092,131.66,91.475,-1.9436,-11.5993,-4.3321,-7.4824" }, EPSG_4641: { towgs84: "-408.809,366.856,-412.987,1.8842,-0.5308,2.1655,-121.0993" }, EPSG_4643: { towgs84: "-480.26,-438.32,-643.429,16.3119,20.1721,-4.0349,-111.7002" }, EPSG_4300: { towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15" }, EPSG_4188: { towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15" }, EPSG_4660: { towgs84: "982.6087,552.753,-540.873,32.39344,-153.25684,-96.2266,16.805" }, EPSG_4662: { towgs84: "97.295,-263.247,310.882,-1.5999,0.8386,3.1409,13.3259" }, EPSG_3906: { towgs84: "577.88891,165.22205,391.18289,4.9145,-0.94729,-13.05098,7.78664" }, EPSG_4307: { towgs84: "-209.3622,-87.8162,404.6198,0.0046,3.4784,0.5805,-1.4547" }, EPSG_6892: { towgs84: "-76.269,-16.683,68.562,-6.275,10.536,-4.286,-13.686" }, EPSG_4690: { towgs84: "221.597,152.441,176.523,2.403,1.3893,0.884,11.4648" }, EPSG_4691: { towgs84: "218.769,150.75,176.75,3.5231,2.0037,1.288,10.9817" }, EPSG_4629: { towgs84: "72.51,345.411,79.241,-1.5862,-0.8826,-0.5495,1.3653" }, EPSG_4630: { towgs84: "165.804,216.213,180.26,-0.6251,-0.4515,-0.0721,7.4111" }, EPSG_4692: { towgs84: "217.109,86.452,23.711,0.0183,-0.0003,0.007,-0.0093" }, EPSG_9333: { towgs84: "0,0,0,-8.393,0.749,-10.276,0" }, EPSG_9059: { towgs84: "0,0,0" }, EPSG_4312: { towgs84: "601.705,84.263,485.227,4.7354,1.3145,5.393,-2.3887" }, EPSG_4123: { towgs84: "-96.062,-82.428,-121.753,4.801,0.345,-1.376,1.496" }, EPSG_4309: { towgs84: "-124.45,183.74,44.64,-0.4384,0.5446,-0.9706,-2.1365" }, ESRI_104106: { towgs84: "-283.088,-70.693,117.445,-1.157,0.059,-0.652,-4.058" }, EPSG_4281: { towgs84: "-219.247,-73.802,269.529" }, EPSG_4322: { towgs84: "0,0,4.5" }, EPSG_4324: { towgs84: "0,0,1.9" }, EPSG_4284: { towgs84: "43.822,-108.842,-119.585,1.455,-0.761,0.737,0.549" }, EPSG_4277: { towgs84: "446.448,-125.157,542.06,0.15,0.247,0.842,-20.489" }, EPSG_4207: { towgs84: "-282.1,-72.2,120,-1.529,0.145,-0.89,-4.46" }, EPSG_4688: { towgs84: "347.175,1077.618,2623.677,33.9058,-70.6776,9.4013,186.0647" }, EPSG_4689: { towgs84: "410.793,54.542,80.501,-2.5596,-2.3517,-0.6594,17.3218" }, EPSG_4720: { towgs84: "0,0,4.5" }, EPSG_4273: { towgs84: "278.3,93,474.5,7.889,0.05,-6.61,6.21" }, EPSG_4240: { towgs84: "204.64,834.74,293.8" }, EPSG_4817: { towgs84: "278.3,93,474.5,7.889,0.05,-6.61,6.21" }, ESRI_104131: { towgs84: "426.62,142.62,460.09,4.98,4.49,-12.42,-17.1" }, EPSG_4265: { towgs84: "-104.1,-49.1,-9.9,0.971,-2.917,0.714,-11.68" }, EPSG_4263: { towgs84: "-111.92,-87.85,114.5,1.875,0.202,0.219,0.032" }, EPSG_4298: { towgs84: "-689.5937,623.84046,-65.93566,-0.02331,1.17094,-0.80054,5.88536" }, EPSG_4270: { towgs84: "-253.4392,-148.452,386.5267,0.15605,0.43,-0.1013,-0.0424" }, EPSG_4229: { towgs84: "-121.8,98.1,-10.7" }, EPSG_4220: { towgs84: "-55.5,-348,-229.2" }, EPSG_4214: { towgs84: "12.646,-155.176,-80.863" }, EPSG_4232: { towgs84: "-345,3,223" }, EPSG_4238: { towgs84: "-1.977,-13.06,-9.993,0.364,0.254,0.689,-1.037" }, EPSG_4168: { towgs84: "-170,33,326" }, EPSG_4131: { towgs84: "199,931,318.9" }, EPSG_4152: { towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0" }, EPSG_5228: { towgs84: "572.213,85.334,461.94,4.9732,1.529,5.2484,3.5378" }, EPSG_8351: { towgs84: "485.021,169.465,483.839,7.786342,4.397554,4.102655,0" }, EPSG_4683: { towgs84: "-127.62,-67.24,-47.04,-3.068,4.903,1.578,-1.06" }, EPSG_4133: { towgs84: "0,0,0" }, EPSG_7373: { towgs84: "0.819,-0.5762,-1.6446,-0.00378,-0.03317,0.00318,0.0693" }, EPSG_9075: { towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0" }, EPSG_9072: { towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0" }, EPSG_9294: { towgs84: "1.16835,-1.42001,-2.24431,-0.00822,-0.05508,0.01818,0.23388" }, EPSG_4212: { towgs84: "-267.434,173.496,181.814,-13.4704,8.7154,7.3926,14.7492" }, EPSG_4191: { towgs84: "-44.183,-0.58,-38.489,2.3867,2.7072,-3.5196,-8.2703" }, EPSG_4237: { towgs84: "52.684,-71.194,-13.975,-0.312,-0.1063,-0.3729,1.0191" }, EPSG_4740: { towgs84: "-1.08,-0.27,-0.9" }, EPSG_4124: { towgs84: "419.3836,99.3335,591.3451,0.850389,1.817277,-7.862238,-0.99496" }, EPSG_5681: { towgs84: "584.9636,107.7175,413.8067,1.1155,0.2824,-3.1384,7.9922" }, EPSG_4141: { towgs84: "23.772,17.49,17.859,-0.3132,-1.85274,1.67299,-5.4262" }, EPSG_4204: { towgs84: "-85.645,-273.077,-79.708,2.289,-1.421,2.532,3.194" }, EPSG_4319: { towgs84: "226.702,-193.337,-35.371,-2.229,-4.391,9.238,0.9798" }, EPSG_4200: { towgs84: "24.82,-131.21,-82.66" }, EPSG_4130: { towgs84: "0,0,0" }, EPSG_4127: { towgs84: "-82.875,-57.097,-156.768,-2.158,1.524,-0.982,-0.359" }, EPSG_4149: { towgs84: "674.374,15.056,405.346" }, EPSG_4617: { towgs84: "-0.991,1.9072,0.5129,1.25033e-7,4.6785e-8,5.6529e-8,0" }, EPSG_4663: { towgs84: "-210.502,-66.902,-48.476,2.094,-15.067,-5.817,0.485" }, EPSG_4664: { towgs84: "-211.939,137.626,58.3,-0.089,0.251,0.079,0.384" }, EPSG_4665: { towgs84: "-105.854,165.589,-38.312,-0.003,-0.026,0.024,-0.048" }, EPSG_4666: { towgs84: "631.392,-66.551,481.442,1.09,-4.445,-4.487,-4.43" }, EPSG_4756: { towgs84: "-192.873,-39.382,-111.202,-0.00205,-0.0005,0.00335,0.0188" }, EPSG_4723: { towgs84: "-179.483,-69.379,-27.584,-7.862,8.163,6.042,-13.925" }, EPSG_4726: { towgs84: "8.853,-52.644,180.304,-0.393,-2.323,2.96,-24.081" }, EPSG_4267: { towgs84: "-8.0,160.0,176.0" }, EPSG_5365: { towgs84: "-0.16959,0.35312,0.51846,0.03385,-0.16325,0.03446,0.03693" }, EPSG_4218: { towgs84: "304.5,306.5,-318.1" }, EPSG_4242: { towgs84: "-33.722,153.789,94.959,-8.581,-4.478,4.54,8.95" }, EPSG_4216: { towgs84: "-292.295,248.758,429.447,4.9971,2.99,6.6906,1.0289" }, ESRI_104105: { towgs84: "631.392,-66.551,481.442,1.09,-4.445,-4.487,-4.43" }, ESRI_104129: { towgs84: "0,0,0" }, EPSG_4673: { towgs84: "174.05,-25.49,112.57" }, EPSG_4202: { towgs84: "-124,-60,154" }, EPSG_4203: { towgs84: "-117.763,-51.51,139.061,0.292,0.443,0.277,-0.191" }, EPSG_3819: { towgs84: "595.48,121.69,515.35,4.115,-2.9383,0.853,-3.408" }, EPSG_8694: { towgs84: "-93.799,-132.737,-219.073,-1.844,0.648,-6.37,-0.169" }, EPSG_4145: { towgs84: "275.57,676.78,229.6" }, EPSG_4283: { towgs84: "61.55,-10.87,-40.19,39.4924,32.7221,32.8979,-9.994" }, EPSG_4317: { towgs84: "2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266" }, EPSG_4272: { towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993" }, EPSG_4248: { towgs84: "-307.7,265.3,-363.5" }, EPSG_5561: { towgs84: "24,-121,-76" }, EPSG_5233: { towgs84: "-0.293,766.95,87.713,0.195704,1.695068,3.473016,-0.039338" }, ESRI_104130: { towgs84: "-86,-98,-119" }, ESRI_104102: { towgs84: "682,-203,480" }, ESRI_37207: { towgs84: "7,-10,-26" }, EPSG_4675: { towgs84: "59.935,118.4,-10.871" }, ESRI_104109: { towgs84: "-89.121,-348.182,260.871" }, ESRI_104112: { towgs84: "-185.583,-230.096,281.361" }, ESRI_104113: { towgs84: "25.1,-275.6,222.6" }, IGNF_WGS72G: { towgs84: "0,12,6" }, IGNF_NTFG: { towgs84: "-168,-60,320" }, IGNF_EFATE57G: { towgs84: "-127,-769,472" }, IGNF_PGP50G: { towgs84: "324.8,153.6,172.1" }, IGNF_REUN47G: { towgs84: "94,-948,-1262" }, IGNF_CSG67G: { towgs84: "-186,230,110" }, IGNF_GUAD48G: { towgs84: "-467,-16,-300" }, IGNF_TAHI51G: { towgs84: "162,117,154" }, IGNF_TAHAAG: { towgs84: "65,342,77" }, IGNF_NUKU72G: { towgs84: "84,274,65" }, IGNF_PETRELS72G: { towgs84: "365,194,166" }, IGNF_WALL78G: { towgs84: "253,-133,-127" }, IGNF_MAYO50G: { towgs84: "-382,-59,-262" }, IGNF_TANNAG: { towgs84: "-139,-967,436" }, IGNF_IGN72G: { towgs84: "-13,-348,292" }, IGNF_ATIGG: { towgs84: "1118,23,66" }, IGNF_FANGA84G: { towgs84: "150.57,158.33,118.32" }, IGNF_RUSAT84G: { towgs84: "202.13,174.6,-15.74" }, IGNF_KAUE70G: { towgs84: "126.74,300.1,-75.49" }, IGNF_MOP90G: { towgs84: "-10.8,-1.8,12.77" }, IGNF_MHPF67G: { towgs84: "338.08,212.58,-296.17" }, IGNF_TAHI79G: { towgs84: "160.61,116.05,153.69" }, IGNF_ANAA92G: { towgs84: "1.5,3.84,4.81" }, IGNF_MARQUI72G: { towgs84: "330.91,-13.92,58.56" }, IGNF_APAT86G: { towgs84: "143.6,197.82,74.05" }, IGNF_TUBU69G: { towgs84: "237.17,171.61,-77.84" }, IGNF_STPM50G: { towgs84: "11.363,424.148,373.13" }, EPSG_4150: { towgs84: "674.374,15.056,405.346" }, EPSG_4754: { towgs84: "-208.4058,-109.8777,-2.5764" }, ESRI_104101: { towgs84: "374,150,588" }, EPSG_4693: { towgs84: "0,-0.15,0.68" }, EPSG_6207: { towgs84: "293.17,726.18,245.36" }, EPSG_4153: { towgs84: "-133.63,-157.5,-158.62" }, EPSG_4132: { towgs84: "-241.54,-163.64,396.06" }, EPSG_4221: { towgs84: "-154.5,150.7,100.4" }, EPSG_4266: { towgs84: "-80.7,-132.5,41.1" }, EPSG_4193: { towgs84: "-70.9,-151.8,-41.4" }, EPSG_5340: { towgs84: "-0.41,0.46,-0.35" }, EPSG_4246: { towgs84: "-294.7,-200.1,525.5" }, EPSG_4318: { towgs84: "-3.2,-5.7,2.8" }, EPSG_4121: { towgs84: "-199.87,74.79,246.62" }, EPSG_4223: { towgs84: "-260.1,5.5,432.2" }, EPSG_4158: { towgs84: "-0.465,372.095,171.736" }, EPSG_4285: { towgs84: "-128.16,-282.42,21.93" }, EPSG_4613: { towgs84: "-404.78,685.68,45.47" }, EPSG_4607: { towgs84: "195.671,332.517,274.607" }, EPSG_4475: { towgs84: "-381.788,-57.501,-256.673" }, EPSG_4208: { towgs84: "-157.84,308.54,-146.6" }, EPSG_4743: { towgs84: "70.995,-335.916,262.898" }, EPSG_4710: { towgs84: "-323.65,551.39,-491.22" }, EPSG_7881: { towgs84: "-0.077,0.079,0.086" }, EPSG_4682: { towgs84: "283.729,735.942,261.143" }, EPSG_4739: { towgs84: "-156,-271,-189" }, EPSG_4679: { towgs84: "-80.01,253.26,291.19" }, EPSG_4750: { towgs84: "-56.263,16.136,-22.856" }, EPSG_4644: { towgs84: "-10.18,-350.43,291.37" }, EPSG_4695: { towgs84: "-103.746,-9.614,-255.95" }, EPSG_4292: { towgs84: "-355,21,72" }, EPSG_4302: { towgs84: "-61.702,284.488,472.052" }, EPSG_4143: { towgs84: "-124.76,53,466.79" }, EPSG_4606: { towgs84: "-153,153,307" }, EPSG_4699: { towgs84: "-770.1,158.4,-498.2" }, EPSG_4247: { towgs84: "-273.5,110.6,-357.9" }, EPSG_4160: { towgs84: "8.88,184.86,106.69" }, EPSG_4161: { towgs84: "-233.43,6.65,173.64" }, EPSG_9251: { towgs84: "-9.5,122.9,138.2" }, EPSG_9253: { towgs84: "-78.1,101.6,133.3" }, EPSG_4297: { towgs84: "-198.383,-240.517,-107.909" }, EPSG_4269: { towgs84: "0,0,0" }, EPSG_4301: { towgs84: "-147,506,687" }, EPSG_4618: { towgs84: "-59,-11,-52" }, EPSG_4612: { towgs84: "0,0,0" }, EPSG_4678: { towgs84: "44.585,-131.212,-39.544" }, EPSG_4250: { towgs84: "-130,29,364" }, EPSG_4144: { towgs84: "214,804,268" }, EPSG_4147: { towgs84: "-17.51,-108.32,-62.39" }, EPSG_4259: { towgs84: "-254.1,-5.36,-100.29" }, EPSG_4164: { towgs84: "-76,-138,67" }, EPSG_4211: { towgs84: "-378.873,676.002,-46.255" }, EPSG_4182: { towgs84: "-422.651,-172.995,84.02" }, EPSG_4224: { towgs84: "-143.87,243.37,-33.52" }, EPSG_4225: { towgs84: "-205.57,168.77,-4.12" }, EPSG_5527: { towgs84: "-67.35,3.88,-38.22" }, EPSG_4752: { towgs84: "98,390,-22" }, EPSG_4310: { towgs84: "-30,190,89" }, EPSG_9248: { towgs84: "-192.26,65.72,132.08" }, EPSG_4680: { towgs84: "124.5,-63.5,-281" }, EPSG_4701: { towgs84: "-79.9,-158,-168.9" }, EPSG_4706: { towgs84: "-146.21,112.63,4.05" }, EPSG_4805: { towgs84: "682,-203,480" }, EPSG_4201: { towgs84: "-165,-11,206" }, EPSG_4210: { towgs84: "-157,-2,-299" }, EPSG_4183: { towgs84: "-104,167,-38" }, EPSG_4139: { towgs84: "11,72,-101" }, EPSG_4668: { towgs84: "-86,-98,-119" }, EPSG_4717: { towgs84: "-2,151,181" }, EPSG_4732: { towgs84: "102,52,-38" }, EPSG_4280: { towgs84: "-377,681,-50" }, EPSG_4209: { towgs84: "-138,-105,-289" }, EPSG_4261: { towgs84: "31,146,47" }, EPSG_4658: { towgs84: "-73,46,-86" }, EPSG_4721: { towgs84: "265.025,384.929,-194.046" }, EPSG_4222: { towgs84: "-136,-108,-292" }, EPSG_4601: { towgs84: "-255,-15,71" }, EPSG_4602: { towgs84: "725,685,536" }, EPSG_4603: { towgs84: "72,213.7,93" }, EPSG_4605: { towgs84: "9,183,236" }, EPSG_4621: { towgs84: "137,248,-430" }, EPSG_4657: { towgs84: "-28,199,5" }, EPSG_4316: { towgs84: "103.25,-100.4,-307.19" }, EPSG_4642: { towgs84: "-13,-348,292" }, EPSG_4698: { towgs84: "145,-187,103" }, EPSG_4192: { towgs84: "-206.1,-174.7,-87.7" }, EPSG_4311: { towgs84: "-265,120,-358" }, EPSG_4135: { towgs84: "58,-283,-182" }, ESRI_104138: { towgs84: "198,-226,-347" }, EPSG_4245: { towgs84: "-11,851,5" }, EPSG_4142: { towgs84: "-125,53,467" }, EPSG_4213: { towgs84: "-106,-87,188" }, EPSG_4253: { towgs84: "-133,-77,-51" }, EPSG_4129: { towgs84: "-132,-110,-335" }, EPSG_4713: { towgs84: "-77,-128,142" }, EPSG_4239: { towgs84: "217,823,299" }, EPSG_4146: { towgs84: "295,736,257" }, EPSG_4155: { towgs84: "-83,37,124" }, EPSG_4165: { towgs84: "-173,253,27" }, EPSG_4672: { towgs84: "175,-38,113" }, EPSG_4236: { towgs84: "-637,-549,-203" }, EPSG_4251: { towgs84: "-90,40,88" }, EPSG_4271: { towgs84: "-2,374,172" }, EPSG_4175: { towgs84: "-88,4,101" }, EPSG_4716: { towgs84: "298,-304,-375" }, EPSG_4315: { towgs84: "-23,259,-9" }, EPSG_4744: { towgs84: "-242.2,-144.9,370.3" }, EPSG_4244: { towgs84: "-97,787,86" }, EPSG_4293: { towgs84: "616,97,-251" }, EPSG_4714: { towgs84: "-127,-769,472" }, EPSG_4736: { towgs84: "260,12,-147" }, EPSG_6883: { towgs84: "-235,-110,393" }, EPSG_6894: { towgs84: "-63,176,185" }, EPSG_4205: { towgs84: "-43,-163,45" }, EPSG_4256: { towgs84: "41,-220,-134" }, EPSG_4262: { towgs84: "639,405,60" }, EPSG_4604: { towgs84: "174,359,365" }, EPSG_4169: { towgs84: "-115,118,426" }, EPSG_4620: { towgs84: "-106,-129,165" }, EPSG_4184: { towgs84: "-203,141,53" }, EPSG_4616: { towgs84: "-289,-124,60" }, EPSG_9403: { towgs84: "-307,-92,127" }, EPSG_4684: { towgs84: "-133,-321,50" }, EPSG_4708: { towgs84: "-491,-22,435" }, EPSG_4707: { towgs84: "114,-116,-333" }, EPSG_4709: { towgs84: "145,75,-272" }, EPSG_4712: { towgs84: "-205,107,53" }, EPSG_4711: { towgs84: "124,-234,-25" }, EPSG_4718: { towgs84: "230,-199,-752" }, EPSG_4719: { towgs84: "211,147,111" }, EPSG_4724: { towgs84: "208,-435,-229" }, EPSG_4725: { towgs84: "189,-79,-202" }, EPSG_4735: { towgs84: "647,1777,-1124" }, EPSG_4722: { towgs84: "-794,119,-298" }, EPSG_4728: { towgs84: "-307,-92,127" }, EPSG_4734: { towgs84: "-632,438,-609" }, EPSG_4727: { towgs84: "912,-58,1227" }, EPSG_4729: { towgs84: "185,165,42" }, EPSG_4730: { towgs84: "170,42,84" }, EPSG_4733: { towgs84: "276,-57,149" }, ESRI_37218: { towgs84: "230,-199,-752" }, ESRI_37240: { towgs84: "-7,215,225" }, ESRI_37221: { towgs84: "252,-209,-751" }, ESRI_4305: { towgs84: "-123,-206,219" }, ESRI_104139: { towgs84: "-73,-247,227" }, EPSG_4748: { towgs84: "51,391,-36" }, EPSG_4219: { towgs84: "-384,664,-48" }, EPSG_4255: { towgs84: "-333,-222,114" }, EPSG_4257: { towgs84: "-587.8,519.75,145.76" }, EPSG_4646: { towgs84: "-963,510,-359" }, EPSG_6881: { towgs84: "-24,-203,268" }, EPSG_6882: { towgs84: "-183,-15,273" }, EPSG_4715: { towgs84: "-104,-129,239" }, IGNF_RGF93GDD: { towgs84: "0,0,0" }, IGNF_RGM04GDD: { towgs84: "0,0,0" }, IGNF_RGSPM06GDD: { towgs84: "0,0,0" }, IGNF_RGTAAF07GDD: { towgs84: "0,0,0" }, IGNF_RGFG95GDD: { towgs84: "0,0,0" }, IGNF_RGNCG: { towgs84: "0,0,0" }, IGNF_RGPFGDD: { towgs84: "0,0,0" }, IGNF_ETRS89G: { towgs84: "0,0,0" }, IGNF_RGR92GDD: { towgs84: "0,0,0" }, EPSG_4173: { towgs84: "0,0,0" }, EPSG_4180: { towgs84: "0,0,0" }, EPSG_4619: { towgs84: "0,0,0" }, EPSG_4667: { towgs84: "0,0,0" }, EPSG_4075: { towgs84: "0,0,0" }, EPSG_6706: { towgs84: "0,0,0" }, EPSG_7798: { towgs84: "0,0,0" }, EPSG_4661: { towgs84: "0,0,0" }, EPSG_4669: { towgs84: "0,0,0" }, EPSG_8685: { towgs84: "0,0,0" }, EPSG_4151: { towgs84: "0,0,0" }, EPSG_9702: { towgs84: "0,0,0" }, EPSG_4758: { towgs84: "0,0,0" }, EPSG_4761: { towgs84: "0,0,0" }, EPSG_4765: { towgs84: "0,0,0" }, EPSG_8997: { towgs84: "0,0,0" }, EPSG_4023: { towgs84: "0,0,0" }, EPSG_4670: { towgs84: "0,0,0" }, EPSG_4694: { towgs84: "0,0,0" }, EPSG_4148: { towgs84: "0,0,0" }, EPSG_4163: { towgs84: "0,0,0" }, EPSG_4167: { towgs84: "0,0,0" }, EPSG_4189: { towgs84: "0,0,0" }, EPSG_4190: { towgs84: "0,0,0" }, EPSG_4176: { towgs84: "0,0,0" }, EPSG_4659: { towgs84: "0,0,0" }, EPSG_3824: { towgs84: "0,0,0" }, EPSG_3889: { towgs84: "0,0,0" }, EPSG_4046: { towgs84: "0,0,0" }, EPSG_4081: { towgs84: "0,0,0" }, EPSG_4558: { towgs84: "0,0,0" }, EPSG_4483: { towgs84: "0,0,0" }, EPSG_5013: { towgs84: "0,0,0" }, EPSG_5264: { towgs84: "0,0,0" }, EPSG_5324: { towgs84: "0,0,0" }, EPSG_5354: { towgs84: "0,0,0" }, EPSG_5371: { towgs84: "0,0,0" }, EPSG_5373: { towgs84: "0,0,0" }, EPSG_5381: { towgs84: "0,0,0" }, EPSG_5393: { towgs84: "0,0,0" }, EPSG_5489: { towgs84: "0,0,0" }, EPSG_5593: { towgs84: "0,0,0" }, EPSG_6135: { towgs84: "0,0,0" }, EPSG_6365: { towgs84: "0,0,0" }, EPSG_5246: { towgs84: "0,0,0" }, EPSG_7886: { towgs84: "0,0,0" }, EPSG_8431: { towgs84: "0,0,0" }, EPSG_8427: { towgs84: "0,0,0" }, EPSG_8699: { towgs84: "0,0,0" }, EPSG_8818: { towgs84: "0,0,0" }, EPSG_4757: { towgs84: "0,0,0" }, EPSG_9140: { towgs84: "0,0,0" }, EPSG_8086: { towgs84: "0,0,0" }, EPSG_4686: { towgs84: "0,0,0" }, EPSG_4737: { towgs84: "0,0,0" }, EPSG_4702: { towgs84: "0,0,0" }, EPSG_4747: { towgs84: "0,0,0" }, EPSG_4749: { towgs84: "0,0,0" }, EPSG_4674: { towgs84: "0,0,0" }, EPSG_4755: { towgs84: "0,0,0" }, EPSG_4759: { towgs84: "0,0,0" }, EPSG_4762: { towgs84: "0,0,0" }, EPSG_4763: { towgs84: "0,0,0" }, EPSG_4764: { towgs84: "0,0,0" }, EPSG_4166: { towgs84: "0,0,0" }, EPSG_4170: { towgs84: "0,0,0" }, EPSG_5546: { towgs84: "0,0,0" }, EPSG_7844: { towgs84: "0,0,0" }, EPSG_4818: { towgs84: "589,76,480" } };
      for (var it in st) {
        var at = st[it];
        at.datumName && (st[at.datumName] = at);
      }
      var ht = {};
      async function et(t2, s2) {
        for (var i2 = [], a3 = await s2.getImageCount(), h2 = a3 - 1; h2 >= 0; h2--) {
          var e2 = await s2.getImage(h2), n2 = await e2.readRasters(), r2 = [e2.getWidth(), e2.getHeight()], o2 = e2.getBoundingBox().map(rt), l2 = [e2.fileDirectory.ModelPixelScale[0], e2.fileDirectory.ModelPixelScale[1]].map(rt), c2 = o2[0] + (r2[0] - 1) * l2[0], _2 = o2[3] - (r2[1] - 1) * l2[1], u2 = n2[0], M5 = n2[1], g2 = [];
          for (let t3 = r2[1] - 1; t3 >= 0; t3--) for (let s3 = r2[0] - 1; s3 >= 0; s3--) {
            var f2 = t3 * r2[0] + s3;
            g2.push([-ot(M5[f2]), ot(u2[f2])]);
          }
          i2.push({ del: l2, lim: r2, ll: [-c2, _2], cvs: g2 });
        }
        var d2 = { header: { nSubgrids: a3 }, subgrids: i2 };
        return ht[t2] = d2, d2;
      }
      function nt(t2) {
        if (0 === t2.length) return null;
        var s2 = "@" === t2[0];
        return s2 && (t2 = t2.slice(1)), "null" === t2 ? { name: "null", mandatory: !s2, grid: null, isNull: true } : { name: t2, mandatory: !s2, grid: ht[t2] || null, isNull: false };
      }
      function rt(t2) {
        return t2 * Math.PI / 180;
      }
      function ot(t2) {
        return t2 / 3600 * Math.PI / 180;
      }
      function lt(t2, s2, i2) {
        return String.fromCharCode.apply(null, new Uint8Array(t2.buffer.slice(s2, i2)));
      }
      function ct(t2) {
        return t2.map(function(t3) {
          return [ot(t3.longitudeShift), ot(t3.latitudeShift)];
        });
      }
      function _t(t2, s2, i2) {
        return { name: lt(t2, s2 + 8, s2 + 16).trim(), parent: lt(t2, s2 + 24, s2 + 24 + 8).trim(), lowerLatitude: t2.getFloat64(s2 + 72, i2), upperLatitude: t2.getFloat64(s2 + 88, i2), lowerLongitude: t2.getFloat64(s2 + 104, i2), upperLongitude: t2.getFloat64(s2 + 120, i2), latitudeInterval: t2.getFloat64(s2 + 136, i2), longitudeInterval: t2.getFloat64(s2 + 152, i2), gridNodeCount: t2.getInt32(s2 + 168, i2) };
      }
      function ut(t2, s2, i2, a3, h2) {
        var e2 = s2 + 176, n2 = 16;
        false === h2 && (n2 = 8);
        for (var r2 = [], o2 = 0; o2 < i2.gridNodeCount; o2++) {
          var l2 = { latitudeShift: t2.getFloat32(e2 + o2 * n2, a3), longitudeShift: t2.getFloat32(e2 + o2 * n2 + 4, a3) };
          false !== h2 && (l2.latitudeAccuracy = t2.getFloat32(e2 + o2 * n2 + 8, a3), l2.longitudeAccuracy = t2.getFloat32(e2 + o2 * n2 + 12, a3)), r2.push(l2);
        }
        return r2;
      }
      function Mt(t2, s2) {
        if (!(this instanceof Mt)) return new Mt(t2);
        s2 = s2 || function(t3) {
          if (t3) throw t3;
        };
        var a3 = j(t2);
        if ("object" == typeof a3) {
          var e2 = Mt.projections.get(a3.projName);
          if (e2) {
            if (a3.datumCode && "none" !== a3.datumCode) {
              var n2 = M(st, a3.datumCode);
              n2 && (a3.datum_params = a3.datum_params || (n2.towgs84 ? n2.towgs84.split(",") : null), a3.ellps = n2.ellipse, a3.datumName = n2.datumName ? n2.datumName : a3.datumCode);
            }
            a3.k0 = a3.k0 || 1, a3.axis = a3.axis || "enu", a3.ellps = a3.ellps || "wgs84", a3.lat1 = a3.lat1 || a3.lat0;
            var r2, o2, l2, c2, _2, u2, g2, f2 = function(t3, s3, i2, a4, e3) {
              if (!t3) {
                var n3 = M($, a4);
                n3 || (n3 = tt), t3 = n3.a, s3 = n3.b, i2 = n3.rf;
              }
              return i2 && !s3 && (s3 = (1 - 1 / i2) * t3), (0 === i2 || Math.abs(t3 - s3) < h) && (e3 = true, s3 = t3), { a: t3, b: s3, rf: i2, sphere: e3 };
            }(a3.a, a3.b, a3.rf, a3.ellps, a3.sphere), d2 = (r2 = f2.a, o2 = f2.b, f2.rf, l2 = a3.R_A, u2 = ((c2 = r2 * r2) - (_2 = o2 * o2)) / c2, g2 = 0, l2 ? (c2 = (r2 *= 1 - u2 * (0.16666666666666666 + u2 * (0.04722222222222222 + 0.022156084656084655 * u2))) * r2, u2 = 0) : g2 = Math.sqrt(u2), { es: u2, e: g2, ep2: (c2 - _2) / _2 }), p5 = function(t3) {
              return void 0 === t3 ? null : t3.split(",").map(nt);
            }(a3.nadgrids), m2 = a3.datum || function(t3, s3, a4, h2, e3, n3, r3) {
              var o3 = {};
              return o3.datum_type = void 0 === t3 || "none" === t3 ? 5 : 4, s3 && (o3.datum_params = s3.map(parseFloat), 0 === o3.datum_params[0] && 0 === o3.datum_params[1] && 0 === o3.datum_params[2] || (o3.datum_type = 1), o3.datum_params.length > 3 && (0 === o3.datum_params[3] && 0 === o3.datum_params[4] && 0 === o3.datum_params[5] && 0 === o3.datum_params[6] || (o3.datum_type = 2, o3.datum_params[3] *= i, o3.datum_params[4] *= i, o3.datum_params[5] *= i, o3.datum_params[6] = o3.datum_params[6] / 1e6 + 1))), r3 && (o3.datum_type = 3, o3.grids = r3), o3.a = a4, o3.b = h2, o3.es = e3, o3.ep2 = n3, o3;
            }(a3.datumCode, a3.datum_params, f2.a, f2.b, d2.es, d2.ep2, p5);
            U(this, a3), U(this, e2), this.a = f2.a, this.b = f2.b, this.rf = f2.rf, this.sphere = f2.sphere, this.es = d2.es, this.e = d2.e, this.ep2 = d2.ep2, this.datum = m2, this.init(), s2(null, this);
          } else s2("Could not get projection name from: " + t2);
        } else s2("Could not parse to valid json: " + t2);
      }
      function gt(t2, s2, i2) {
        var h2, e2, n2, r2, o2 = t2.x, l2 = t2.y, c2 = t2.z ? t2.z : 0;
        if (l2 < -a && l2 > -1.001 * a) l2 = -a;
        else if (l2 > a && l2 < 1.001 * a) l2 = a;
        else {
          if (l2 < -a) return { x: -1 / 0, y: -1 / 0, z: t2.z };
          if (l2 > a) return { x: 1 / 0, y: 1 / 0, z: t2.z };
        }
        return o2 > Math.PI && (o2 -= 2 * Math.PI), e2 = Math.sin(l2), r2 = Math.cos(l2), n2 = e2 * e2, { x: ((h2 = i2 / Math.sqrt(1 - s2 * n2)) + c2) * r2 * Math.cos(o2), y: (h2 + c2) * r2 * Math.sin(o2), z: (h2 * (1 - s2) + c2) * e2 };
      }
      function ft(t2, s2, i2, a3) {
        var h2, e2, n2, r2, o2, l2, c2, _2, u2, M5, g2, f2, d2, p5, m2, y2 = 1e-12, S2 = t2.x, E5 = t2.y, w2 = t2.z ? t2.z : 0;
        if (h2 = Math.sqrt(S2 * S2 + E5 * E5), e2 = Math.sqrt(S2 * S2 + E5 * E5 + w2 * w2), h2 / i2 < y2) {
          if (p5 = 0, e2 / i2 < y2) return m2 = -a3, { x: t2.x, y: t2.y, z: t2.z };
        } else p5 = Math.atan2(E5, S2);
        n2 = w2 / e2, _2 = (r2 = h2 / e2) * (1 - s2) * (o2 = 1 / Math.sqrt(1 - s2 * (2 - s2) * r2 * r2)), u2 = n2 * o2, d2 = 0;
        do {
          d2++, l2 = s2 * (c2 = i2 / Math.sqrt(1 - s2 * u2 * u2)) / (c2 + (m2 = h2 * _2 + w2 * u2 - c2 * (1 - s2 * u2 * u2))), f2 = (g2 = n2 * (o2 = 1 / Math.sqrt(1 - l2 * (2 - l2) * r2 * r2))) * _2 - (M5 = r2 * (1 - l2) * o2) * u2, _2 = M5, u2 = g2;
        } while (f2 * f2 > 1e-24 && d2 < 30);
        return { x: p5, y: Math.atan(g2 / Math.abs(M5)), z: m2 };
      }
      function dt(t2) {
        return 1 === t2 || 2 === t2;
      }
      function pt(i2, a3, h2) {
        if (function(t2, s2) {
          return t2.datum_type === s2.datum_type && !(t2.a !== s2.a || Math.abs(t2.es - s2.es) > 5e-11) && (1 === t2.datum_type ? t2.datum_params[0] === s2.datum_params[0] && t2.datum_params[1] === s2.datum_params[1] && t2.datum_params[2] === s2.datum_params[2] : 2 !== t2.datum_type || t2.datum_params[0] === s2.datum_params[0] && t2.datum_params[1] === s2.datum_params[1] && t2.datum_params[2] === s2.datum_params[2] && t2.datum_params[3] === s2.datum_params[3] && t2.datum_params[4] === s2.datum_params[4] && t2.datum_params[5] === s2.datum_params[5] && t2.datum_params[6] === s2.datum_params[6]);
        }(i2, a3)) return h2;
        if (5 === i2.datum_type || 5 === a3.datum_type) return h2;
        var e2 = i2.a, n2 = i2.es;
        if (3 === i2.datum_type) {
          if (0 !== mt(i2, false, h2)) return;
          e2 = t, n2 = s;
        }
        var r2 = a3.a, o2 = a3.b, l2 = a3.es;
        if (3 === a3.datum_type && (r2 = t, o2 = 6356752314e-3, l2 = s), n2 === l2 && e2 === r2 && !dt(i2.datum_type) && !dt(a3.datum_type)) return h2;
        if ((h2 = gt(h2, n2, e2), dt(i2.datum_type) && (h2 = function(t2, s2, i3) {
          if (1 === s2) return { x: t2.x + i3[0], y: t2.y + i3[1], z: t2.z + i3[2] };
          if (2 === s2) {
            var a4 = i3[0], h3 = i3[1], e3 = i3[2], n3 = i3[3], r3 = i3[4], o3 = i3[5], l3 = i3[6];
            return { x: l3 * (t2.x - o3 * t2.y + r3 * t2.z) + a4, y: l3 * (o3 * t2.x + t2.y - n3 * t2.z) + h3, z: l3 * (-r3 * t2.x + n3 * t2.y + t2.z) + e3 };
          }
        }(h2, i2.datum_type, i2.datum_params)), dt(a3.datum_type) && (h2 = function(t2, s2, i3) {
          if (1 === s2) return { x: t2.x - i3[0], y: t2.y - i3[1], z: t2.z - i3[2] };
          if (2 === s2) {
            var a4 = i3[0], h3 = i3[1], e3 = i3[2], n3 = i3[3], r3 = i3[4], o3 = i3[5], l3 = i3[6], c2 = (t2.x - a4) / l3, _2 = (t2.y - h3) / l3, u2 = (t2.z - e3) / l3;
            return { x: c2 + o3 * _2 - r3 * u2, y: -o3 * c2 + _2 + n3 * u2, z: r3 * c2 - n3 * _2 + u2 };
          }
        }(h2, a3.datum_type, a3.datum_params)), h2 = ft(h2, l2, r2, o2), 3 === a3.datum_type) && 0 !== mt(a3, true, h2)) return;
        return h2;
      }
      function mt(t2, s2, i2) {
        if (null === t2.grids || 0 === t2.grids.length) return console.log("Grid shift grids not found"), -1;
        var a3 = { x: -i2.x, y: i2.y }, h2 = { x: Number.NaN, y: Number.NaN }, e2 = [];
        t: for (var r2 = 0; r2 < t2.grids.length; r2++) {
          var o2 = t2.grids[r2];
          if (e2.push(o2.name), o2.isNull) {
            h2 = a3;
            break;
          }
          if (null !== o2.grid) for (var l2 = o2.grid.subgrids, c2 = 0, _2 = l2.length; c2 < _2; c2++) {
            var u2 = l2[c2], M5 = (Math.abs(u2.del[1]) + Math.abs(u2.del[0])) / 1e4, g2 = u2.ll[0] - M5, f2 = u2.ll[1] - M5, d2 = u2.ll[0] + (u2.lim[0] - 1) * u2.del[0] + M5, p5 = u2.ll[1] + (u2.lim[1] - 1) * u2.del[1] + M5;
            if (!(f2 > a3.y || g2 > a3.x || p5 < a3.y || d2 < a3.x) && (h2 = yt(a3, s2, u2), !isNaN(h2.x))) break t;
          }
          else if (o2.mandatory) return console.log("Unable to find mandatory grid '" + o2.name + "'"), -1;
        }
        return isNaN(h2.x) ? (console.log("Failed to find a grid shift table for location '" + -a3.x * n + " " + a3.y * n + " tried: '" + e2 + "'"), -1) : (i2.x = -h2.x, i2.y = h2.y, 0);
      }
      function yt(t2, s2, i2) {
        var a3 = { x: Number.NaN, y: Number.NaN };
        if (isNaN(t2.x)) return a3;
        var h2 = { x: t2.x, y: t2.y };
        h2.x -= i2.ll[0], h2.y -= i2.ll[1], h2.x = z(h2.x - Math.PI) + Math.PI;
        var e2 = St(h2, i2);
        if (s2) {
          if (isNaN(e2.x)) return a3;
          e2.x = h2.x - e2.x, e2.y = h2.y - e2.y;
          var n2, r2, o2 = 9;
          do {
            if (r2 = St(e2, i2), isNaN(r2.x)) {
              console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
              break;
            }
            n2 = { x: h2.x - (r2.x + e2.x), y: h2.y - (r2.y + e2.y) }, e2.x += n2.x, e2.y += n2.y;
          } while (o2-- && Math.abs(n2.x) > 1e-12 && Math.abs(n2.y) > 1e-12);
          if (o2 < 0) return console.log("Inverse grid shift iterator failed to converge."), a3;
          a3.x = z(e2.x + i2.ll[0]), a3.y = e2.y + i2.ll[1];
        } else isNaN(e2.x) || (a3.x = t2.x + e2.x, a3.y = t2.y + e2.y);
        return a3;
      }
      function St(t2, s2) {
        var i2, a3 = { x: t2.x / s2.del[0], y: t2.y / s2.del[1] }, h2 = Math.floor(a3.x), e2 = Math.floor(a3.y), n2 = a3.x - 1 * h2, r2 = a3.y - 1 * e2, o2 = { x: Number.NaN, y: Number.NaN };
        if (h2 < 0 || h2 >= s2.lim[0]) return o2;
        if (e2 < 0 || e2 >= s2.lim[1]) return o2;
        i2 = e2 * s2.lim[0] + h2;
        var l2 = s2.cvs[i2][0], c2 = s2.cvs[i2][1];
        i2++;
        var _2 = s2.cvs[i2][0], u2 = s2.cvs[i2][1];
        i2 += s2.lim[0];
        var M5 = s2.cvs[i2][0], g2 = s2.cvs[i2][1];
        i2--;
        var f2 = s2.cvs[i2][0], d2 = s2.cvs[i2][1], p5 = n2 * r2, m2 = n2 * (1 - r2), y2 = (1 - n2) * (1 - r2), S2 = (1 - n2) * r2;
        return o2.x = y2 * l2 + m2 * _2 + S2 * f2 + p5 * M5, o2.y = y2 * c2 + m2 * u2 + S2 * d2 + p5 * g2, o2;
      }
      function Et(t2, s2, i2) {
        var a3, h2, e2, n2 = i2.x, r2 = i2.y, o2 = i2.z || 0, l2 = {};
        for (e2 = 0; e2 < 3; e2++) if (!s2 || 2 !== e2 || void 0 !== i2.z) switch (0 === e2 ? (a3 = n2, h2 = -1 !== "ew".indexOf(t2.axis[e2]) ? "x" : "y") : 1 === e2 ? (a3 = r2, h2 = -1 !== "ns".indexOf(t2.axis[e2]) ? "y" : "x") : (a3 = o2, h2 = "z"), t2.axis[e2]) {
          case "e":
          case "n":
            l2[h2] = a3;
            break;
          case "w":
          case "s":
            l2[h2] = -a3;
            break;
          case "u":
            void 0 !== i2[h2] && (l2.z = a3);
            break;
          case "d":
            void 0 !== i2[h2] && (l2.z = -a3);
            break;
          default:
            return null;
        }
        return l2;
      }
      function wt(t2) {
        var s2 = { x: t2[0], y: t2[1] };
        return t2.length > 2 && (s2.z = t2[2]), t2.length > 3 && (s2.m = t2[3]), s2;
      }
      function vt(t2) {
        if ("function" == typeof Number.isFinite) {
          if (Number.isFinite(t2)) return;
          throw new TypeError("coordinates must be finite numbers");
        }
        if ("number" != typeof t2 || t2 != t2 || !isFinite(t2)) throw new TypeError("coordinates must be finite numbers");
      }
      function Gt(t2, s2, i2, a3) {
        var h2, r2 = void 0 !== (i2 = Array.isArray(i2) ? wt(i2) : { x: i2.x, y: i2.y, z: i2.z, m: i2.m }).z;
        if (function(t3) {
          vt(t3.x), vt(t3.y);
        }(i2), t2.datum && s2.datum && function(t3, s3) {
          return (1 === t3.datum.datum_type || 2 === t3.datum.datum_type || 3 === t3.datum.datum_type) && "WGS84" !== s3.datumCode || (1 === s3.datum.datum_type || 2 === s3.datum.datum_type || 3 === s3.datum.datum_type) && "WGS84" !== t3.datumCode;
        }(t2, s2) && (i2 = Gt(t2, h2 = new Mt("WGS84"), i2, a3), t2 = h2), a3 && "enu" !== t2.axis && (i2 = Et(t2, false, i2)), "longlat" === t2.projName) i2 = { x: i2.x * e, y: i2.y * e, z: i2.z || 0 };
        else if (t2.to_meter && (i2 = { x: i2.x * t2.to_meter, y: i2.y * t2.to_meter, z: i2.z || 0 }), !(i2 = t2.inverse(i2))) return;
        if (t2.from_greenwich && (i2.x += t2.from_greenwich), i2 = pt(t2.datum, s2.datum, i2)) return s2.from_greenwich && (i2 = { x: i2.x - s2.from_greenwich, y: i2.y, z: i2.z || 0 }), "longlat" === s2.projName ? i2 = { x: i2.x * n, y: i2.y * n, z: i2.z || 0 } : (i2 = s2.forward(i2), s2.to_meter && (i2 = { x: i2.x / s2.to_meter, y: i2.y / s2.to_meter, z: i2.z || 0 })), a3 && "enu" !== s2.axis ? Et(s2, true, i2) : (i2 && !r2 && delete i2.z, i2);
      }
      Mt.projections = Y, Mt.projections.start();
      var xt = Mt("WGS84");
      function Pt(t2, s2, i2, a3) {
        var h2, e2, n2;
        return Array.isArray(i2) ? (h2 = Gt(t2, s2, i2, a3) || { x: NaN, y: NaN }, i2.length > 2 ? void 0 !== t2.name && "geocent" === t2.name || void 0 !== s2.name && "geocent" === s2.name ? "number" == typeof h2.z ? [h2.x, h2.y, h2.z].concat(i2.slice(3)) : [h2.x, h2.y, i2[2]].concat(i2.slice(3)) : [h2.x, h2.y].concat(i2.slice(2)) : [h2.x, h2.y]) : (e2 = Gt(t2, s2, i2, a3), 2 === (n2 = Object.keys(i2)).length || n2.forEach(function(a4) {
          if (void 0 !== t2.name && "geocent" === t2.name || void 0 !== s2.name && "geocent" === s2.name) {
            if ("x" === a4 || "y" === a4 || "z" === a4) return;
          } else if ("x" === a4 || "y" === a4) return;
          e2[a4] = i2[a4];
        }), e2);
      }
      function bt(t2) {
        return t2 instanceof Mt ? t2 : t2.oProj ? t2.oProj : Mt(t2);
      }
      function At(t2, s2, i2) {
        t2 = bt(t2);
        var a3, h2 = false;
        return void 0 === s2 ? (s2 = t2, t2 = xt, h2 = true) : (void 0 !== s2.x || Array.isArray(s2)) && (i2 = s2, s2 = t2, t2 = xt, h2 = true), s2 = bt(s2), i2 ? Pt(t2, s2, i2) : (a3 = { forward: function(i3, a4) {
          return Pt(t2, s2, i3, a4);
        }, inverse: function(i3, a4) {
          return Pt(s2, t2, i3, a4);
        } }, h2 && (a3.oProj = s2), a3);
      }
      var Ct = "AJSAJS", Nt = "AFAFAF", It = 65, Lt = 73, Ot = 79, Rt = 86, qt = 90, Tt = { forward: kt, inverse: function(t2) {
        var s2 = Ft(Ht(t2.toUpperCase()));
        if (s2.lat && s2.lon) return [s2.lon, s2.lat, s2.lon, s2.lat];
        return [s2.left, s2.bottom, s2.right, s2.top];
      }, toPoint: Dt };
      function kt(t2, s2) {
        return s2 = s2 || 5, function(t3, s3) {
          var i2 = "00000" + t3.easting, a3 = "00000" + t3.northing;
          return t3.zoneNumber + t3.zoneLetter + (M5 = t3.easting, g2 = t3.northing, f2 = t3.zoneNumber, d2 = zt(f2), p5 = Math.floor(M5 / 1e5), m2 = Math.floor(g2 / 1e5) % 20, h2 = p5, e2 = m2, n2 = d2, r2 = n2 - 1, o2 = Ct.charCodeAt(r2), l2 = Nt.charCodeAt(r2), c2 = o2 + h2 - 1, _2 = l2 + e2, u2 = false, c2 > qt && (c2 = c2 - qt + It - 1, u2 = true), (c2 === Lt || o2 < Lt && c2 > Lt || (c2 > Lt || o2 < Lt) && u2) && c2++, (c2 === Ot || o2 < Ot && c2 > Ot || (c2 > Ot || o2 < Ot) && u2) && ++c2 === Lt && c2++, c2 > qt && (c2 = c2 - qt + It - 1), _2 > Rt ? (_2 = _2 - Rt + It - 1, u2 = true) : u2 = false, (_2 === Lt || l2 < Lt && _2 > Lt || (_2 > Lt || l2 < Lt) && u2) && _2++, (_2 === Ot || l2 < Ot && _2 > Ot || (_2 > Ot || l2 < Ot) && u2) && ++_2 === Lt && _2++, _2 > Rt && (_2 = _2 - Rt + It - 1), String.fromCharCode(c2) + String.fromCharCode(_2)) + i2.substr(i2.length - 5, s3) + a3.substr(a3.length - 5, s3);
          var h2, e2, n2, r2, o2, l2, c2, _2, u2;
          var M5, g2, f2, d2, p5, m2;
        }(function(t3) {
          var s3, i2, a3, h2, e2, n2, r2, o2, l2 = t3.lat, c2 = t3.lon, _2 = 6378137, u2 = 669438e-8, M5 = 0.9996, g2 = jt(l2), f2 = jt(c2);
          o2 = Math.floor((c2 + 180) / 6) + 1, 180 === c2 && (o2 = 60);
          l2 >= 56 && l2 < 64 && c2 >= 3 && c2 < 12 && (o2 = 32);
          l2 >= 72 && l2 < 84 && (c2 >= 0 && c2 < 9 ? o2 = 31 : c2 >= 9 && c2 < 21 ? o2 = 33 : c2 >= 21 && c2 < 33 ? o2 = 35 : c2 >= 33 && c2 < 42 && (o2 = 37));
          r2 = jt(6 * (o2 - 1) - 180 + 3), s3 = u2 / (1 - u2), i2 = _2 / Math.sqrt(1 - u2 * Math.sin(g2) * Math.sin(g2)), a3 = Math.tan(g2) * Math.tan(g2), h2 = s3 * Math.cos(g2) * Math.cos(g2), e2 = Math.cos(g2) * (f2 - r2), n2 = _2 * ((1 - u2 / 4 - 3 * u2 * u2 / 64 - 5 * u2 * u2 * u2 / 256) * g2 - (3 * u2 / 8 + 3 * u2 * u2 / 32 + 45 * u2 * u2 * u2 / 1024) * Math.sin(2 * g2) + (15 * u2 * u2 / 256 + 45 * u2 * u2 * u2 / 1024) * Math.sin(4 * g2) - 35 * u2 * u2 * u2 / 3072 * Math.sin(6 * g2));
          var d2 = M5 * i2 * (e2 + (1 - a3 + h2) * e2 * e2 * e2 / 6 + (5 - 18 * a3 + a3 * a3 + 72 * h2 - 58 * s3) * e2 * e2 * e2 * e2 * e2 / 120) + 5e5, p5 = M5 * (n2 + i2 * Math.tan(g2) * (e2 * e2 / 2 + (5 - a3 + 9 * h2 + 4 * h2 * h2) * e2 * e2 * e2 * e2 / 24 + (61 - 58 * a3 + a3 * a3 + 600 * h2 - 330 * s3) * e2 * e2 * e2 * e2 * e2 * e2 / 720));
          l2 < 0 && (p5 += 1e7);
          return { northing: Math.round(p5), easting: Math.round(d2), zoneNumber: o2, zoneLetter: Bt(l2) };
        }({ lat: t2[1], lon: t2[0] }), s2);
      }
      function Dt(t2) {
        var s2 = Ft(Ht(t2.toUpperCase()));
        return s2.lat && s2.lon ? [s2.lon, s2.lat] : [(s2.left + s2.right) / 2, (s2.top + s2.bottom) / 2];
      }
      function jt(t2) {
        return t2 * (Math.PI / 180);
      }
      function Ut(t2) {
        return t2 / Math.PI * 180;
      }
      function Ft(t2) {
        var s2 = t2.northing, i2 = t2.easting, a3 = t2.zoneLetter, h2 = t2.zoneNumber;
        if (h2 < 0 || h2 > 60) return null;
        var e2, n2, r2, o2, l2, c2, _2, u2, M5, g2 = 0.9996, f2 = 6378137, d2 = 669438e-8, p5 = (1 - Math.sqrt(0.99330562)) / (1 + Math.sqrt(0.99330562)), m2 = i2 - 5e5, y2 = s2;
        a3 < "N" && (y2 -= 1e7), _2 = 6 * (h2 - 1) - 180 + 3, e2 = 0.006739496752268451, M5 = (u2 = y2 / g2 / 6367449145945056e-9) + (3 * p5 / 2 - 27 * p5 * p5 * p5 / 32) * Math.sin(2 * u2) + (21 * p5 * p5 / 16 - 55 * p5 * p5 * p5 * p5 / 32) * Math.sin(4 * u2) + 151 * p5 * p5 * p5 / 96 * Math.sin(6 * u2), n2 = f2 / Math.sqrt(1 - d2 * Math.sin(M5) * Math.sin(M5)), r2 = Math.tan(M5) * Math.tan(M5), o2 = e2 * Math.cos(M5) * Math.cos(M5), l2 = 0.99330562 * f2 / Math.pow(1 - d2 * Math.sin(M5) * Math.sin(M5), 1.5), c2 = m2 / (n2 * g2);
        var S2 = M5 - n2 * Math.tan(M5) / l2 * (c2 * c2 / 2 - (5 + 3 * r2 + 10 * o2 - 4 * o2 * o2 - 9 * e2) * c2 * c2 * c2 * c2 / 24 + (61 + 90 * r2 + 298 * o2 + 45 * r2 * r2 - 1.6983531815716497 - 3 * o2 * o2) * c2 * c2 * c2 * c2 * c2 * c2 / 720);
        S2 = Ut(S2);
        var E5, w2 = (c2 - (1 + 2 * r2 + o2) * c2 * c2 * c2 / 6 + (5 - 2 * o2 + 28 * r2 - 3 * o2 * o2 + 8 * e2 + 24 * r2 * r2) * c2 * c2 * c2 * c2 * c2 / 120) / Math.cos(M5);
        if (w2 = _2 + Ut(w2), t2.accuracy) {
          var v2 = Ft({ northing: t2.northing + t2.accuracy, easting: t2.easting + t2.accuracy, zoneLetter: t2.zoneLetter, zoneNumber: t2.zoneNumber });
          E5 = { top: v2.lat, right: v2.lon, bottom: S2, left: w2 };
        } else E5 = { lat: S2, lon: w2 };
        return E5;
      }
      function Bt(t2) {
        var s2 = "Z";
        return 84 >= t2 && t2 >= 72 ? s2 = "X" : 72 > t2 && t2 >= 64 ? s2 = "W" : 64 > t2 && t2 >= 56 ? s2 = "V" : 56 > t2 && t2 >= 48 ? s2 = "U" : 48 > t2 && t2 >= 40 ? s2 = "T" : 40 > t2 && t2 >= 32 ? s2 = "S" : 32 > t2 && t2 >= 24 ? s2 = "R" : 24 > t2 && t2 >= 16 ? s2 = "Q" : 16 > t2 && t2 >= 8 ? s2 = "P" : 8 > t2 && t2 >= 0 ? s2 = "N" : 0 > t2 && t2 >= -8 ? s2 = "M" : -8 > t2 && t2 >= -16 ? s2 = "L" : -16 > t2 && t2 >= -24 ? s2 = "K" : -24 > t2 && t2 >= -32 ? s2 = "J" : -32 > t2 && t2 >= -40 ? s2 = "H" : -40 > t2 && t2 >= -48 ? s2 = "G" : -48 > t2 && t2 >= -56 ? s2 = "F" : -56 > t2 && t2 >= -64 ? s2 = "E" : -64 > t2 && t2 >= -72 ? s2 = "D" : -72 > t2 && t2 >= -80 && (s2 = "C"), s2;
      }
      function zt(t2) {
        var s2 = t2 % 6;
        return 0 === s2 && (s2 = 6), s2;
      }
      function Ht(t2) {
        if (t2 && 0 === t2.length) throw "MGRSPoint coverting from nothing";
        for (var s2, i2 = t2.length, a3 = null, h2 = "", e2 = 0; !/[A-Z]/.test(s2 = t2.charAt(e2)); ) {
          if (e2 >= 2) throw "MGRSPoint bad conversion from: " + t2;
          h2 += s2, e2++;
        }
        var n2 = parseInt(h2, 10);
        if (0 === e2 || e2 + 3 > i2) throw "MGRSPoint bad conversion from: " + t2;
        var r2 = t2.charAt(e2++);
        if (r2 <= "A" || "B" === r2 || "Y" === r2 || r2 >= "Z" || "I" === r2 || "O" === r2) throw "MGRSPoint zone letter " + r2 + " not handled: " + t2;
        a3 = t2.substring(e2, e2 += 2);
        for (var o2 = zt(n2), l2 = function(t3, s3) {
          var i3 = Ct.charCodeAt(s3 - 1), a4 = 1e5, h3 = false;
          for (; i3 !== t3.charCodeAt(0); ) {
            if (++i3 === Lt && i3++, i3 === Ot && i3++, i3 > qt) {
              if (h3) throw "Bad character: " + t3;
              i3 = It, h3 = true;
            }
            a4 += 1e5;
          }
          return a4;
        }(a3.charAt(0), o2), c2 = function(t3, s3) {
          if (t3 > "V") throw "MGRSPoint given invalid Northing " + t3;
          var i3 = Nt.charCodeAt(s3 - 1), a4 = 0, h3 = false;
          for (; i3 !== t3.charCodeAt(0); ) {
            if (++i3 === Lt && i3++, i3 === Ot && i3++, i3 > Rt) {
              if (h3) throw "Bad character: " + t3;
              i3 = It, h3 = true;
            }
            a4 += 1e5;
          }
          return a4;
        }(a3.charAt(1), o2); c2 < Wt(r2); ) c2 += 2e6;
        var _2 = i2 - e2;
        if (_2 % 2 != 0) throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + t2;
        var u2, M5, g2, f2 = _2 / 2, d2 = 0, p5 = 0;
        return f2 > 0 && (u2 = 1e5 / Math.pow(10, f2), M5 = t2.substring(e2, e2 + f2), d2 = parseFloat(M5) * u2, g2 = t2.substring(e2 + f2), p5 = parseFloat(g2) * u2), { easting: d2 + l2, northing: p5 + c2, zoneLetter: r2, zoneNumber: n2, accuracy: u2 };
      }
      function Wt(t2) {
        var s2;
        switch (t2) {
          case "C":
            s2 = 11e5;
            break;
          case "D":
            s2 = 2e6;
            break;
          case "E":
            s2 = 28e5;
            break;
          case "F":
            s2 = 37e5;
            break;
          case "G":
            s2 = 46e5;
            break;
          case "H":
            s2 = 55e5;
            break;
          case "J":
            s2 = 64e5;
            break;
          case "K":
            s2 = 73e5;
            break;
          case "L":
            s2 = 82e5;
            break;
          case "M":
            s2 = 91e5;
            break;
          case "N":
            s2 = 0;
            break;
          case "P":
            s2 = 8e5;
            break;
          case "Q":
            s2 = 17e5;
            break;
          case "R":
            s2 = 26e5;
            break;
          case "S":
            s2 = 35e5;
            break;
          case "T":
            s2 = 44e5;
            break;
          case "U":
            s2 = 53e5;
            break;
          case "V":
            s2 = 62e5;
            break;
          case "W":
            s2 = 7e6;
            break;
          case "X":
            s2 = 79e5;
            break;
          default:
            s2 = -1;
        }
        if (s2 >= 0) return s2;
        throw "Invalid zone letter: " + t2;
      }
      function Qt(t2, s2, i2) {
        if (!(this instanceof Qt)) return new Qt(t2, s2, i2);
        if (Array.isArray(t2)) this.x = t2[0], this.y = t2[1], this.z = t2[2] || 0;
        else if ("object" == typeof t2) this.x = t2.x, this.y = t2.y, this.z = t2.z || 0;
        else if ("string" == typeof t2 && void 0 === s2) {
          var a3 = t2.split(",");
          this.x = parseFloat(a3[0], 10), this.y = parseFloat(a3[1], 10), this.z = parseFloat(a3[2], 10) || 0;
        } else this.x = t2, this.y = s2, this.z = i2 || 0;
        console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
      }
      Qt.fromMGRS = function(t2) {
        return new Qt(Dt(t2));
      }, Qt.prototype.toMGRS = function(t2) {
        return kt([this.x, this.y], t2);
      };
      var Kt = 0.046875, Xt = 0.01953125, Vt = 0.01068115234375;
      function Jt(t2) {
        var s2 = [];
        s2[0] = 1 - t2 * (0.25 + t2 * (Kt + t2 * (Xt + t2 * Vt))), s2[1] = t2 * (0.75 - t2 * (Kt + t2 * (Xt + t2 * Vt)));
        var i2 = t2 * t2;
        return s2[2] = i2 * (0.46875 - t2 * (0.013020833333333334 + 0.007120768229166667 * t2)), i2 *= t2, s2[3] = i2 * (0.3645833333333333 - 0.005696614583333333 * t2), s2[4] = i2 * t2 * 0.3076171875, s2;
      }
      function Zt(t2, s2, i2, a3) {
        return i2 *= s2, s2 *= s2, a3[0] * t2 - i2 * (a3[1] + s2 * (a3[2] + s2 * (a3[3] + s2 * a3[4])));
      }
      function Yt(t2, s2, i2) {
        for (var a3 = 1 / (1 - s2), e2 = t2, n2 = 20; n2; --n2) {
          var r2 = Math.sin(e2), o2 = 1 - s2 * r2 * r2;
          if (e2 -= o2 = (Zt(e2, r2, Math.cos(e2), i2) - t2) * (o2 * Math.sqrt(o2)) * a3, Math.abs(o2) < h) return e2;
        }
        return e2;
      }
      var $t = { init: function() {
        this.x0 = void 0 !== this.x0 ? this.x0 : 0, this.y0 = void 0 !== this.y0 ? this.y0 : 0, this.long0 = void 0 !== this.long0 ? this.long0 : 0, this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0, this.es && (this.en = Jt(this.es), this.ml0 = Zt(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
      }, forward: function(t2) {
        var s2, i2, a3, e2 = t2.x, n2 = t2.y, r2 = z(e2 - this.long0), o2 = Math.sin(n2), l2 = Math.cos(n2);
        if (this.es) {
          var c2 = l2 * r2, _2 = Math.pow(c2, 2), u2 = this.ep2 * Math.pow(l2, 2), M5 = Math.pow(u2, 2), g2 = Math.abs(l2) > h ? Math.tan(n2) : 0, f2 = Math.pow(g2, 2), d2 = Math.pow(f2, 2);
          s2 = 1 - this.es * Math.pow(o2, 2), c2 /= Math.sqrt(s2);
          var p5 = Zt(n2, o2, l2, this.en);
          i2 = this.a * (this.k0 * c2 * (1 + _2 / 6 * (1 - f2 + u2 + _2 / 20 * (5 - 18 * f2 + d2 + 14 * u2 - 58 * f2 * u2 + _2 / 42 * (61 + 179 * d2 - d2 * f2 - 479 * f2))))) + this.x0, a3 = this.a * (this.k0 * (p5 - this.ml0 + o2 * r2 * c2 / 2 * (1 + _2 / 12 * (5 - f2 + 9 * u2 + 4 * M5 + _2 / 30 * (61 + d2 - 58 * f2 + 270 * u2 - 330 * f2 * u2 + _2 / 56 * (1385 + 543 * d2 - d2 * f2 - 3111 * f2)))))) + this.y0;
        } else {
          var m2 = l2 * Math.sin(r2);
          if (Math.abs(Math.abs(m2) - 1) < h) return 93;
          if (i2 = 0.5 * this.a * this.k0 * Math.log((1 + m2) / (1 - m2)) + this.x0, a3 = l2 * Math.cos(r2) / Math.sqrt(1 - Math.pow(m2, 2)), (m2 = Math.abs(a3)) >= 1) {
            if (m2 - 1 > h) return 93;
            a3 = 0;
          } else a3 = Math.acos(a3);
          n2 < 0 && (a3 = -a3), a3 = this.a * this.k0 * (a3 - this.lat0) + this.y0;
        }
        return t2.x = i2, t2.y = a3, t2;
      }, inverse: function(t2) {
        var s2, i2, e2, n2, r2 = (t2.x - this.x0) * (1 / this.a), o2 = (t2.y - this.y0) * (1 / this.a);
        if (this.es) if (i2 = Yt(s2 = this.ml0 + o2 / this.k0, this.es, this.en), Math.abs(i2) < a) {
          var l2 = Math.sin(i2), c2 = Math.cos(i2), _2 = Math.abs(c2) > h ? Math.tan(i2) : 0, u2 = this.ep2 * Math.pow(c2, 2), M5 = Math.pow(u2, 2), g2 = Math.pow(_2, 2), f2 = Math.pow(g2, 2);
          s2 = 1 - this.es * Math.pow(l2, 2);
          var d2 = r2 * Math.sqrt(s2) / this.k0, p5 = Math.pow(d2, 2);
          e2 = i2 - (s2 *= _2) * p5 / (1 - this.es) * 0.5 * (1 - p5 / 12 * (5 + 3 * g2 - 9 * u2 * g2 + u2 - 4 * M5 - p5 / 30 * (61 + 90 * g2 - 252 * u2 * g2 + 45 * f2 + 46 * u2 - p5 / 56 * (1385 + 3633 * g2 + 4095 * f2 + 1574 * f2 * g2)))), n2 = z(this.long0 + d2 * (1 - p5 / 6 * (1 + 2 * g2 + u2 - p5 / 20 * (5 + 28 * g2 + 24 * f2 + 8 * u2 * g2 + 6 * u2 - p5 / 42 * (61 + 662 * g2 + 1320 * f2 + 720 * f2 * g2)))) / c2);
        } else e2 = a * B(o2), n2 = 0;
        else {
          var m2 = Math.exp(r2 / this.k0), y2 = 0.5 * (m2 - 1 / m2), S2 = this.lat0 + o2 / this.k0, E5 = Math.cos(S2);
          s2 = Math.sqrt((1 - Math.pow(E5, 2)) / (1 + Math.pow(y2, 2))), e2 = Math.asin(s2), o2 < 0 && (e2 = -e2), n2 = 0 === y2 && 0 === E5 ? 0 : z(Math.atan2(y2, E5) + this.long0);
        }
        return t2.x = n2, t2.y = e2, t2;
      }, names: ["Fast_Transverse_Mercator", "Fast Transverse Mercator"] };
      function ts(t2) {
        var s2 = Math.exp(t2);
        return s2 = (s2 - 1 / s2) / 2;
      }
      function ss(t2, s2) {
        t2 = Math.abs(t2), s2 = Math.abs(s2);
        var i2 = Math.max(t2, s2), a3 = Math.min(t2, s2) / (i2 || 1);
        return i2 * Math.sqrt(1 + Math.pow(a3, 2));
      }
      function is(t2) {
        var s2 = Math.abs(t2);
        return s2 = function(t3) {
          var s3 = 1 + t3, i2 = s3 - 1;
          return 0 === i2 ? t3 : t3 * Math.log(s3) / i2;
        }(s2 * (1 + s2 / (ss(1, s2) + 1))), t2 < 0 ? -s2 : s2;
      }
      function as(t2, s2) {
        for (var i2, a3 = 2 * Math.cos(2 * s2), h2 = t2.length - 1, e2 = t2[h2], n2 = 0; --h2 >= 0; ) i2 = a3 * e2 - n2 + t2[h2], n2 = e2, e2 = i2;
        return s2 + i2 * Math.sin(2 * s2);
      }
      function hs(t2, s2, i2) {
        for (var a3, h2, e2 = Math.sin(s2), n2 = Math.cos(s2), r2 = ts(i2), o2 = function(t3) {
          var s3 = Math.exp(t3);
          return (s3 + 1 / s3) / 2;
        }(i2), l2 = 2 * n2 * o2, c2 = -2 * e2 * r2, _2 = t2.length - 1, u2 = t2[_2], M5 = 0, g2 = 0, f2 = 0; --_2 >= 0; ) a3 = g2, h2 = M5, u2 = l2 * (g2 = u2) - a3 - c2 * (M5 = f2) + t2[_2], f2 = c2 * g2 - h2 + l2 * M5;
        return [(l2 = e2 * o2) * u2 - (c2 = n2 * r2) * f2, l2 * f2 + c2 * u2];
      }
      var es = { init: function() {
        if (!this.approx && (isNaN(this.es) || this.es <= 0)) throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
        this.approx && ($t.init.apply(this), this.forward = $t.forward, this.inverse = $t.inverse), this.x0 = void 0 !== this.x0 ? this.x0 : 0, this.y0 = void 0 !== this.y0 ? this.y0 : 0, this.long0 = void 0 !== this.long0 ? this.long0 : 0, this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
        var t2 = this.es / (1 + Math.sqrt(1 - this.es)), s2 = t2 / (2 - t2), i2 = s2;
        this.cgb[0] = s2 * (2 + s2 * (-2 / 3 + s2 * (s2 * (116 / 45 + s2 * (26 / 45 + s2 * (-2854 / 675))) - 2))), this.cbg[0] = s2 * (s2 * (2 / 3 + s2 * (4 / 3 + s2 * (-82 / 45 + s2 * (32 / 45 + s2 * (4642 / 4725))))) - 2), i2 *= s2, this.cgb[1] = i2 * (7 / 3 + s2 * (s2 * (-227 / 45 + s2 * (2704 / 315 + s2 * (2323 / 945))) - 1.6)), this.cbg[1] = i2 * (5 / 3 + s2 * (-16 / 15 + s2 * (-13 / 9 + s2 * (904 / 315 + s2 * (-1522 / 945))))), i2 *= s2, this.cgb[2] = i2 * (56 / 15 + s2 * (-136 / 35 + s2 * (-1262 / 105 + s2 * (73814 / 2835)))), this.cbg[2] = i2 * (-26 / 15 + s2 * (34 / 21 + s2 * (1.6 + s2 * (-12686 / 2835)))), i2 *= s2, this.cgb[3] = i2 * (4279 / 630 + s2 * (-332 / 35 + s2 * (-399572 / 14175))), this.cbg[3] = i2 * (1237 / 630 + s2 * (s2 * (-24832 / 14175) - 2.4)), i2 *= s2, this.cgb[4] = i2 * (4174 / 315 + s2 * (-144838 / 6237)), this.cbg[4] = i2 * (-734 / 315 + s2 * (109598 / 31185)), i2 *= s2, this.cgb[5] = i2 * (601676 / 22275), this.cbg[5] = i2 * (444337 / 155925), i2 = Math.pow(s2, 2), this.Qn = this.k0 / (1 + s2) * (1 + i2 * (1 / 4 + i2 * (1 / 64 + i2 / 256))), this.utg[0] = s2 * (s2 * (2 / 3 + s2 * (-37 / 96 + s2 * (1 / 360 + s2 * (81 / 512 + s2 * (-96199 / 604800))))) - 0.5), this.gtu[0] = s2 * (0.5 + s2 * (-2 / 3 + s2 * (5 / 16 + s2 * (41 / 180 + s2 * (-127 / 288 + s2 * (7891 / 37800)))))), this.utg[1] = i2 * (-1 / 48 + s2 * (-1 / 15 + s2 * (437 / 1440 + s2 * (-46 / 105 + s2 * (1118711 / 3870720))))), this.gtu[1] = i2 * (13 / 48 + s2 * (s2 * (557 / 1440 + s2 * (281 / 630 + s2 * (-1983433 / 1935360))) - 0.6)), i2 *= s2, this.utg[2] = i2 * (-17 / 480 + s2 * (37 / 840 + s2 * (209 / 4480 + s2 * (-5569 / 90720)))), this.gtu[2] = i2 * (61 / 240 + s2 * (-103 / 140 + s2 * (15061 / 26880 + s2 * (167603 / 181440)))), i2 *= s2, this.utg[3] = i2 * (-4397 / 161280 + s2 * (11 / 504 + s2 * (830251 / 7257600))), this.gtu[3] = i2 * (49561 / 161280 + s2 * (-179 / 168 + s2 * (6601661 / 7257600))), i2 *= s2, this.utg[4] = i2 * (-4583 / 161280 + s2 * (108847 / 3991680)), this.gtu[4] = i2 * (34729 / 80640 + s2 * (-3418889 / 1995840)), i2 *= s2, this.utg[5] = i2 * (-20648693 / 638668800), this.gtu[5] = 0.6650675310896665 * i2;
        var a3 = as(this.cbg, this.lat0);
        this.Zb = -this.Qn * (a3 + function(t3, s3) {
          for (var i3, a4 = 2 * Math.cos(s3), h2 = t3.length - 1, e2 = t3[h2], n2 = 0; --h2 >= 0; ) i3 = a4 * e2 - n2 + t3[h2], n2 = e2, e2 = i3;
          return Math.sin(s3) * i3;
        }(this.gtu, 2 * a3));
      }, forward: function(t2) {
        var s2 = z(t2.x - this.long0), i2 = t2.y;
        i2 = as(this.cbg, i2);
        var a3 = Math.sin(i2), h2 = Math.cos(i2), e2 = Math.sin(s2), n2 = Math.cos(s2);
        i2 = Math.atan2(a3, n2 * h2), s2 = Math.atan2(e2 * h2, ss(a3, h2 * n2)), s2 = is(Math.tan(s2));
        var r2, o2, l2 = hs(this.gtu, 2 * i2, 2 * s2);
        return i2 += l2[0], s2 += l2[1], Math.abs(s2) <= 2.623395162778 ? (r2 = this.a * (this.Qn * s2) + this.x0, o2 = this.a * (this.Qn * i2 + this.Zb) + this.y0) : (r2 = 1 / 0, o2 = 1 / 0), t2.x = r2, t2.y = o2, t2;
      }, inverse: function(t2) {
        var s2, i2, a3 = (t2.x - this.x0) * (1 / this.a), h2 = (t2.y - this.y0) * (1 / this.a);
        if (h2 = (h2 - this.Zb) / this.Qn, a3 /= this.Qn, Math.abs(a3) <= 2.623395162778) {
          var e2 = hs(this.utg, 2 * h2, 2 * a3);
          h2 += e2[0], a3 += e2[1], a3 = Math.atan(ts(a3));
          var n2 = Math.sin(h2), r2 = Math.cos(h2), o2 = Math.sin(a3), l2 = Math.cos(a3);
          h2 = Math.atan2(n2 * l2, ss(o2, l2 * r2)), s2 = z((a3 = Math.atan2(o2, l2 * r2)) + this.long0), i2 = as(this.cgb, h2);
        } else s2 = 1 / 0, i2 = 1 / 0;
        return t2.x = s2, t2.y = i2, t2;
      }, names: ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "Gauss Kruger", "Gauss_Kruger", "tmerc"] };
      var ns = { init: function() {
        var t2 = function(t3, s2) {
          if (void 0 === t3) {
            if ((t3 = Math.floor(30 * (z(s2) + Math.PI) / Math.PI) + 1) < 0) return 0;
            if (t3 > 60) return 60;
          }
          return t3;
        }(this.zone, this.long0);
        if (void 0 === t2) throw new Error("unknown utm zone");
        this.lat0 = 0, this.long0 = (6 * Math.abs(t2) - 183) * e, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, es.init.apply(this), this.forward = es.forward, this.inverse = es.inverse;
      }, names: ["Universal Transverse Mercator System", "utm"], dependsOn: "etmerc" };
      function rs(t2, s2) {
        return Math.pow((1 - t2) / (1 + t2), s2);
      }
      var os = { init: function() {
        var t2 = Math.sin(this.lat0), s2 = Math.cos(this.lat0);
        s2 *= s2, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * t2 * t2), this.C = Math.sqrt(1 + this.es * s2 * s2 / (1 - this.es)), this.phic0 = Math.asin(t2 / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + r) / (Math.pow(Math.tan(0.5 * this.lat0 + r), this.C) * rs(this.e * t2, this.ratexp));
      }, forward: function(t2) {
        var s2 = t2.x, i2 = t2.y;
        return t2.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * i2 + r), this.C) * rs(this.e * Math.sin(i2), this.ratexp)) - a, t2.x = this.C * s2, t2;
      }, inverse: function(t2) {
        for (var s2 = t2.x / this.C, i2 = t2.y, h2 = Math.pow(Math.tan(0.5 * i2 + r) / this.K, 1 / this.C), e2 = 20; e2 > 0 && (i2 = 2 * Math.atan(h2 * rs(this.e * Math.sin(t2.y), -0.5 * this.e)) - a, !(Math.abs(i2 - t2.y) < 1e-14)); --e2) t2.y = i2;
        return e2 ? (t2.x = s2, t2.y = i2, t2) : null;
      } };
      var ls = { init: function() {
        os.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
      }, forward: function(t2) {
        var s2, i2, a3, h2;
        return t2.x = z(t2.x - this.long0), os.forward.apply(this, [t2]), s2 = Math.sin(t2.y), i2 = Math.cos(t2.y), a3 = Math.cos(t2.x), h2 = this.k0 * this.R2 / (1 + this.sinc0 * s2 + this.cosc0 * i2 * a3), t2.x = h2 * i2 * Math.sin(t2.x), t2.y = h2 * (this.cosc0 * s2 - this.sinc0 * i2 * a3), t2.x = this.a * t2.x + this.x0, t2.y = this.a * t2.y + this.y0, t2;
      }, inverse: function(t2) {
        var s2, i2, a3, h2, e2;
        if (t2.x = (t2.x - this.x0) / this.a, t2.y = (t2.y - this.y0) / this.a, t2.x /= this.k0, t2.y /= this.k0, e2 = ss(t2.x, t2.y)) {
          var n2 = 2 * Math.atan2(e2, this.R2);
          s2 = Math.sin(n2), i2 = Math.cos(n2), h2 = Math.asin(i2 * this.sinc0 + t2.y * s2 * this.cosc0 / e2), a3 = Math.atan2(t2.x * s2, e2 * this.cosc0 * i2 - t2.y * this.sinc0 * s2);
        } else h2 = this.phic0, a3 = 0;
        return t2.x = a3, t2.y = h2, os.inverse.apply(this, [t2]), t2.x = z(t2.x + this.long0), t2;
      }, names: ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"] };
      var cs = { init: function() {
        this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= h && (this.k0 = 0.5 * (1 + B(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= h && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= h && Math.abs(Math.cos(this.lat_ts)) > h && (this.k0 = 0.5 * this.cons * F(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / H(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = F(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - a, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
      }, forward: function(t2) {
        var s2, i2, e2, n2, r2, o2, l2 = t2.x, c2 = t2.y, _2 = Math.sin(c2), u2 = Math.cos(c2), M5 = z(l2 - this.long0);
        return Math.abs(Math.abs(l2 - this.long0) - Math.PI) <= h && Math.abs(c2 + this.lat0) <= h ? (t2.x = NaN, t2.y = NaN, t2) : this.sphere ? (s2 = 2 * this.k0 / (1 + this.sinlat0 * _2 + this.coslat0 * u2 * Math.cos(M5)), t2.x = this.a * s2 * u2 * Math.sin(M5) + this.x0, t2.y = this.a * s2 * (this.coslat0 * _2 - this.sinlat0 * u2 * Math.cos(M5)) + this.y0, t2) : (i2 = 2 * Math.atan(this.ssfn_(c2, _2, this.e)) - a, n2 = Math.cos(i2), e2 = Math.sin(i2), Math.abs(this.coslat0) <= h ? (r2 = H(this.e, c2 * this.con, this.con * _2), o2 = 2 * this.a * this.k0 * r2 / this.cons, t2.x = this.x0 + o2 * Math.sin(l2 - this.long0), t2.y = this.y0 - this.con * o2 * Math.cos(l2 - this.long0), t2) : (Math.abs(this.sinlat0) < h ? (s2 = 2 * this.a * this.k0 / (1 + n2 * Math.cos(M5)), t2.y = s2 * e2) : (s2 = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * e2 + this.cosX0 * n2 * Math.cos(M5))), t2.y = s2 * (this.cosX0 * e2 - this.sinX0 * n2 * Math.cos(M5)) + this.y0), t2.x = s2 * n2 * Math.sin(M5) + this.x0, t2));
      }, inverse: function(t2) {
        var s2, i2, e2, n2, r2;
        t2.x -= this.x0, t2.y -= this.y0;
        var o2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y);
        if (this.sphere) {
          var l2 = 2 * Math.atan(o2 / (2 * this.a * this.k0));
          return s2 = this.long0, i2 = this.lat0, o2 <= h ? (t2.x = s2, t2.y = i2, t2) : (i2 = Math.asin(Math.cos(l2) * this.sinlat0 + t2.y * Math.sin(l2) * this.coslat0 / o2), s2 = Math.abs(this.coslat0) < h ? this.lat0 > 0 ? z(this.long0 + Math.atan2(t2.x, -1 * t2.y)) : z(this.long0 + Math.atan2(t2.x, t2.y)) : z(this.long0 + Math.atan2(t2.x * Math.sin(l2), o2 * this.coslat0 * Math.cos(l2) - t2.y * this.sinlat0 * Math.sin(l2))), t2.x = s2, t2.y = i2, t2);
        }
        if (Math.abs(this.coslat0) <= h) {
          if (o2 <= h) return i2 = this.lat0, s2 = this.long0, t2.x = s2, t2.y = i2, t2;
          t2.x *= this.con, t2.y *= this.con, e2 = o2 * this.cons / (2 * this.a * this.k0), i2 = this.con * W(this.e, e2), s2 = this.con * z(this.con * this.long0 + Math.atan2(t2.x, -1 * t2.y));
        } else n2 = 2 * Math.atan(o2 * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), s2 = this.long0, o2 <= h ? r2 = this.X0 : (r2 = Math.asin(Math.cos(n2) * this.sinX0 + t2.y * Math.sin(n2) * this.cosX0 / o2), s2 = z(this.long0 + Math.atan2(t2.x * Math.sin(n2), o2 * this.cosX0 * Math.cos(n2) - t2.y * this.sinX0 * Math.sin(n2)))), i2 = -1 * W(this.e, Math.tan(0.5 * (a + r2)));
        return t2.x = s2, t2.y = i2, t2;
      }, names: ["stere", "Stereographic_South_Pole", "Polar_Stereographic_variant_A", "Polar_Stereographic_variant_B", "Polar_Stereographic"], ssfn_: function(t2, s2, i2) {
        return s2 *= i2, Math.tan(0.5 * (a + t2)) * Math.pow((1 - s2) / (1 + s2), 0.5 * i2);
      } };
      var _s = { init: function() {
        var t2 = this.lat0;
        this.lambda0 = this.long0;
        var s2 = Math.sin(t2), i2 = this.a, a3 = 1 / this.rf, h2 = 2 * a3 - Math.pow(a3, 2), e2 = this.e = Math.sqrt(h2);
        this.R = this.k0 * i2 * Math.sqrt(1 - h2) / (1 - h2 * Math.pow(s2, 2)), this.alpha = Math.sqrt(1 + h2 / (1 - h2) * Math.pow(Math.cos(t2), 4)), this.b0 = Math.asin(s2 / this.alpha);
        var n2 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), r2 = Math.log(Math.tan(Math.PI / 4 + t2 / 2)), o2 = Math.log((1 + e2 * s2) / (1 - e2 * s2));
        this.K = n2 - this.alpha * r2 + this.alpha * e2 / 2 * o2;
      }, forward: function(t2) {
        var s2 = Math.log(Math.tan(Math.PI / 4 - t2.y / 2)), i2 = this.e / 2 * Math.log((1 + this.e * Math.sin(t2.y)) / (1 - this.e * Math.sin(t2.y))), a3 = -this.alpha * (s2 + i2) + this.K, h2 = 2 * (Math.atan(Math.exp(a3)) - Math.PI / 4), e2 = this.alpha * (t2.x - this.lambda0), n2 = Math.atan(Math.sin(e2) / (Math.sin(this.b0) * Math.tan(h2) + Math.cos(this.b0) * Math.cos(e2))), r2 = Math.asin(Math.cos(this.b0) * Math.sin(h2) - Math.sin(this.b0) * Math.cos(h2) * Math.cos(e2));
        return t2.y = this.R / 2 * Math.log((1 + Math.sin(r2)) / (1 - Math.sin(r2))) + this.y0, t2.x = this.R * n2 + this.x0, t2;
      }, inverse: function(t2) {
        for (var s2 = t2.x - this.x0, i2 = t2.y - this.y0, a3 = s2 / this.R, h2 = 2 * (Math.atan(Math.exp(i2 / this.R)) - Math.PI / 4), e2 = Math.asin(Math.cos(this.b0) * Math.sin(h2) + Math.sin(this.b0) * Math.cos(h2) * Math.cos(a3)), n2 = Math.atan(Math.sin(a3) / (Math.cos(this.b0) * Math.cos(a3) - Math.sin(this.b0) * Math.tan(h2))), r2 = this.lambda0 + n2 / this.alpha, o2 = 0, l2 = e2, c2 = -1e3, _2 = 0; Math.abs(l2 - c2) > 1e-7; ) {
          if (++_2 > 20) return;
          o2 = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + e2 / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(l2)) / 2)), c2 = l2, l2 = 2 * Math.atan(Math.exp(o2)) - Math.PI / 2;
        }
        return t2.x = r2, t2.y = l2, t2;
      }, names: ["somerc"] }, us = 1e-7;
      var Ms = { init: function() {
        var t2, s2, i2, e2, n2, l2, c2, _2, u2, M5, g2, f2, d2, p5, m2 = 0, y2 = 0, S2 = 0, E5 = 0, w2 = 0, v2 = 0, G2 = 0;
        this.no_off = (d2 = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_variant_A", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], p5 = "object" == typeof (f2 = this).projName ? Object.keys(f2.projName)[0] : f2.projName, "no_uoff" in f2 || "no_off" in f2 || -1 !== d2.indexOf(p5) || -1 !== d2.indexOf(Z(p5))), this.no_rot = "no_rot" in this;
        var x2 = false;
        "alpha" in this && (x2 = true);
        var P6 = false;
        if ("rectified_grid_angle" in this && (P6 = true), x2 && (G2 = this.alpha), P6 && (m2 = this.rectified_grid_angle), x2 || P6) y2 = this.longc;
        else if (S2 = this.long1, w2 = this.lat1, E5 = this.long2, v2 = this.lat2, Math.abs(w2 - v2) <= us || (t2 = Math.abs(w2)) <= us || Math.abs(t2 - a) <= us || Math.abs(Math.abs(this.lat0) - a) <= us || Math.abs(Math.abs(v2) - a) <= us) throw new Error();
        var b3 = 1 - this.es;
        s2 = Math.sqrt(b3), Math.abs(this.lat0) > h ? (_2 = Math.sin(this.lat0), i2 = Math.cos(this.lat0), t2 = 1 - this.es * _2 * _2, this.B = i2 * i2, this.B = Math.sqrt(1 + this.es * this.B * this.B / b3), this.A = this.B * this.k0 * s2 / t2, (n2 = (e2 = this.B * s2 / (i2 * Math.sqrt(t2))) * e2 - 1) <= 0 ? n2 = 0 : (n2 = Math.sqrt(n2), this.lat0 < 0 && (n2 = -n2)), this.E = n2 += e2, this.E *= Math.pow(H(this.e, this.lat0, _2), this.B)) : (this.B = 1 / s2, this.A = this.k0, this.E = e2 = n2 = 1), x2 || P6 ? (x2 ? (g2 = Math.asin(Math.sin(G2) / e2), P6 || (m2 = G2)) : (g2 = m2, G2 = Math.asin(e2 * Math.sin(g2))), this.lam0 = y2 - Math.asin(0.5 * (n2 - 1 / n2) * Math.tan(g2)) / this.B) : (l2 = Math.pow(H(this.e, w2, Math.sin(w2)), this.B), c2 = Math.pow(H(this.e, v2, Math.sin(v2)), this.B), n2 = this.E / l2, u2 = (c2 - l2) / (c2 + l2), M5 = ((M5 = this.E * this.E) - c2 * l2) / (M5 + c2 * l2), (t2 = S2 - E5) < -Math.pi ? E5 -= o : t2 > Math.pi && (E5 += o), this.lam0 = z(0.5 * (S2 + E5) - Math.atan(M5 * Math.tan(0.5 * this.B * (S2 - E5)) / u2) / this.B), g2 = Math.atan(2 * Math.sin(this.B * z(S2 - this.lam0)) / (n2 - 1 / n2)), m2 = G2 = Math.asin(e2 * Math.sin(g2))), this.singam = Math.sin(g2), this.cosgam = Math.cos(g2), this.sinrot = Math.sin(m2), this.cosrot = Math.cos(m2), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(e2 * e2 - 1) / Math.cos(G2))), this.lat0 < 0 && (this.u_0 = -this.u_0)), n2 = 0.5 * g2, this.v_pole_n = this.ArB * Math.log(Math.tan(r - n2)), this.v_pole_s = this.ArB * Math.log(Math.tan(r + n2));
      }, forward: function(t2) {
        var s2, i2, e2, n2, r2, o2, l2, c2, _2 = {};
        if (t2.x = t2.x - this.lam0, Math.abs(Math.abs(t2.y) - a) > h) {
          if (s2 = 0.5 * ((r2 = this.E / Math.pow(H(this.e, t2.y, Math.sin(t2.y)), this.B)) - (o2 = 1 / r2)), i2 = 0.5 * (r2 + o2), n2 = Math.sin(this.B * t2.x), e2 = (s2 * this.singam - n2 * this.cosgam) / i2, Math.abs(Math.abs(e2) - 1) < h) throw new Error();
          c2 = 0.5 * this.ArB * Math.log((1 - e2) / (1 + e2)), o2 = Math.cos(this.B * t2.x), l2 = Math.abs(o2) < us ? this.A * t2.x : this.ArB * Math.atan2(s2 * this.cosgam + n2 * this.singam, o2);
        } else c2 = t2.y > 0 ? this.v_pole_n : this.v_pole_s, l2 = this.ArB * t2.y;
        return this.no_rot ? (_2.x = l2, _2.y = c2) : (l2 -= this.u_0, _2.x = c2 * this.cosrot + l2 * this.sinrot, _2.y = l2 * this.cosrot - c2 * this.sinrot), _2.x = this.a * _2.x + this.x0, _2.y = this.a * _2.y + this.y0, _2;
      }, inverse: function(t2) {
        var s2, i2, e2, n2, r2, o2, l2, c2 = {};
        if (t2.x = (t2.x - this.x0) * (1 / this.a), t2.y = (t2.y - this.y0) * (1 / this.a), this.no_rot ? (i2 = t2.y, s2 = t2.x) : (i2 = t2.x * this.cosrot - t2.y * this.sinrot, s2 = t2.y * this.cosrot + t2.x * this.sinrot + this.u_0), n2 = 0.5 * ((e2 = Math.exp(-this.BrA * i2)) - 1 / e2), r2 = 0.5 * (e2 + 1 / e2), l2 = ((o2 = Math.sin(this.BrA * s2)) * this.cosgam + n2 * this.singam) / r2, Math.abs(Math.abs(l2) - 1) < h) c2.x = 0, c2.y = l2 < 0 ? -a : a;
        else {
          if (c2.y = this.E / Math.sqrt((1 + l2) / (1 - l2)), c2.y = W(this.e, Math.pow(c2.y, 1 / this.B)), c2.y === 1 / 0) throw new Error();
          c2.x = -this.rB * Math.atan2(n2 * this.cosgam - o2 * this.singam, Math.cos(this.BrA * s2));
        }
        return c2.x += this.lam0, c2;
      }, names: ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_variant_A", "Hotine_Oblique_Mercator_Variant_B", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"] };
      var gs = { init: function() {
        if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < h)) {
          var t2 = this.b / this.a;
          this.e = Math.sqrt(1 - t2 * t2);
          var s2 = Math.sin(this.lat1), i2 = Math.cos(this.lat1), e2 = F(this.e, s2, i2), n2 = H(this.e, this.lat1, s2), r2 = Math.sin(this.lat2), o2 = Math.cos(this.lat2), l2 = F(this.e, r2, o2), c2 = H(this.e, this.lat2, r2), _2 = Math.abs(Math.abs(this.lat0) - a) < h ? 0 : H(this.e, this.lat0, Math.sin(this.lat0));
          Math.abs(this.lat1 - this.lat2) > h ? this.ns = Math.log(e2 / l2) / Math.log(n2 / c2) : this.ns = s2, isNaN(this.ns) && (this.ns = s2), this.f0 = e2 / (this.ns * Math.pow(n2, this.ns)), this.rh = this.a * this.f0 * Math.pow(_2, this.ns), this.title || (this.title = "Lambert Conformal Conic");
        }
      }, forward: function(t2) {
        var s2 = t2.x, i2 = t2.y;
        Math.abs(2 * Math.abs(i2) - Math.PI) <= h && (i2 = B(i2) * (a - 2e-10));
        var e2, n2, r2 = Math.abs(Math.abs(i2) - a);
        if (r2 > h) e2 = H(this.e, i2, Math.sin(i2)), n2 = this.a * this.f0 * Math.pow(e2, this.ns);
        else {
          if ((r2 = i2 * this.ns) <= 0) return null;
          n2 = 0;
        }
        var o2 = this.ns * z(s2 - this.long0);
        return t2.x = this.k0 * (n2 * Math.sin(o2)) + this.x0, t2.y = this.k0 * (this.rh - n2 * Math.cos(o2)) + this.y0, t2;
      }, inverse: function(t2) {
        var s2, i2, h2, e2, n2, r2 = (t2.x - this.x0) / this.k0, o2 = this.rh - (t2.y - this.y0) / this.k0;
        this.ns > 0 ? (s2 = Math.sqrt(r2 * r2 + o2 * o2), i2 = 1) : (s2 = -Math.sqrt(r2 * r2 + o2 * o2), i2 = -1);
        var l2 = 0;
        if (0 !== s2 && (l2 = Math.atan2(i2 * r2, i2 * o2)), 0 !== s2 || this.ns > 0) {
          if (i2 = 1 / this.ns, h2 = Math.pow(s2 / (this.a * this.f0), i2), -9999 === (e2 = W(this.e, h2))) return null;
        } else e2 = -a;
        return n2 = z(l2 / this.ns + this.long0), t2.x = n2, t2.y = e2, t2;
      }, names: ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_1SP", "Lambert_Conformal_Conic_2SP", "lcc", "Lambert Conic Conformal (1SP)", "Lambert Conic Conformal (2SP)"] };
      var fs = { init: function() {
        this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.4334234309119251), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
      }, forward: function(t2) {
        var s2, i2, a3, h2, e2, n2, r2, o2 = t2.x, l2 = t2.y, c2 = z(o2 - this.long0);
        return s2 = Math.pow((1 + this.e * Math.sin(l2)) / (1 - this.e * Math.sin(l2)), this.alfa * this.e / 2), i2 = 2 * (Math.atan(this.k * Math.pow(Math.tan(l2 / 2 + this.s45), this.alfa) / s2) - this.s45), a3 = -c2 * this.alfa, h2 = Math.asin(Math.cos(this.ad) * Math.sin(i2) + Math.sin(this.ad) * Math.cos(i2) * Math.cos(a3)), e2 = Math.asin(Math.cos(i2) * Math.sin(a3) / Math.cos(h2)), n2 = this.n * e2, r2 = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(h2 / 2 + this.s45), this.n), t2.y = r2 * Math.cos(n2) / 1, t2.x = r2 * Math.sin(n2) / 1, this.czech || (t2.y *= -1, t2.x *= -1), t2;
      }, inverse: function(t2) {
        var s2, i2, a3, h2, e2, n2, r2, o2 = t2.x;
        t2.x = t2.y, t2.y = o2, this.czech || (t2.y *= -1, t2.x *= -1), e2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), h2 = Math.atan2(t2.y, t2.x) / Math.sin(this.s0), a3 = 2 * (Math.atan(Math.pow(this.ro0 / e2, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), s2 = Math.asin(Math.cos(this.ad) * Math.sin(a3) - Math.sin(this.ad) * Math.cos(a3) * Math.cos(h2)), i2 = Math.asin(Math.cos(a3) * Math.sin(h2) / Math.cos(s2)), t2.x = this.long0 - i2 / this.alfa, n2 = s2, r2 = 0;
        var l2 = 0;
        do {
          t2.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(s2 / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(n2)) / (1 - this.e * Math.sin(n2)), this.e / 2)) - this.s45), Math.abs(n2 - t2.y) < 1e-10 && (r2 = 1), n2 = t2.y, l2 += 1;
        } while (0 === r2 && l2 < 15);
        return l2 >= 15 ? null : t2;
      }, names: ["Krovak", "krovak"] };
      function ds(t2, s2, i2, a3, h2) {
        return t2 * h2 - s2 * Math.sin(2 * h2) + i2 * Math.sin(4 * h2) - a3 * Math.sin(6 * h2);
      }
      function ps(t2) {
        return 1 - 0.25 * t2 * (1 + t2 / 16 * (3 + 1.25 * t2));
      }
      function ms(t2) {
        return 0.375 * t2 * (1 + 0.25 * t2 * (1 + 0.46875 * t2));
      }
      function ys(t2) {
        return 0.05859375 * t2 * t2 * (1 + 0.75 * t2);
      }
      function Ss(t2) {
        return t2 * t2 * t2 * (35 / 3072);
      }
      function Es(t2, s2, i2) {
        var a3 = s2 * i2;
        return t2 / Math.sqrt(1 - a3 * a3);
      }
      function ws(t2) {
        return Math.abs(t2) < a ? t2 : t2 - B(t2) * Math.PI;
      }
      function vs(t2, s2, i2, a3, h2) {
        var e2, n2;
        e2 = t2 / s2;
        for (var r2 = 0; r2 < 15; r2++) if (e2 += n2 = (t2 - (s2 * e2 - i2 * Math.sin(2 * e2) + a3 * Math.sin(4 * e2) - h2 * Math.sin(6 * e2))) / (s2 - 2 * i2 * Math.cos(2 * e2) + 4 * a3 * Math.cos(4 * e2) - 6 * h2 * Math.cos(6 * e2)), Math.abs(n2) <= 1e-10) return e2;
        return NaN;
      }
      var Gs = { init: function() {
        this.sphere || (this.e0 = ps(this.es), this.e1 = ms(this.es), this.e2 = ys(this.es), this.e3 = Ss(this.es), this.ml0 = this.a * ds(this.e0, this.e1, this.e2, this.e3, this.lat0));
      }, forward: function(t2) {
        var s2, i2, a3 = t2.x, h2 = t2.y;
        if (a3 = z(a3 - this.long0), this.sphere) s2 = this.a * Math.asin(Math.cos(h2) * Math.sin(a3)), i2 = this.a * (Math.atan2(Math.tan(h2), Math.cos(a3)) - this.lat0);
        else {
          var e2 = Math.sin(h2), n2 = Math.cos(h2), r2 = Es(this.a, this.e, e2), o2 = Math.tan(h2) * Math.tan(h2), l2 = a3 * Math.cos(h2), c2 = l2 * l2, _2 = this.es * n2 * n2 / (1 - this.es);
          s2 = r2 * l2 * (1 - c2 * o2 * (1 / 6 - (8 - o2 + 8 * _2) * c2 / 120)), i2 = this.a * ds(this.e0, this.e1, this.e2, this.e3, h2) - this.ml0 + r2 * e2 / n2 * c2 * (0.5 + (5 - o2 + 6 * _2) * c2 / 24);
        }
        return t2.x = s2 + this.x0, t2.y = i2 + this.y0, t2;
      }, inverse: function(t2) {
        t2.x -= this.x0, t2.y -= this.y0;
        var s2, i2, e2 = t2.x / this.a, n2 = t2.y / this.a;
        if (this.sphere) {
          var r2 = n2 + this.lat0;
          s2 = Math.asin(Math.sin(r2) * Math.cos(e2)), i2 = Math.atan2(Math.tan(e2), Math.cos(r2));
        } else {
          var o2 = vs(this.ml0 / this.a + n2, this.e0, this.e1, this.e2, this.e3);
          if (Math.abs(Math.abs(o2) - a) <= h) return t2.x = this.long0, t2.y = a, n2 < 0 && (t2.y *= -1), t2;
          var l2 = Es(this.a, this.e, Math.sin(o2)), c2 = l2 * l2 * l2 / this.a / this.a * (1 - this.es), _2 = Math.pow(Math.tan(o2), 2), u2 = e2 * this.a / l2, M5 = u2 * u2;
          s2 = o2 - l2 * Math.tan(o2) / c2 * u2 * u2 * (0.5 - (1 + 3 * _2) * u2 * u2 / 24), i2 = u2 * (1 - M5 * (_2 / 3 + (1 + 3 * _2) * _2 * M5 / 15)) / Math.cos(o2);
        }
        return t2.x = z(i2 + this.long0), t2.y = ws(s2), t2;
      }, names: ["Cassini", "Cassini_Soldner", "cass"] };
      function xs(t2, s2) {
        var i2;
        return t2 > 1e-7 ? (1 - t2 * t2) * (s2 / (1 - (i2 = t2 * s2) * i2) - 0.5 / t2 * Math.log((1 - i2) / (1 + i2))) : 2 * s2;
      }
      var Ps = 0.3333333333333333, bs = 0.17222222222222222, As = 0.10257936507936508, Cs = 0.06388888888888888, Ns = 0.0664021164021164, Is = 0.016415012942191543;
      var Ls = { init: function() {
        var t2, s2 = Math.abs(this.lat0);
        if (Math.abs(s2 - a) < h ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(s2) < h ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) switch (this.qp = xs(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = function(t3) {
          var s3, i2 = [];
          return i2[0] = t3 * Ps, s3 = t3 * t3, i2[0] += s3 * bs, i2[1] = s3 * Cs, s3 *= t3, i2[0] += s3 * As, i2[1] += s3 * Ns, i2[2] = s3 * Is, i2;
        }(this.es), this.mode) {
          case this.N_POLE:
          case this.S_POLE:
            this.dd = 1;
            break;
          case this.EQUIT:
            this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
            break;
          case this.OBLIQ:
            this.rq = Math.sqrt(0.5 * this.qp), t2 = Math.sin(this.lat0), this.sinb1 = xs(this.e, t2) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * t2 * t2) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
        }
        else this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
      }, forward: function(t2) {
        var s2, i2, e2, n2, o2, l2, c2, _2, u2, M5, g2 = t2.x, f2 = t2.y;
        if (g2 = z(g2 - this.long0), this.sphere) {
          if (o2 = Math.sin(f2), M5 = Math.cos(f2), e2 = Math.cos(g2), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
            if ((i2 = this.mode === this.EQUIT ? 1 + M5 * e2 : 1 + this.sinph0 * o2 + this.cosph0 * M5 * e2) <= h) return null;
            s2 = (i2 = Math.sqrt(2 / i2)) * M5 * Math.sin(g2), i2 *= this.mode === this.EQUIT ? o2 : this.cosph0 * o2 - this.sinph0 * M5 * e2;
          } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
            if (this.mode === this.N_POLE && (e2 = -e2), Math.abs(f2 + this.lat0) < h) return null;
            i2 = r - 0.5 * f2, s2 = (i2 = 2 * (this.mode === this.S_POLE ? Math.cos(i2) : Math.sin(i2))) * Math.sin(g2), i2 *= e2;
          }
        } else {
          switch (c2 = 0, _2 = 0, u2 = 0, e2 = Math.cos(g2), n2 = Math.sin(g2), o2 = Math.sin(f2), l2 = xs(this.e, o2), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (c2 = l2 / this.qp, _2 = Math.sqrt(1 - c2 * c2)), this.mode) {
            case this.OBLIQ:
              u2 = 1 + this.sinb1 * c2 + this.cosb1 * _2 * e2;
              break;
            case this.EQUIT:
              u2 = 1 + _2 * e2;
              break;
            case this.N_POLE:
              u2 = a + f2, l2 = this.qp - l2;
              break;
            case this.S_POLE:
              u2 = f2 - a, l2 = this.qp + l2;
          }
          if (Math.abs(u2) < h) return null;
          switch (this.mode) {
            case this.OBLIQ:
            case this.EQUIT:
              u2 = Math.sqrt(2 / u2), i2 = this.mode === this.OBLIQ ? this.ymf * u2 * (this.cosb1 * c2 - this.sinb1 * _2 * e2) : (u2 = Math.sqrt(2 / (1 + _2 * e2))) * c2 * this.ymf, s2 = this.xmf * u2 * _2 * n2;
              break;
            case this.N_POLE:
            case this.S_POLE:
              l2 >= 0 ? (s2 = (u2 = Math.sqrt(l2)) * n2, i2 = e2 * (this.mode === this.S_POLE ? u2 : -u2)) : s2 = i2 = 0;
          }
        }
        return t2.x = this.a * s2 + this.x0, t2.y = this.a * i2 + this.y0, t2;
      }, inverse: function(t2) {
        t2.x -= this.x0, t2.y -= this.y0;
        var s2, i2, e2, n2, r2, o2, l2, c2, _2, u2, M5 = t2.x / this.a, g2 = t2.y / this.a;
        if (this.sphere) {
          var f2, d2 = 0, p5 = 0;
          if ((i2 = 0.5 * (f2 = Math.sqrt(M5 * M5 + g2 * g2))) > 1) return null;
          switch (i2 = 2 * Math.asin(i2), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (p5 = Math.sin(i2), d2 = Math.cos(i2)), this.mode) {
            case this.EQUIT:
              i2 = Math.abs(f2) <= h ? 0 : Math.asin(g2 * p5 / f2), M5 *= p5, g2 = d2 * f2;
              break;
            case this.OBLIQ:
              i2 = Math.abs(f2) <= h ? this.lat0 : Math.asin(d2 * this.sinph0 + g2 * p5 * this.cosph0 / f2), M5 *= p5 * this.cosph0, g2 = (d2 - Math.sin(i2) * this.sinph0) * f2;
              break;
            case this.N_POLE:
              g2 = -g2, i2 = a - i2;
              break;
            case this.S_POLE:
              i2 -= a;
          }
          s2 = 0 !== g2 || this.mode !== this.EQUIT && this.mode !== this.OBLIQ ? Math.atan2(M5, g2) : 0;
        } else {
          if (l2 = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
            if (M5 /= this.dd, g2 *= this.dd, (o2 = Math.sqrt(M5 * M5 + g2 * g2)) < h) return t2.x = this.long0, t2.y = this.lat0, t2;
            n2 = 2 * Math.asin(0.5 * o2 / this.rq), e2 = Math.cos(n2), M5 *= n2 = Math.sin(n2), this.mode === this.OBLIQ ? (l2 = e2 * this.sinb1 + g2 * n2 * this.cosb1 / o2, r2 = this.qp * l2, g2 = o2 * this.cosb1 * e2 - g2 * this.sinb1 * n2) : (l2 = g2 * n2 / o2, r2 = this.qp * l2, g2 = o2 * e2);
          } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
            if (this.mode === this.N_POLE && (g2 = -g2), !(r2 = M5 * M5 + g2 * g2)) return t2.x = this.long0, t2.y = this.lat0, t2;
            l2 = 1 - r2 / this.qp, this.mode === this.S_POLE && (l2 = -l2);
          }
          s2 = Math.atan2(M5, g2), c2 = Math.asin(l2), _2 = this.apa, u2 = c2 + c2, i2 = c2 + _2[0] * Math.sin(u2) + _2[1] * Math.sin(u2 + u2) + _2[2] * Math.sin(u2 + u2 + u2);
        }
        return t2.x = z(this.long0 + s2), t2.y = i2, t2;
      }, names: ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"], S_POLE: 1, N_POLE: 2, EQUIT: 3, OBLIQ: 4 };
      function Os(t2) {
        return Math.abs(t2) > 1 && (t2 = t2 > 1 ? 1 : -1), Math.asin(t2);
      }
      var Rs = { init: function() {
        Math.abs(this.lat1 + this.lat2) < h || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = F(this.e3, this.sin_po, this.cos_po), this.qs1 = xs(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = F(this.e3, this.sin_po, this.cos_po), this.qs2 = xs(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = xs(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > h ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
      }, forward: function(t2) {
        var s2 = t2.x, i2 = t2.y;
        this.sin_phi = Math.sin(i2), this.cos_phi = Math.cos(i2);
        var a3 = xs(this.e3, this.sin_phi), h2 = this.a * Math.sqrt(this.c - this.ns0 * a3) / this.ns0, e2 = this.ns0 * z(s2 - this.long0), n2 = h2 * Math.sin(e2) + this.x0, r2 = this.rh - h2 * Math.cos(e2) + this.y0;
        return t2.x = n2, t2.y = r2, t2;
      }, inverse: function(t2) {
        var s2, i2, a3, h2, e2, n2;
        return t2.x -= this.x0, t2.y = this.rh - t2.y + this.y0, this.ns0 >= 0 ? (s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), a3 = 1) : (s2 = -Math.sqrt(t2.x * t2.x + t2.y * t2.y), a3 = -1), h2 = 0, 0 !== s2 && (h2 = Math.atan2(a3 * t2.x, a3 * t2.y)), a3 = s2 * this.ns0 / this.a, this.sphere ? n2 = Math.asin((this.c - a3 * a3) / (2 * this.ns0)) : (i2 = (this.c - a3 * a3) / this.ns0, n2 = this.phi1z(this.e3, i2)), e2 = z(h2 / this.ns0 + this.long0), t2.x = e2, t2.y = n2, t2;
      }, names: ["Albers_Conic_Equal_Area", "Albers_Equal_Area", "Albers", "aea"], phi1z: function(t2, s2) {
        var i2, a3, e2, n2, r2 = Os(0.5 * s2);
        if (t2 < h) return r2;
        for (var o2 = t2 * t2, l2 = 1; l2 <= 25; l2++) if (r2 += n2 = 0.5 * (e2 = 1 - (a3 = t2 * (i2 = Math.sin(r2))) * a3) * e2 / Math.cos(r2) * (s2 / (1 - o2) - i2 / e2 + 0.5 / t2 * Math.log((1 - a3) / (1 + a3))), Math.abs(n2) <= 1e-7) return r2;
        return null;
      } };
      var qs = { init: function() {
        this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
      }, forward: function(t2) {
        var s2, i2, a3, e2, n2, r2, o2, l2 = t2.x, c2 = t2.y;
        return a3 = z(l2 - this.long0), s2 = Math.sin(c2), i2 = Math.cos(c2), e2 = Math.cos(a3), (n2 = this.sin_p14 * s2 + this.cos_p14 * i2 * e2) > 0 || Math.abs(n2) <= h ? (r2 = this.x0 + 1 * this.a * i2 * Math.sin(a3) / n2, o2 = this.y0 + 1 * this.a * (this.cos_p14 * s2 - this.sin_p14 * i2 * e2) / n2) : (r2 = this.x0 + this.infinity_dist * i2 * Math.sin(a3), o2 = this.y0 + this.infinity_dist * (this.cos_p14 * s2 - this.sin_p14 * i2 * e2)), t2.x = r2, t2.y = o2, t2;
      }, inverse: function(t2) {
        var s2, i2, a3, h2, e2, n2;
        return t2.x = (t2.x - this.x0) / this.a, t2.y = (t2.y - this.y0) / this.a, t2.x /= this.k0, t2.y /= this.k0, (s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y)) ? (h2 = Math.atan2(s2, this.rc), i2 = Math.sin(h2), n2 = Os((a3 = Math.cos(h2)) * this.sin_p14 + t2.y * i2 * this.cos_p14 / s2), e2 = Math.atan2(t2.x * i2, s2 * this.cos_p14 * a3 - t2.y * this.sin_p14 * i2), e2 = z(this.long0 + e2)) : (n2 = this.phic0, e2 = 0), t2.x = e2, t2.y = n2, t2;
      }, names: ["gnom"] };
      var Ts = { init: function() {
        this.sphere || (this.k0 = F(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
      }, forward: function(t2) {
        var s2, i2, a3 = t2.x, h2 = t2.y, e2 = z(a3 - this.long0);
        if (this.sphere) s2 = this.x0 + this.a * e2 * Math.cos(this.lat_ts), i2 = this.y0 + this.a * Math.sin(h2) / Math.cos(this.lat_ts);
        else {
          var n2 = xs(this.e, Math.sin(h2));
          s2 = this.x0 + this.a * this.k0 * e2, i2 = this.y0 + this.a * n2 * 0.5 / this.k0;
        }
        return t2.x = s2, t2.y = i2, t2;
      }, inverse: function(t2) {
        var s2, i2;
        return t2.x -= this.x0, t2.y -= this.y0, this.sphere ? (s2 = z(this.long0 + t2.x / this.a / Math.cos(this.lat_ts)), i2 = Math.asin(t2.y / this.a * Math.cos(this.lat_ts))) : (i2 = function(t3, s3) {
          var i3 = 1 - (1 - t3 * t3) / (2 * t3) * Math.log((1 - t3) / (1 + t3));
          if (Math.abs(Math.abs(s3) - i3) < 1e-6) return s3 < 0 ? -1 * a : a;
          for (var h2, e2, n2, r2, o2 = Math.asin(0.5 * s3), l2 = 0; l2 < 30; l2++) if (e2 = Math.sin(o2), n2 = Math.cos(o2), r2 = t3 * e2, o2 += h2 = Math.pow(1 - r2 * r2, 2) / (2 * n2) * (s3 / (1 - t3 * t3) - e2 / (1 - r2 * r2) + 0.5 / t3 * Math.log((1 - r2) / (1 + r2))), Math.abs(h2) <= 1e-10) return o2;
          return NaN;
        }(this.e, 2 * t2.y * this.k0 / this.a), s2 = z(this.long0 + t2.x / (this.a * this.k0))), t2.x = s2, t2.y = i2, t2;
      }, names: ["cea"] };
      var ks = { init: function() {
        this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
      }, forward: function(t2) {
        var s2 = t2.x, i2 = t2.y, a3 = z(s2 - this.long0), h2 = ws(i2 - this.lat0);
        return t2.x = this.x0 + this.a * a3 * this.rc, t2.y = this.y0 + this.a * h2, t2;
      }, inverse: function(t2) {
        var s2 = t2.x, i2 = t2.y;
        return t2.x = z(this.long0 + (s2 - this.x0) / (this.a * this.rc)), t2.y = ws(this.lat0 + (i2 - this.y0) / this.a), t2;
      }, names: ["Equirectangular", "Equidistant_Cylindrical", "Equidistant_Cylindrical_Spherical", "eqc"] };
      var Ds = { init: function() {
        this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = ps(this.es), this.e1 = ms(this.es), this.e2 = ys(this.es), this.e3 = Ss(this.es), this.ml0 = this.a * ds(this.e0, this.e1, this.e2, this.e3, this.lat0);
      }, forward: function(t2) {
        var s2, i2, a3, e2 = t2.x, n2 = t2.y, r2 = z(e2 - this.long0);
        if (a3 = r2 * Math.sin(n2), this.sphere) Math.abs(n2) <= h ? (s2 = this.a * r2, i2 = -1 * this.a * this.lat0) : (s2 = this.a * Math.sin(a3) / Math.tan(n2), i2 = this.a * (ws(n2 - this.lat0) + (1 - Math.cos(a3)) / Math.tan(n2)));
        else if (Math.abs(n2) <= h) s2 = this.a * r2, i2 = -1 * this.ml0;
        else {
          var o2 = Es(this.a, this.e, Math.sin(n2)) / Math.tan(n2);
          s2 = o2 * Math.sin(a3), i2 = this.a * ds(this.e0, this.e1, this.e2, this.e3, n2) - this.ml0 + o2 * (1 - Math.cos(a3));
        }
        return t2.x = s2 + this.x0, t2.y = i2 + this.y0, t2;
      }, inverse: function(t2) {
        var s2, i2, a3, e2, n2, r2, o2, l2, c2;
        if (a3 = t2.x - this.x0, e2 = t2.y - this.y0, this.sphere) if (Math.abs(e2 + this.a * this.lat0) <= h) s2 = z(a3 / this.a + this.long0), i2 = 0;
        else {
          var _2;
          for (r2 = this.lat0 + e2 / this.a, o2 = a3 * a3 / this.a / this.a + r2 * r2, l2 = r2, n2 = 20; n2; --n2) if (l2 += c2 = -1 * (r2 * (l2 * (_2 = Math.tan(l2)) + 1) - l2 - 0.5 * (l2 * l2 + o2) * _2) / ((l2 - r2) / _2 - 1), Math.abs(c2) <= h) {
            i2 = l2;
            break;
          }
          s2 = z(this.long0 + Math.asin(a3 * Math.tan(l2) / this.a) / Math.sin(i2));
        }
        else if (Math.abs(e2 + this.ml0) <= h) i2 = 0, s2 = z(this.long0 + a3 / this.a);
        else {
          var u2, M5, g2, f2, d2;
          for (r2 = (this.ml0 + e2) / this.a, o2 = a3 * a3 / this.a / this.a + r2 * r2, l2 = r2, n2 = 20; n2; --n2) if (d2 = this.e * Math.sin(l2), u2 = Math.sqrt(1 - d2 * d2) * Math.tan(l2), M5 = this.a * ds(this.e0, this.e1, this.e2, this.e3, l2), g2 = this.e0 - 2 * this.e1 * Math.cos(2 * l2) + 4 * this.e2 * Math.cos(4 * l2) - 6 * this.e3 * Math.cos(6 * l2), l2 -= c2 = (r2 * (u2 * (f2 = M5 / this.a) + 1) - f2 - 0.5 * u2 * (f2 * f2 + o2)) / (this.es * Math.sin(2 * l2) * (f2 * f2 + o2 - 2 * r2 * f2) / (4 * u2) + (r2 - f2) * (u2 * g2 - 2 / Math.sin(2 * l2)) - g2), Math.abs(c2) <= h) {
            i2 = l2;
            break;
          }
          u2 = Math.sqrt(1 - this.es * Math.pow(Math.sin(i2), 2)) * Math.tan(i2), s2 = z(this.long0 + Math.asin(a3 * u2 / this.a) / Math.sin(i2));
        }
        return t2.x = s2, t2.y = i2, t2;
      }, names: ["Polyconic", "American_Polyconic", "poly"] };
      var js = { init: function() {
        this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
      }, forward: function(t2) {
        var s2, a3 = t2.x, h2 = t2.y - this.lat0, e2 = a3 - this.long0, n2 = h2 / i * 1e-5, r2 = e2, o2 = 1, l2 = 0;
        for (s2 = 1; s2 <= 10; s2++) o2 *= n2, l2 += this.A[s2] * o2;
        var c2, _2 = l2, u2 = r2, M5 = 1, g2 = 0, f2 = 0, d2 = 0;
        for (s2 = 1; s2 <= 6; s2++) c2 = g2 * _2 + M5 * u2, M5 = M5 * _2 - g2 * u2, g2 = c2, f2 = f2 + this.B_re[s2] * M5 - this.B_im[s2] * g2, d2 = d2 + this.B_im[s2] * M5 + this.B_re[s2] * g2;
        return t2.x = d2 * this.a + this.x0, t2.y = f2 * this.a + this.y0, t2;
      }, inverse: function(t2) {
        var s2, a3, h2 = t2.x, e2 = t2.y, n2 = h2 - this.x0, r2 = (e2 - this.y0) / this.a, o2 = n2 / this.a, l2 = 1, c2 = 0, _2 = 0, u2 = 0;
        for (s2 = 1; s2 <= 6; s2++) a3 = c2 * r2 + l2 * o2, l2 = l2 * r2 - c2 * o2, c2 = a3, _2 = _2 + this.C_re[s2] * l2 - this.C_im[s2] * c2, u2 = u2 + this.C_im[s2] * l2 + this.C_re[s2] * c2;
        for (var M5 = 0; M5 < this.iterations; M5++) {
          var g2, f2 = _2, d2 = u2, p5 = r2, m2 = o2;
          for (s2 = 2; s2 <= 6; s2++) g2 = d2 * _2 + f2 * u2, f2 = f2 * _2 - d2 * u2, d2 = g2, p5 += (s2 - 1) * (this.B_re[s2] * f2 - this.B_im[s2] * d2), m2 += (s2 - 1) * (this.B_im[s2] * f2 + this.B_re[s2] * d2);
          f2 = 1, d2 = 0;
          var y2 = this.B_re[1], S2 = this.B_im[1];
          for (s2 = 2; s2 <= 6; s2++) g2 = d2 * _2 + f2 * u2, f2 = f2 * _2 - d2 * u2, d2 = g2, y2 += s2 * (this.B_re[s2] * f2 - this.B_im[s2] * d2), S2 += s2 * (this.B_im[s2] * f2 + this.B_re[s2] * d2);
          var E5 = y2 * y2 + S2 * S2;
          _2 = (p5 * y2 + m2 * S2) / E5, u2 = (m2 * y2 - p5 * S2) / E5;
        }
        var w2 = _2, v2 = u2, G2 = 1, x2 = 0;
        for (s2 = 1; s2 <= 9; s2++) G2 *= w2, x2 += this.D[s2] * G2;
        var P6 = this.lat0 + x2 * i * 1e5, b3 = this.long0 + v2;
        return t2.x = b3, t2.y = P6, t2;
      }, names: ["New_Zealand_Map_Grid", "nzmg"] };
      var Us = { init: function() {
      }, forward: function(t2) {
        var s2 = t2.x, i2 = t2.y, a3 = z(s2 - this.long0), h2 = this.x0 + this.a * a3, e2 = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + i2 / 2.5)) * 1.25;
        return t2.x = h2, t2.y = e2, t2;
      }, inverse: function(t2) {
        t2.x -= this.x0, t2.y -= this.y0;
        var s2 = z(this.long0 + t2.x / this.a), i2 = 2.5 * (Math.atan(Math.exp(0.8 * t2.y / this.a)) - Math.PI / 4);
        return t2.x = s2, t2.y = i2, t2;
      }, names: ["Miller_Cylindrical", "mill"] };
      var Fs = { init: function() {
        this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = Jt(this.es);
      }, forward: function(t2) {
        var s2, i2, a3 = t2.x, e2 = t2.y;
        if (a3 = z(a3 - this.long0), this.sphere) {
          if (this.m) for (var n2 = this.n * Math.sin(e2), r2 = 20; r2; --r2) {
            var o2 = (this.m * e2 + Math.sin(e2) - n2) / (this.m + Math.cos(e2));
            if (e2 -= o2, Math.abs(o2) < h) break;
          }
          else e2 = 1 !== this.n ? Math.asin(this.n * Math.sin(e2)) : e2;
          s2 = this.a * this.C_x * a3 * (this.m + Math.cos(e2)), i2 = this.a * this.C_y * e2;
        } else {
          var l2 = Math.sin(e2), c2 = Math.cos(e2);
          i2 = this.a * Zt(e2, l2, c2, this.en), s2 = this.a * a3 * c2 / Math.sqrt(1 - this.es * l2 * l2);
        }
        return t2.x = s2, t2.y = i2, t2;
      }, inverse: function(t2) {
        var s2, i2, e2;
        return t2.x -= this.x0, i2 = t2.x / this.a, t2.y -= this.y0, s2 = t2.y / this.a, this.sphere ? (s2 /= this.C_y, i2 /= this.C_x * (this.m + Math.cos(s2)), this.m ? s2 = Os((this.m * s2 + Math.sin(s2)) / this.n) : 1 !== this.n && (s2 = Os(Math.sin(s2) / this.n)), i2 = z(i2 + this.long0), s2 = ws(s2)) : (s2 = Yt(t2.y / this.a, this.es, this.en), (e2 = Math.abs(s2)) < a ? (e2 = Math.sin(s2), i2 = z(this.long0 + t2.x * Math.sqrt(1 - this.es * e2 * e2) / (this.a * Math.cos(s2)))) : e2 - h < a && (i2 = this.long0)), t2.x = i2, t2.y = s2, t2;
      }, names: ["Sinusoidal", "sinu"] };
      var Bs = { init: function() {
      }, forward: function(t2) {
        for (var s2 = t2.x, i2 = t2.y, a3 = z(s2 - this.long0), e2 = i2, n2 = Math.PI * Math.sin(i2); ; ) {
          var r2 = -(e2 + Math.sin(e2) - n2) / (1 + Math.cos(e2));
          if (e2 += r2, Math.abs(r2) < h) break;
        }
        e2 /= 2, Math.PI / 2 - Math.abs(i2) < h && (a3 = 0);
        var o2 = 0.900316316158 * this.a * a3 * Math.cos(e2) + this.x0, l2 = 1.4142135623731 * this.a * Math.sin(e2) + this.y0;
        return t2.x = o2, t2.y = l2, t2;
      }, inverse: function(t2) {
        var s2, i2;
        t2.x -= this.x0, t2.y -= this.y0, i2 = t2.y / (1.4142135623731 * this.a), Math.abs(i2) > 0.999999999999 && (i2 = 0.999999999999), s2 = Math.asin(i2);
        var a3 = z(this.long0 + t2.x / (0.900316316158 * this.a * Math.cos(s2)));
        a3 < -Math.PI && (a3 = -Math.PI), a3 > Math.PI && (a3 = Math.PI), i2 = (2 * s2 + Math.sin(2 * s2)) / Math.PI, Math.abs(i2) > 1 && (i2 = 1);
        var h2 = Math.asin(i2);
        return t2.x = a3, t2.y = h2, t2;
      }, names: ["Mollweide", "moll"] };
      var zs = { init: function() {
        Math.abs(this.lat1 + this.lat2) < h || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = ps(this.es), this.e1 = ms(this.es), this.e2 = ys(this.es), this.e3 = Ss(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = F(this.e, this.sinphi, this.cosphi), this.ml1 = ds(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < h ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = F(this.e, this.sinphi, this.cosphi), this.ml2 = ds(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = ds(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
      }, forward: function(t2) {
        var s2, i2 = t2.x, a3 = t2.y;
        if (this.sphere) s2 = this.a * (this.g - a3);
        else {
          var h2 = ds(this.e0, this.e1, this.e2, this.e3, a3);
          s2 = this.a * (this.g - h2);
        }
        var e2 = this.ns * z(i2 - this.long0), n2 = this.x0 + s2 * Math.sin(e2), r2 = this.y0 + this.rh - s2 * Math.cos(e2);
        return t2.x = n2, t2.y = r2, t2;
      }, inverse: function(t2) {
        var s2, i2, a3, h2;
        t2.x -= this.x0, t2.y = this.rh - t2.y + this.y0, this.ns >= 0 ? (i2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), s2 = 1) : (i2 = -Math.sqrt(t2.x * t2.x + t2.y * t2.y), s2 = -1);
        var e2 = 0;
        return 0 !== i2 && (e2 = Math.atan2(s2 * t2.x, s2 * t2.y)), this.sphere ? (h2 = z(this.long0 + e2 / this.ns), a3 = ws(this.g - i2 / this.a), t2.x = h2, t2.y = a3, t2) : (a3 = vs(this.g - i2 / this.a, this.e0, this.e1, this.e2, this.e3), h2 = z(this.long0 + e2 / this.ns), t2.x = h2, t2.y = a3, t2);
      }, names: ["Equidistant_Conic", "eqdc"] };
      var Hs, Ws = { init: function() {
        this.R = this.a;
      }, forward: function(t2) {
        var s2, i2, e2 = t2.x, n2 = t2.y, r2 = z(e2 - this.long0);
        Math.abs(n2) <= h && (s2 = this.x0 + this.R * r2, i2 = this.y0);
        var o2 = Os(2 * Math.abs(n2 / Math.PI));
        (Math.abs(r2) <= h || Math.abs(Math.abs(n2) - a) <= h) && (s2 = this.x0, i2 = n2 >= 0 ? this.y0 + Math.PI * this.R * Math.tan(0.5 * o2) : this.y0 + Math.PI * this.R * -Math.tan(0.5 * o2));
        var l2 = 0.5 * Math.abs(Math.PI / r2 - r2 / Math.PI), c2 = l2 * l2, _2 = Math.sin(o2), u2 = Math.cos(o2), M5 = u2 / (_2 + u2 - 1), g2 = M5 * M5, f2 = M5 * (2 / _2 - 1), d2 = f2 * f2, p5 = Math.PI * this.R * (l2 * (M5 - d2) + Math.sqrt(c2 * (M5 - d2) * (M5 - d2) - (d2 + c2) * (g2 - d2))) / (d2 + c2);
        r2 < 0 && (p5 = -p5), s2 = this.x0 + p5;
        var m2 = c2 + M5;
        return p5 = Math.PI * this.R * (f2 * m2 - l2 * Math.sqrt((d2 + c2) * (c2 + 1) - m2 * m2)) / (d2 + c2), i2 = n2 >= 0 ? this.y0 + p5 : this.y0 - p5, t2.x = s2, t2.y = i2, t2;
      }, inverse: function(t2) {
        var s2, i2, a3, e2, n2, r2, o2, l2, c2, _2, u2, M5;
        return t2.x -= this.x0, t2.y -= this.y0, u2 = Math.PI * this.R, n2 = (a3 = t2.x / u2) * a3 + (e2 = t2.y / u2) * e2, u2 = 3 * (e2 * e2 / (l2 = -2 * (r2 = -Math.abs(e2) * (1 + n2)) + 1 + 2 * e2 * e2 + n2 * n2) + (2 * (o2 = r2 - 2 * e2 * e2 + a3 * a3) * o2 * o2 / l2 / l2 / l2 - 9 * r2 * o2 / l2 / l2) / 27) / (c2 = (r2 - o2 * o2 / 3 / l2) / l2) / (_2 = 2 * Math.sqrt(-c2 / 3)), Math.abs(u2) > 1 && (u2 = u2 >= 0 ? 1 : -1), M5 = Math.acos(u2) / 3, i2 = t2.y >= 0 ? (-_2 * Math.cos(M5 + Math.PI / 3) - o2 / 3 / l2) * Math.PI : -(-_2 * Math.cos(M5 + Math.PI / 3) - o2 / 3 / l2) * Math.PI, s2 = Math.abs(a3) < h ? this.long0 : z(this.long0 + Math.PI * (n2 - 1 + Math.sqrt(1 + 2 * (a3 * a3 - e2 * e2) + n2 * n2)) / 2 / a3), t2.x = s2, t2.y = i2, t2;
      }, names: ["Van_der_Grinten_I", "VanDerGrinten", "Van_der_Grinten", "vandg"] }, Qs = { exports: {} };
      var Ks = (Hs || (Hs = 1, function(t2) {
        var s2, i2, a3, h2;
        (h2 = {}).Constants = {}, h2.Math = {}, h2.Accumulator = {}, (s2 = h2.Constants).WGS84 = { a: 6378137, f: 1 / 298.257223563 }, s2.version = { major: 2, minor: 1, patch: 1 }, s2.version_string = "2.1.1", (i2 = h2.Math).digits = 53, i2.epsilon = Math.pow(0.5, i2.digits - 1), i2.degree = Math.PI / 180, i2.sq = function(t3) {
          return t3 * t3;
        }, i2.hypot = function(t3, s3) {
          return Math.sqrt(t3 * t3 + s3 * s3);
        }, i2.cbrt = Math.cbrt || function(t3) {
          var s3 = Math.pow(Math.abs(t3), 1 / 3);
          return t3 > 0 ? s3 : t3 < 0 ? -s3 : t3;
        }, i2.log1p = Math.log1p || function(t3) {
          var s3 = 1 + t3, i3 = s3 - 1;
          return 0 === i3 ? t3 : t3 * Math.log(s3) / i3;
        }, i2.atanh = Math.atanh || function(t3) {
          var s3 = Math.abs(t3);
          return s3 = i2.log1p(2 * s3 / (1 - s3)) / 2, t3 > 0 ? s3 : t3 < 0 ? -s3 : t3;
        }, i2.copysign = function(t3, s3) {
          return Math.abs(t3) * (s3 < 0 || 0 === s3 && 1 / s3 < 0 ? -1 : 1);
        }, i2.sum = function(t3, s3) {
          var i3 = t3 + s3, a4 = i3 - s3, h3 = i3 - a4;
          return a4 -= t3, { s: i3, t: i3 ? 0 - (a4 + (h3 -= s3)) : i3 };
        }, i2.polyval = function(t3, s3, i3, a4) {
          for (var h3 = t3 < 0 ? 0 : s3[i3++]; --t3 >= 0; ) h3 = h3 * a4 + s3[i3++];
          return h3;
        }, i2.AngRound = function(t3) {
          var s3 = 1 / 16, a4 = Math.abs(t3);
          return a4 = a4 < s3 ? s3 - (s3 - a4) : a4, i2.copysign(a4, t3);
        }, i2.remainder = function(t3, s3) {
          return (t3 %= s3) < -s3 / 2 ? t3 + s3 : t3 < s3 / 2 ? t3 : t3 - s3;
        }, i2.AngNormalize = function(t3) {
          var s3 = i2.remainder(t3, 360);
          return 180 === Math.abs(s3) ? i2.copysign(180, t3) : s3;
        }, i2.LatFix = function(t3) {
          return Math.abs(t3) > 90 ? NaN : t3;
        }, i2.AngDiff = function(t3, s3) {
          var a4, h3, e2 = i2.sum(i2.remainder(-t3, 360), i2.remainder(s3, 360));
          return a4 = (e2 = i2.sum(i2.remainder(e2.s, 360), e2.t)).s, h3 = e2.t, 0 !== a4 && 180 !== Math.abs(a4) || (a4 = i2.copysign(a4, 0 === h3 ? s3 - t3 : -h3)), { d: a4, e: h3 };
        }, i2.sincosd = function(t3) {
          var s3, a4, h3, e2, n2, r2, o2;
          switch (s3 = t3 % 360, a4 = (s3 -= 90 * (h3 = Math.round(s3 / 90))) * this.degree, e2 = Math.sin(a4), n2 = Math.cos(a4), 45 === Math.abs(s3) ? (n2 = Math.sqrt(0.5), e2 = i2.copysign(n2, a4)) : 30 === Math.abs(s3) && (n2 = Math.sqrt(0.75), e2 = i2.copysign(0.5, a4)), 3 & h3) {
            case 0:
              r2 = e2, o2 = n2;
              break;
            case 1:
              r2 = n2, o2 = -e2;
              break;
            case 2:
              r2 = -e2, o2 = -n2;
              break;
            default:
              r2 = -n2, o2 = e2;
          }
          return o2 += 0, 0 === r2 && (r2 = i2.copysign(r2, t3)), { s: r2, c: o2 };
        }, i2.sincosde = function(t3, s3) {
          var a4, h3, e2, n2, r2, o2, l2;
          switch (a4 = t3 % 360, e2 = Math.round(a4 / 90), h3 = (a4 = i2.AngRound(a4 - 90 * e2 + s3)) * this.degree, n2 = Math.sin(h3), r2 = Math.cos(h3), 45 === Math.abs(a4) ? (r2 = Math.sqrt(0.5), n2 = i2.copysign(r2, h3)) : 30 === Math.abs(a4) && (r2 = Math.sqrt(0.75), n2 = i2.copysign(0.5, h3)), 3 & e2) {
            case 0:
              o2 = n2, l2 = r2;
              break;
            case 1:
              o2 = r2, l2 = -n2;
              break;
            case 2:
              o2 = -n2, l2 = -r2;
              break;
            default:
              o2 = -r2, l2 = n2;
          }
          return l2 += 0, 0 === o2 && (o2 = i2.copysign(o2, t3 + s3)), { s: o2, c: l2 };
        }, i2.atan2d = function(t3, s3) {
          var a4, h3 = 0;
          switch (Math.abs(t3) > Math.abs(s3) && ([t3, s3] = [s3, t3], h3 = 2), i2.copysign(1, s3) < 0 && (s3 = -s3, ++h3), a4 = Math.atan2(t3, s3) / this.degree, h3) {
            case 1:
              a4 = i2.copysign(180, t3) - a4;
              break;
            case 2:
              a4 = 90 - a4;
              break;
            case 3:
              a4 = -90 + a4;
          }
          return a4;
        }, function(t3, s3) {
          t3.Accumulator = function(t4) {
            this.Set(t4);
          }, t3.Accumulator.prototype.Set = function(s4) {
            s4 || (s4 = 0), s4.constructor === t3.Accumulator ? (this._s = s4._s, this._t = s4._t) : (this._s = s4, this._t = 0);
          }, t3.Accumulator.prototype.Add = function(t4) {
            var i3 = s3.sum(t4, this._t), a4 = s3.sum(i3.s, this._s);
            i3 = i3.t, this._s = a4.s, this._t = a4.t, 0 === this._s ? this._s = i3 : this._t += i3;
          }, t3.Accumulator.prototype.Sum = function(s4) {
            var i3;
            return s4 ? ((i3 = new t3.Accumulator(this)).Add(s4), i3._s) : this._s;
          }, t3.Accumulator.prototype.Negate = function() {
            this._s *= -1, this._t *= -1;
          }, t3.Accumulator.prototype.Remainder = function(t4) {
            this._s = s3.remainder(this._s, t4), this.Add(0);
          };
        }(h2.Accumulator, h2.Math), h2.Geodesic = {}, h2.GeodesicLine = {}, h2.PolygonArea = {}, function(t3, s3, i3, a4, h3) {
          var e2, n2, r2, o2, l2, c2, _2, u2, M5, g2, f2, d2 = 20 + a4.digits + 10, p5 = a4.epsilon, m2 = 200 * p5, y2 = Math.sqrt(p5), S2 = p5, E5 = 1e3 * y2;
          t3.tiny_ = Math.sqrt(Number.MIN_VALUE / Number.EPSILON), t3.nC1_ = 6, t3.nC1p_ = 6, t3.nC2_ = 6, t3.nC3_ = 6, t3.nC4_ = 6, e2 = t3.nC3_ * (t3.nC3_ - 1) / 2, n2 = t3.nC4_ * (t3.nC4_ + 1) / 2, t3.CAP_C1 = 1, t3.CAP_C1p = 2, t3.CAP_C2 = 4, t3.CAP_C3 = 8, t3.CAP_C4 = 16, t3.NONE = 0, t3.ARC = 64, t3.LATITUDE = 128, t3.LONGITUDE = 256 | t3.CAP_C3, t3.AZIMUTH = 512, t3.DISTANCE = 1024 | t3.CAP_C1, t3.STANDARD = t3.LATITUDE | t3.LONGITUDE | t3.AZIMUTH | t3.DISTANCE, t3.DISTANCE_IN = 2048 | t3.CAP_C1 | t3.CAP_C1p, t3.REDUCEDLENGTH = 4096 | t3.CAP_C1 | t3.CAP_C2, t3.GEODESICSCALE = 8192 | t3.CAP_C1 | t3.CAP_C2, t3.AREA = 16384 | t3.CAP_C4, t3.ALL = 32671, t3.LONG_UNROLL = 32768, t3.OUT_MASK = 32640 | t3.LONG_UNROLL, t3.SinCosSeries = function(t4, s4, i4, a5) {
            var h4 = a5.length, e3 = h4 - (t4 ? 1 : 0), n3 = 2 * (i4 - s4) * (i4 + s4), r3 = 1 & e3 ? a5[--h4] : 0, o3 = 0;
            for (e3 = Math.floor(e3 / 2); e3--; ) r3 = n3 * (o3 = n3 * r3 - o3 + a5[--h4]) - r3 + a5[--h4];
            return t4 ? 2 * s4 * i4 * r3 : i4 * (r3 - o3);
          }, r2 = function(t4, s4) {
            var i4, h4, e3, n3, r3, o3, l3, c3, _3, u3, M6, g3, f3 = a4.sq(t4), d3 = a4.sq(s4), p6 = (f3 + d3 - 1) / 6;
            return 0 === d3 && p6 <= 0 ? i4 = 0 : (o3 = p6, (r3 = (h4 = f3 * d3 / 4) * (h4 + 2 * (n3 = p6 * (e3 = a4.sq(p6))))) >= 0 ? (l3 = h4 + n3, l3 += l3 < 0 ? -Math.sqrt(r3) : Math.sqrt(r3), o3 += (c3 = a4.cbrt(l3)) + (0 !== c3 ? e3 / c3 : 0)) : (_3 = Math.atan2(Math.sqrt(-r3), -(h4 + n3)), o3 += 2 * p6 * Math.cos(_3 / 3)), u3 = Math.sqrt(a4.sq(o3) + d3), g3 = ((M6 = o3 < 0 ? d3 / (u3 - o3) : o3 + u3) - d3) / (2 * u3), i4 = M6 / (Math.sqrt(M6 + a4.sq(g3)) + g3)), i4;
          }, o2 = [1, 4, 64, 0, 256], t3.A1m1f = function(t4) {
            var s4 = Math.floor(3);
            return (a4.polyval(s4, o2, 0, a4.sq(t4)) / o2[s4 + 1] + t4) / (1 - t4);
          }, l2 = [-1, 6, -16, 32, -9, 64, -128, 2048, 9, -16, 768, 3, -5, 512, -7, 1280, -7, 2048], t3.C1f = function(s4, i4) {
            var h4, e3, n3 = a4.sq(s4), r3 = s4, o3 = 0;
            for (h4 = 1; h4 <= t3.nC1_; ++h4) e3 = Math.floor((t3.nC1_ - h4) / 2), i4[h4] = r3 * a4.polyval(e3, l2, o3, n3) / l2[o3 + e3 + 1], o3 += e3 + 2, r3 *= s4;
          }, c2 = [205, -432, 768, 1536, 4005, -4736, 3840, 12288, -225, 116, 384, -7173, 2695, 7680, 3467, 7680, 38081, 61440], t3.C1pf = function(s4, i4) {
            var h4, e3, n3 = a4.sq(s4), r3 = s4, o3 = 0;
            for (h4 = 1; h4 <= t3.nC1p_; ++h4) e3 = Math.floor((t3.nC1p_ - h4) / 2), i4[h4] = r3 * a4.polyval(e3, c2, o3, n3) / c2[o3 + e3 + 1], o3 += e3 + 2, r3 *= s4;
          }, _2 = [-11, -28, -192, 0, 256], t3.A2m1f = function(t4) {
            var s4 = Math.floor(3);
            return (a4.polyval(s4, _2, 0, a4.sq(t4)) / _2[s4 + 1] - t4) / (1 + t4);
          }, u2 = [1, 2, 16, 32, 35, 64, 384, 2048, 15, 80, 768, 7, 35, 512, 63, 1280, 77, 2048], t3.C2f = function(s4, i4) {
            var h4, e3, n3 = a4.sq(s4), r3 = s4, o3 = 0;
            for (h4 = 1; h4 <= t3.nC2_; ++h4) e3 = Math.floor((t3.nC2_ - h4) / 2), i4[h4] = r3 * a4.polyval(e3, u2, o3, n3) / u2[o3 + e3 + 1], o3 += e3 + 2, r3 *= s4;
          }, t3.Geodesic = function(t4, s4) {
            if (this.a = t4, this.f = s4, this._f1 = 1 - this.f, this._e2 = this.f * (2 - this.f), this._ep2 = this._e2 / a4.sq(this._f1), this._n = this.f / (2 - this.f), this._b = this.a * this._f1, this._c2 = (a4.sq(this.a) + a4.sq(this._b) * (0 === this._e2 ? 1 : (this._e2 > 0 ? a4.atanh(Math.sqrt(this._e2)) : Math.atan(Math.sqrt(-this._e2))) / Math.sqrt(Math.abs(this._e2)))) / 2, this._etol2 = 0.1 * y2 / Math.sqrt(Math.max(1e-3, Math.abs(this.f)) * Math.min(1, 1 - this.f / 2) / 2), !(isFinite(this.a) && this.a > 0)) throw new Error("Equatorial radius is not positive");
            if (!(isFinite(this._b) && this._b > 0)) throw new Error("Polar semi-axis is not positive");
            this._A3x = new Array(6), this._C3x = new Array(e2), this._C4x = new Array(n2), this.A3coeff(), this.C3coeff(), this.C4coeff();
          }, M5 = [-3, 128, -2, -3, 64, -1, -3, -1, 16, 3, -1, -2, 8, 1, -1, 2, 1, 1], t3.Geodesic.prototype.A3coeff = function() {
            var t4, s4, i4 = 0, h4 = 0;
            for (t4 = 5; t4 >= 0; --t4) s4 = Math.min(6 - t4 - 1, t4), this._A3x[h4++] = a4.polyval(s4, M5, i4, this._n) / M5[i4 + s4 + 1], i4 += s4 + 2;
          }, g2 = [3, 128, 2, 5, 128, -1, 3, 3, 64, -1, 0, 1, 8, -1, 1, 4, 5, 256, 1, 3, 128, -3, -2, 3, 64, 1, -3, 2, 32, 7, 512, -10, 9, 384, 5, -9, 5, 192, 7, 512, -14, 7, 512, 21, 2560], t3.Geodesic.prototype.C3coeff = function() {
            var s4, i4, h4, e3 = 0, n3 = 0;
            for (s4 = 1; s4 < t3.nC3_; ++s4) for (i4 = t3.nC3_ - 1; i4 >= s4; --i4) h4 = Math.min(t3.nC3_ - i4 - 1, i4), this._C3x[n3++] = a4.polyval(h4, g2, e3, this._n) / g2[e3 + h4 + 1], e3 += h4 + 2;
          }, f2 = [97, 15015, 1088, 156, 45045, -224, -4784, 1573, 45045, -10656, 14144, -4576, -858, 45045, 64, 624, -4576, 6864, -3003, 15015, 100, 208, 572, 3432, -12012, 30030, 45045, 1, 9009, -2944, 468, 135135, 5792, 1040, -1287, 135135, 5952, -11648, 9152, -2574, 135135, -64, -624, 4576, -6864, 3003, 135135, 8, 10725, 1856, -936, 225225, -8448, 4992, -1144, 225225, -1440, 4160, -4576, 1716, 225225, -136, 63063, 1024, -208, 105105, 3584, -3328, 1144, 315315, -128, 135135, -2560, 832, 405405, 128, 99099], t3.Geodesic.prototype.C4coeff = function() {
            var s4, i4, h4, e3 = 0, n3 = 0;
            for (s4 = 0; s4 < t3.nC4_; ++s4) for (i4 = t3.nC4_ - 1; i4 >= s4; --i4) h4 = t3.nC4_ - i4 - 1, this._C4x[n3++] = a4.polyval(h4, f2, e3, this._n) / f2[e3 + h4 + 1], e3 += h4 + 2;
          }, t3.Geodesic.prototype.A3f = function(t4) {
            return a4.polyval(5, this._A3x, 0, t4);
          }, t3.Geodesic.prototype.C3f = function(s4, i4) {
            var h4, e3, n3 = 1, r3 = 0;
            for (h4 = 1; h4 < t3.nC3_; ++h4) e3 = t3.nC3_ - h4 - 1, n3 *= s4, i4[h4] = n3 * a4.polyval(e3, this._C3x, r3, s4), r3 += e3 + 1;
          }, t3.Geodesic.prototype.C4f = function(s4, i4) {
            var h4, e3, n3 = 1, r3 = 0;
            for (h4 = 0; h4 < t3.nC4_; ++h4) e3 = t3.nC4_ - h4 - 1, i4[h4] = n3 * a4.polyval(e3, this._C4x, r3, s4), r3 += e3 + 1, n3 *= s4;
          }, t3.Geodesic.prototype.Lengths = function(s4, i4, a5, h4, e3, n3, r3, o3, l3, c3, _3, u3, M6) {
            var g3, f3, d3, p6, m3 = {}, y3 = 0, S3 = 0, E6 = 0, w2 = 0;
            if ((_3 &= t3.OUT_MASK) & (t3.DISTANCE | t3.REDUCEDLENGTH | t3.GEODESICSCALE) && (E6 = t3.A1m1f(s4), t3.C1f(s4, u3), _3 & (t3.REDUCEDLENGTH | t3.GEODESICSCALE) && (w2 = t3.A2m1f(s4), t3.C2f(s4, M6), y3 = E6 - w2, w2 = 1 + w2), E6 = 1 + E6), _3 & t3.DISTANCE) g3 = t3.SinCosSeries(true, n3, r3, u3) - t3.SinCosSeries(true, a5, h4, u3), m3.s12b = E6 * (i4 + g3), _3 & (t3.REDUCEDLENGTH | t3.GEODESICSCALE) && (S3 = y3 * i4 + (E6 * g3 - w2 * (t3.SinCosSeries(true, n3, r3, M6) - t3.SinCosSeries(true, a5, h4, M6))));
            else if (_3 & (t3.REDUCEDLENGTH | t3.GEODESICSCALE)) {
              for (f3 = 1; f3 <= t3.nC2_; ++f3) M6[f3] = E6 * u3[f3] - w2 * M6[f3];
              S3 = y3 * i4 + (t3.SinCosSeries(true, n3, r3, M6) - t3.SinCosSeries(true, a5, h4, M6));
            }
            return _3 & t3.REDUCEDLENGTH && (m3.m0 = y3, m3.m12b = o3 * (h4 * n3) - e3 * (a5 * r3) - h4 * r3 * S3), _3 & t3.GEODESICSCALE && (d3 = h4 * r3 + a5 * n3, p6 = this._ep2 * (l3 - c3) * (l3 + c3) / (e3 + o3), m3.M12 = d3 + (p6 * n3 - r3 * S3) * a5 / e3, m3.M21 = d3 - (p6 * a5 - h4 * S3) * n3 / o3), m3;
          }, t3.Geodesic.prototype.InverseStart = function(s4, i4, h4, e3, n3, o3, l3, c3, _3, u3, M6) {
            var g3, f3, d3, p6, y3, S3, w2, v2, G2, x2, P6, b3, A2, C2, N2, I2, L2, O2, R3, q2, T2 = {}, k2 = e3 * i4 - n3 * s4, D2 = n3 * i4 + e3 * s4;
            return T2.sig12 = -1, g3 = e3 * i4, g3 += n3 * s4, (f3 = D2 >= 0 && k2 < 0.5 && n3 * l3 < 0.5) ? (p6 = a4.sq(s4 + e3), p6 /= p6 + a4.sq(i4 + n3), T2.dnm = Math.sqrt(1 + this._ep2 * p6), d3 = l3 / (this._f1 * T2.dnm), y3 = Math.sin(d3), S3 = Math.cos(d3)) : (y3 = c3, S3 = _3), T2.salp1 = n3 * y3, T2.calp1 = S3 >= 0 ? k2 + n3 * s4 * a4.sq(y3) / (1 + S3) : g3 - n3 * s4 * a4.sq(y3) / (1 - S3), v2 = a4.hypot(T2.salp1, T2.calp1), G2 = s4 * e3 + i4 * n3 * S3, f3 && v2 < this._etol2 ? (T2.salp2 = i4 * y3, T2.calp2 = k2 - i4 * e3 * (S3 >= 0 ? a4.sq(y3) / (1 + S3) : 1 - S3), w2 = a4.hypot(T2.salp2, T2.calp2), T2.salp2 /= w2, T2.calp2 /= w2, T2.sig12 = Math.atan2(v2, G2)) : Math.abs(this._n) > 0.1 || G2 >= 0 || v2 >= 6 * Math.abs(this._n) * Math.PI * a4.sq(i4) || (q2 = Math.atan2(-c3, -_3), this.f >= 0 ? (C2 = (A2 = a4.sq(s4) * this._ep2) / (2 * (1 + Math.sqrt(1 + A2)) + A2), x2 = q2 / (b3 = this.f * i4 * this.A3f(C2) * Math.PI), P6 = g3 / (b3 * i4)) : (N2 = n3 * i4 - e3 * s4, I2 = Math.atan2(g3, N2), P6 = l3 / (b3 = ((x2 = (L2 = this.Lengths(this._n, Math.PI + I2, s4, -i4, h4, e3, n3, o3, i4, n3, t3.REDUCEDLENGTH, u3, M6)).m12b / (i4 * n3 * L2.m0 * Math.PI) - 1) < -0.01 ? g3 / x2 : -this.f * a4.sq(i4) * Math.PI) / i4)), P6 > -m2 && x2 > -1 - E5 ? this.f >= 0 ? (T2.salp1 = Math.min(1, -x2), T2.calp1 = -Math.sqrt(1 - a4.sq(T2.salp1))) : (T2.calp1 = Math.max(x2 > -m2 ? 0 : -1, x2), T2.salp1 = Math.sqrt(1 - a4.sq(T2.calp1))) : (O2 = r2(x2, P6), R3 = b3 * (this.f >= 0 ? -x2 * O2 / (1 + O2) : -P6 * (1 + O2) / O2), y3 = Math.sin(R3), S3 = -Math.cos(R3), T2.salp1 = n3 * y3, T2.calp1 = g3 - n3 * s4 * a4.sq(y3) / (1 - S3))), T2.salp1 <= 0 ? (T2.salp1 = 1, T2.calp1 = 0) : (w2 = a4.hypot(T2.salp1, T2.calp1), T2.salp1 /= w2, T2.calp1 /= w2), T2;
          }, t3.Geodesic.prototype.Lambda12 = function(s4, i4, h4, e3, n3, r3, o3, l3, c3, _3, u3, M6, g3, f3) {
            var d3, p6, m3, y3, S3, E6, w2, v2, G2, x2, P6, b3, A2, C2 = {};
            return 0 === s4 && 0 === l3 && (l3 = -t3.tiny_), p6 = o3 * i4, m3 = a4.hypot(l3, o3 * s4), C2.ssig1 = s4, y3 = p6 * s4, C2.csig1 = S3 = l3 * i4, d3 = a4.hypot(C2.ssig1, C2.csig1), C2.ssig1 /= d3, C2.csig1 /= d3, C2.salp2 = n3 !== i4 ? p6 / n3 : o3, C2.calp2 = n3 !== i4 || Math.abs(e3) !== -s4 ? Math.sqrt(a4.sq(l3 * i4) + (i4 < -s4 ? (n3 - i4) * (i4 + n3) : (s4 - e3) * (s4 + e3))) / n3 : Math.abs(l3), C2.ssig2 = e3, E6 = p6 * e3, C2.csig2 = w2 = C2.calp2 * n3, d3 = a4.hypot(C2.ssig2, C2.csig2), C2.ssig2 /= d3, C2.csig2 /= d3, C2.sig12 = Math.atan2(Math.max(0, C2.csig1 * C2.ssig2 - C2.ssig1 * C2.csig2), C2.csig1 * C2.csig2 + C2.ssig1 * C2.ssig2), v2 = Math.max(0, S3 * E6 - y3 * w2), G2 = S3 * w2 + y3 * E6, P6 = Math.atan2(v2 * _3 - G2 * c3, G2 * _3 + v2 * c3), b3 = a4.sq(m3) * this._ep2, C2.eps = b3 / (2 * (1 + Math.sqrt(1 + b3)) + b3), this.C3f(C2.eps, f3), x2 = t3.SinCosSeries(true, C2.ssig2, C2.csig2, f3) - t3.SinCosSeries(true, C2.ssig1, C2.csig1, f3), C2.domg12 = -this.f * this.A3f(C2.eps) * p6 * (C2.sig12 + x2), C2.lam12 = P6 + C2.domg12, u3 && (0 === C2.calp2 ? C2.dlam12 = -2 * this._f1 * h4 / s4 : (A2 = this.Lengths(C2.eps, C2.sig12, C2.ssig1, C2.csig1, h4, C2.ssig2, C2.csig2, r3, i4, n3, t3.REDUCEDLENGTH, M6, g3), C2.dlam12 = A2.m12b, C2.dlam12 *= this._f1 / (C2.calp2 * n3))), C2;
          }, t3.Geodesic.prototype.Inverse = function(s4, i4, h4, e3, n3) {
            var r3, o3;
            return n3 || (n3 = t3.STANDARD), n3 === t3.LONG_UNROLL && (n3 |= t3.STANDARD), n3 &= t3.OUT_MASK, o3 = (r3 = this.InverseInt(s4, i4, h4, e3, n3)).vals, n3 & t3.AZIMUTH && (o3.azi1 = a4.atan2d(r3.salp1, r3.calp1), o3.azi2 = a4.atan2d(r3.salp2, r3.calp2)), o3;
          }, t3.Geodesic.prototype.InverseInt = function(s4, i4, h4, e3, n3) {
            var r3, o3, l3, c3, _3, u3, M6, g3, f3, m3, y3, E6, w2, v2, G2, x2, P6, b3, A2, C2, N2, I2, L2, O2, R3, q2, T2, k2, D2, j2, U2, F2, B2, z2, H2, W2, Q2, K2, X2, V2, J2, Z2, Y2, $2, tt2, st2, it2, at2, ht2, et2, nt2, rt2, ot2, lt2, ct2, _t2, ut2, Mt2, gt2, ft2, dt2, pt2, mt2, yt2, St2, Et2 = {};
            if (Et2.lat1 = s4 = a4.LatFix(s4), Et2.lat2 = h4 = a4.LatFix(h4), s4 = a4.AngRound(s4), h4 = a4.AngRound(h4), o3 = (r3 = a4.AngDiff(i4, e3)).e, r3 = r3.d, n3 & t3.LONG_UNROLL ? (Et2.lon1 = i4, Et2.lon2 = i4 + r3 + o3) : (Et2.lon1 = a4.AngNormalize(i4), Et2.lon2 = a4.AngNormalize(e3)), o3 *= l3 = a4.copysign(1, r3), G2 = (r3 *= l3) * a4.degree, x2 = (c3 = a4.sincosde(r3, o3)).s, P6 = c3.c, o3 = 180 - r3 - o3, (_3 = Math.abs(s4) < Math.abs(h4) || isNaN(h4) ? -1 : 1) < 0 && (l3 *= -1, [h4, s4] = [s4, h4]), s4 *= u3 = a4.copysign(1, -s4), h4 *= u3, c3 = a4.sincosd(s4), M6 = this._f1 * c3.s, g3 = c3.c, M6 /= c3 = a4.hypot(M6, g3), g3 /= c3, g3 = Math.max(t3.tiny_, g3), c3 = a4.sincosd(h4), f3 = this._f1 * c3.s, m3 = c3.c, f3 /= c3 = a4.hypot(f3, m3), m3 /= c3, m3 = Math.max(t3.tiny_, m3), g3 < -M6 ? m3 === g3 && (f3 = a4.copysign(M6, f3)) : Math.abs(f3) === -M6 && (m3 = g3), w2 = Math.sqrt(1 + this._ep2 * a4.sq(M6)), v2 = Math.sqrt(1 + this._ep2 * a4.sq(f3)), L2 = new Array(t3.nC1_ + 1), O2 = new Array(t3.nC2_ + 1), R3 = new Array(t3.nC3_), (q2 = -90 === s4 || 0 === x2) && (C2 = x2, I2 = 0, k2 = M6, D2 = (A2 = P6) * g3, j2 = f3, U2 = (N2 = 1) * m3, b3 = Math.atan2(Math.max(0, D2 * j2 - k2 * U2), D2 * U2 + k2 * j2), y3 = (T2 = this.Lengths(this._n, b3, k2, D2, w2, j2, U2, v2, g3, m3, n3 | t3.DISTANCE | t3.REDUCEDLENGTH, L2, O2)).s12b, E6 = T2.m12b, n3 & t3.GEODESICSCALE && (Et2.M12 = T2.M12, Et2.M21 = T2.M21), b3 < 1 || E6 >= 0 ? ((b3 < 3 * t3.tiny_ || b3 < p5 && (y3 < 0 || E6 < 0)) && (b3 = E6 = y3 = 0), E6 *= this._b, y3 *= this._b, Et2.a12 = b3 / a4.degree) : q2 = false), ut2 = 2, !q2 && 0 === M6 && (this.f <= 0 || o3 >= 180 * this.f)) A2 = N2 = 0, C2 = I2 = 1, y3 = this.a * G2, b3 = B2 = G2 / this._f1, E6 = this._b * Math.sin(b3), n3 & t3.GEODESICSCALE && (Et2.M12 = Et2.M21 = Math.cos(b3)), Et2.a12 = r3 / this._f1;
            else if (!q2) if (b3 = (T2 = this.InverseStart(M6, g3, w2, f3, m3, v2, G2, x2, P6, L2, O2)).sig12, C2 = T2.salp1, A2 = T2.calp1, b3 >= 0) I2 = T2.salp2, N2 = T2.calp2, z2 = T2.dnm, y3 = b3 * this._b * z2, E6 = a4.sq(z2) * this._b * Math.sin(b3 / z2), n3 & t3.GEODESICSCALE && (Et2.M12 = Et2.M21 = Math.cos(b3 / z2)), Et2.a12 = b3 / a4.degree, B2 = G2 / (this._f1 * z2);
            else {
              for (H2 = 0, W2 = t3.tiny_, Q2 = 1, K2 = t3.tiny_, X2 = -1, V2 = false, J2 = false; Z2 = (T2 = this.Lambda12(M6, g3, w2, f3, m3, v2, C2, A2, x2, P6, H2 < 20, L2, O2, R3)).lam12, I2 = T2.salp2, N2 = T2.calp2, b3 = T2.sig12, k2 = T2.ssig1, D2 = T2.csig1, j2 = T2.ssig2, U2 = T2.csig2, F2 = T2.eps, gt2 = T2.domg12, Y2 = T2.dlam12, !J2 && Math.abs(Z2) >= (V2 ? 8 : 1) * p5 && H2 != d2; ++H2) Z2 > 0 && (H2 < 20 || A2 / C2 > X2 / K2) ? (K2 = C2, X2 = A2) : Z2 < 0 && (H2 < 20 || A2 / C2 < Q2 / W2) && (W2 = C2, Q2 = A2), H2 < 20 && Y2 > 0 && ($2 = -Z2 / Y2, Math.abs($2) < Math.PI && (tt2 = Math.sin($2), (it2 = C2 * (st2 = Math.cos($2)) + A2 * tt2) > 0)) ? (A2 = A2 * st2 - C2 * tt2, C2 = it2, C2 /= c3 = a4.hypot(C2, A2), A2 /= c3, V2 = Math.abs(Z2) <= 16 * p5) : (C2 = (W2 + K2) / 2, A2 = (Q2 + X2) / 2, C2 /= c3 = a4.hypot(C2, A2), A2 /= c3, V2 = false, J2 = Math.abs(W2 - C2) + (Q2 - A2) < S2 || Math.abs(C2 - K2) + (A2 - X2) < S2);
              at2 = n3 | (n3 & (t3.REDUCEDLENGTH | t3.GEODESICSCALE) ? t3.DISTANCE : t3.NONE), y3 = (T2 = this.Lengths(F2, b3, k2, D2, w2, j2, U2, v2, g3, m3, at2, L2, O2)).s12b, E6 = T2.m12b, n3 & t3.GEODESICSCALE && (Et2.M12 = T2.M12, Et2.M21 = T2.M21), E6 *= this._b, y3 *= this._b, Et2.a12 = b3 / a4.degree, n3 & t3.AREA && (yt2 = Math.sin(gt2), ut2 = x2 * (St2 = Math.cos(gt2)) - P6 * yt2, Mt2 = P6 * St2 + x2 * yt2);
            }
            return n3 & t3.DISTANCE && (Et2.s12 = 0 + y3), n3 & t3.REDUCEDLENGTH && (Et2.m12 = 0 + E6), n3 & t3.AREA && (ht2 = C2 * g3, 0 !== (et2 = a4.hypot(A2, C2 * M6)) && 0 !== ht2 ? (k2 = M6, D2 = A2 * g3, j2 = f3, U2 = N2 * m3, F2 = (rt2 = a4.sq(et2) * this._ep2) / (2 * (1 + Math.sqrt(1 + rt2)) + rt2), ot2 = a4.sq(this.a) * et2 * ht2 * this._e2, k2 /= c3 = a4.hypot(k2, D2), D2 /= c3, j2 /= c3 = a4.hypot(j2, U2), U2 /= c3, lt2 = new Array(t3.nC4_), this.C4f(F2, lt2), ct2 = t3.SinCosSeries(false, k2, D2, lt2), _t2 = t3.SinCosSeries(false, j2, U2, lt2), Et2.S12 = ot2 * (_t2 - ct2)) : Et2.S12 = 0, q2 || 2 != ut2 || (ut2 = Math.sin(B2), Mt2 = Math.cos(B2)), !q2 && Mt2 > -0.7071 && f3 - M6 < 1.75 ? (gt2 = 1 + Mt2, ft2 = 1 + g3, dt2 = 1 + m3, nt2 = 2 * Math.atan2(ut2 * (M6 * dt2 + f3 * ft2), gt2 * (M6 * f3 + ft2 * dt2))) : (mt2 = N2 * A2 + I2 * C2, 0 == (pt2 = I2 * A2 - N2 * C2) && mt2 < 0 && (pt2 = t3.tiny_ * A2, mt2 = -1), nt2 = Math.atan2(pt2, mt2)), Et2.S12 += this._c2 * nt2, Et2.S12 *= _3 * l3 * u3, Et2.S12 += 0), _3 < 0 && ([I2, C2] = [C2, I2], [N2, A2] = [A2, N2], n3 & t3.GEODESICSCALE && ([Et2.M21, Et2.M12] = [Et2.M12, Et2.M21])), { vals: Et2, salp1: C2 *= _3 * l3, calp1: A2 *= _3 * u3, salp2: I2 *= _3 * l3, calp2: N2 *= _3 * u3 };
          }, t3.Geodesic.prototype.GenDirect = function(i4, a5, h4, e3, n3, r3) {
            return r3 ? r3 === t3.LONG_UNROLL && (r3 |= t3.STANDARD) : r3 = t3.STANDARD, e3 || (r3 |= t3.DISTANCE_IN), new s3.GeodesicLine(this, i4, a5, h4, r3).GenPosition(e3, n3, r3);
          }, t3.Geodesic.prototype.Direct = function(t4, s4, i4, a5, h4) {
            return this.GenDirect(t4, s4, i4, false, a5, h4);
          }, t3.Geodesic.prototype.ArcDirect = function(t4, s4, i4, a5, h4) {
            return this.GenDirect(t4, s4, i4, true, a5, h4);
          }, t3.Geodesic.prototype.Line = function(t4, i4, a5, h4) {
            return new s3.GeodesicLine(this, t4, i4, a5, h4);
          }, t3.Geodesic.prototype.DirectLine = function(t4, s4, i4, a5, h4) {
            return this.GenDirectLine(t4, s4, i4, false, a5, h4);
          }, t3.Geodesic.prototype.ArcDirectLine = function(t4, s4, i4, a5, h4) {
            return this.GenDirectLine(t4, s4, i4, true, a5, h4);
          }, t3.Geodesic.prototype.GenDirectLine = function(i4, a5, h4, e3, n3, r3) {
            var o3;
            return r3 || (r3 = t3.STANDARD | t3.DISTANCE_IN), e3 || (r3 |= t3.DISTANCE_IN), (o3 = new s3.GeodesicLine(this, i4, a5, h4, r3)).GenSetDistance(e3, n3), o3;
          }, t3.Geodesic.prototype.InverseLine = function(i4, h4, e3, n3, r3) {
            var o3, l3, c3;
            return r3 || (r3 = t3.STANDARD | t3.DISTANCE_IN), o3 = this.InverseInt(i4, h4, e3, n3, t3.ARC), c3 = a4.atan2d(o3.salp1, o3.calp1), r3 & t3.OUT_MASK & t3.DISTANCE_IN && (r3 |= t3.DISTANCE), (l3 = new s3.GeodesicLine(this, i4, h4, c3, r3, o3.salp1, o3.calp1)).SetArc(o3.vals.a12), l3;
          }, t3.Geodesic.prototype.Polygon = function(t4) {
            return new i3.PolygonArea(this, t4);
          }, t3.WGS84 = new t3.Geodesic(h3.WGS84.a, h3.WGS84.f);
        }(h2.Geodesic, h2.GeodesicLine, h2.PolygonArea, h2.Math, h2.Constants), function(t3, s3, i3) {
          s3.GeodesicLine = function(s4, a4, h3, e2, n2, r2, o2) {
            var l2, c2, _2, u2, M5, g2;
            n2 || (n2 = t3.STANDARD | t3.DISTANCE_IN), this.a = s4.a, this.f = s4.f, this._b = s4._b, this._c2 = s4._c2, this._f1 = s4._f1, this.caps = n2 | t3.LATITUDE | t3.AZIMUTH | t3.LONG_UNROLL, this.lat1 = i3.LatFix(a4), this.lon1 = h3, void 0 === r2 || void 0 === o2 ? (this.azi1 = i3.AngNormalize(e2), l2 = i3.sincosd(i3.AngRound(this.azi1)), this.salp1 = l2.s, this.calp1 = l2.c) : (this.azi1 = e2, this.salp1 = r2, this.calp1 = o2), l2 = i3.sincosd(i3.AngRound(this.lat1)), _2 = this._f1 * l2.s, c2 = l2.c, _2 /= l2 = i3.hypot(_2, c2), c2 /= l2, c2 = Math.max(t3.tiny_, c2), this._dn1 = Math.sqrt(1 + s4._ep2 * i3.sq(_2)), this._salp0 = this.salp1 * c2, this._calp0 = i3.hypot(this.calp1, this.salp1 * _2), this._ssig1 = _2, this._somg1 = this._salp0 * _2, this._csig1 = this._comg1 = 0 !== _2 || 0 !== this.calp1 ? c2 * this.calp1 : 1, l2 = i3.hypot(this._ssig1, this._csig1), this._ssig1 /= l2, this._csig1 /= l2, this._k2 = i3.sq(this._calp0) * s4._ep2, u2 = this._k2 / (2 * (1 + Math.sqrt(1 + this._k2)) + this._k2), this.caps & t3.CAP_C1 && (this._A1m1 = t3.A1m1f(u2), this._C1a = new Array(t3.nC1_ + 1), t3.C1f(u2, this._C1a), this._B11 = t3.SinCosSeries(true, this._ssig1, this._csig1, this._C1a), M5 = Math.sin(this._B11), g2 = Math.cos(this._B11), this._stau1 = this._ssig1 * g2 + this._csig1 * M5, this._ctau1 = this._csig1 * g2 - this._ssig1 * M5), this.caps & t3.CAP_C1p && (this._C1pa = new Array(t3.nC1p_ + 1), t3.C1pf(u2, this._C1pa)), this.caps & t3.CAP_C2 && (this._A2m1 = t3.A2m1f(u2), this._C2a = new Array(t3.nC2_ + 1), t3.C2f(u2, this._C2a), this._B21 = t3.SinCosSeries(true, this._ssig1, this._csig1, this._C2a)), this.caps & t3.CAP_C3 && (this._C3a = new Array(t3.nC3_), s4.C3f(u2, this._C3a), this._A3c = -this.f * this._salp0 * s4.A3f(u2), this._B31 = t3.SinCosSeries(true, this._ssig1, this._csig1, this._C3a)), this.caps & t3.CAP_C4 && (this._C4a = new Array(t3.nC4_), s4.C4f(u2, this._C4a), this._A4 = i3.sq(this.a) * this._calp0 * this._salp0 * s4._e2, this._B41 = t3.SinCosSeries(false, this._ssig1, this._csig1, this._C4a)), this.a13 = this.s13 = NaN;
          }, s3.GeodesicLine.prototype.GenPosition = function(s4, a4, h3) {
            var e2, n2, r2, o2, l2, c2, _2, u2, M5, g2, f2, d2, p5, m2, y2, S2, E5, w2, v2, G2, x2, P6, b3, A2, C2, N2, I2 = {};
            return h3 ? h3 === t3.LONG_UNROLL && (h3 |= t3.STANDARD) : h3 = t3.STANDARD, h3 &= this.caps & t3.OUT_MASK, I2.lat1 = this.lat1, I2.azi1 = this.azi1, I2.lon1 = h3 & t3.LONG_UNROLL ? this.lon1 : i3.AngNormalize(this.lon1), s4 ? I2.a12 = a4 : I2.s12 = a4, s4 || this.caps & t3.DISTANCE_IN & t3.OUT_MASK ? (o2 = 0, l2 = 0, s4 ? (e2 = a4 * i3.degree, n2 = (b3 = i3.sincosd(a4)).s, r2 = b3.c) : (u2 = a4 / (this._b * (1 + this._A1m1)), M5 = Math.sin(u2), g2 = Math.cos(u2), e2 = u2 - ((o2 = -t3.SinCosSeries(true, this._stau1 * g2 + this._ctau1 * M5, this._ctau1 * g2 - this._stau1 * M5, this._C1pa)) - this._B11), n2 = Math.sin(e2), r2 = Math.cos(e2), Math.abs(this.f) > 0.01 && (c2 = this._ssig1 * r2 + this._csig1 * n2, _2 = this._csig1 * r2 - this._ssig1 * n2, o2 = t3.SinCosSeries(true, c2, _2, this._C1a), e2 -= ((1 + this._A1m1) * (e2 + (o2 - this._B11)) - a4 / this._b) / Math.sqrt(1 + this._k2 * i3.sq(c2)), n2 = Math.sin(e2), r2 = Math.cos(e2))), c2 = this._ssig1 * r2 + this._csig1 * n2, _2 = this._csig1 * r2 - this._ssig1 * n2, v2 = Math.sqrt(1 + this._k2 * i3.sq(c2)), h3 & (t3.DISTANCE | t3.REDUCEDLENGTH | t3.GEODESICSCALE) && ((s4 || Math.abs(this.f) > 0.01) && (o2 = t3.SinCosSeries(true, c2, _2, this._C1a)), l2 = (1 + this._A1m1) * (o2 - this._B11)), p5 = this._calp0 * c2, 0 === (m2 = i3.hypot(this._salp0, this._calp0 * _2)) && (m2 = _2 = t3.tiny_), E5 = this._salp0, w2 = this._calp0 * _2, s4 && h3 & t3.DISTANCE && (I2.s12 = this._b * ((1 + this._A1m1) * e2 + l2)), h3 & t3.LONGITUDE && (y2 = this._salp0 * c2, S2 = _2, d2 = i3.copysign(1, this._salp0), f2 = ((h3 & t3.LONG_UNROLL ? d2 * (e2 - (Math.atan2(c2, _2) - Math.atan2(this._ssig1, this._csig1)) + (Math.atan2(d2 * y2, S2) - Math.atan2(d2 * this._somg1, this._comg1))) : Math.atan2(y2 * this._comg1 - S2 * this._somg1, S2 * this._comg1 + y2 * this._somg1)) + this._A3c * (e2 + (t3.SinCosSeries(true, c2, _2, this._C3a) - this._B31))) / i3.degree, I2.lon2 = h3 & t3.LONG_UNROLL ? this.lon1 + f2 : i3.AngNormalize(i3.AngNormalize(this.lon1) + i3.AngNormalize(f2))), h3 & t3.LATITUDE && (I2.lat2 = i3.atan2d(p5, this._f1 * m2)), h3 & t3.AZIMUTH && (I2.azi2 = i3.atan2d(E5, w2)), h3 & (t3.REDUCEDLENGTH | t3.GEODESICSCALE) && (G2 = t3.SinCosSeries(true, c2, _2, this._C2a), x2 = (1 + this._A2m1) * (G2 - this._B21), P6 = (this._A1m1 - this._A2m1) * e2 + (l2 - x2), h3 & t3.REDUCEDLENGTH && (I2.m12 = this._b * (v2 * (this._csig1 * c2) - this._dn1 * (this._ssig1 * _2) - this._csig1 * _2 * P6)), h3 & t3.GEODESICSCALE && (b3 = this._k2 * (c2 - this._ssig1) * (c2 + this._ssig1) / (this._dn1 + v2), I2.M12 = r2 + (b3 * c2 - _2 * P6) * this._ssig1 / this._dn1, I2.M21 = r2 - (b3 * this._ssig1 - this._csig1 * P6) * c2 / v2)), h3 & t3.AREA && (A2 = t3.SinCosSeries(false, c2, _2, this._C4a), 0 === this._calp0 || 0 === this._salp0 ? (C2 = E5 * this.calp1 - w2 * this.salp1, N2 = w2 * this.calp1 + E5 * this.salp1) : (C2 = this._calp0 * this._salp0 * (r2 <= 0 ? this._csig1 * (1 - r2) + n2 * this._ssig1 : n2 * (this._csig1 * n2 / (1 + r2) + this._ssig1)), N2 = i3.sq(this._salp0) + i3.sq(this._calp0) * this._csig1 * _2), I2.S12 = this._c2 * Math.atan2(C2, N2) + this._A4 * (A2 - this._B41)), s4 || (I2.a12 = e2 / i3.degree), I2) : (I2.a12 = NaN, I2);
          }, s3.GeodesicLine.prototype.Position = function(t4, s4) {
            return this.GenPosition(false, t4, s4);
          }, s3.GeodesicLine.prototype.ArcPosition = function(t4, s4) {
            return this.GenPosition(true, t4, s4);
          }, s3.GeodesicLine.prototype.GenSetDistance = function(t4, s4) {
            t4 ? this.SetArc(s4) : this.SetDistance(s4);
          }, s3.GeodesicLine.prototype.SetDistance = function(s4) {
            var i4;
            this.s13 = s4, i4 = this.GenPosition(false, this.s13, t3.ARC), this.a13 = 0 + i4.a12;
          }, s3.GeodesicLine.prototype.SetArc = function(s4) {
            var i4;
            this.a13 = s4, i4 = this.GenPosition(true, this.a13, t3.DISTANCE), this.s13 = 0 + i4.s12;
          };
        }(h2.Geodesic, h2.GeodesicLine, h2.Math), function(t3, s3, i3, a4) {
          var h3, e2, n2, r2;
          h3 = function(t4, s4) {
            var a5 = i3.AngDiff(t4, s4).d;
            return t4 = i3.AngNormalize(t4), s4 = i3.AngNormalize(s4), a5 > 0 && (t4 < 0 && s4 >= 0 || t4 > 0 && 0 === s4) ? 1 : a5 < 0 && t4 >= 0 && s4 < 0 ? -1 : 0;
          }, e2 = function(t4, s4) {
            return (0 <= (s4 %= 720) && s4 < 360 || s4 < -360 ? 0 : 1) - (0 <= (t4 %= 720) && t4 < 360 || t4 < -360 ? 0 : 1);
          }, n2 = function(t4, s4, i4, a5, h4) {
            return t4.Remainder(s4), 1 & i4 && t4.Add((t4.Sum() < 0 ? 1 : -1) * s4 / 2), a5 || t4.Negate(), h4 ? t4.Sum() > s4 / 2 ? t4.Add(-s4) : t4.Sum() <= -s4 / 2 && t4.Add(+s4) : t4.Sum() >= s4 ? t4.Add(-s4) : t4.Sum() < 0 && t4.Add(+s4), 0 + t4.Sum();
          }, r2 = function(t4, s4, a5, h4, e3) {
            return t4 = i3.remainder(t4, s4), 1 & a5 && (t4 += (t4 < 0 ? 1 : -1) * s4 / 2), h4 || (t4 *= -1), e3 ? t4 > s4 / 2 ? t4 -= s4 : t4 <= -s4 / 2 && (t4 += s4) : t4 >= s4 ? t4 -= s4 : t4 < 0 && (t4 += s4), 0 + t4;
          }, t3.PolygonArea = function(t4, i4) {
            this._geod = t4, this.a = this._geod.a, this.f = this._geod.f, this._area0 = 4 * Math.PI * t4._c2, this.polyline = i4 || false, this._mask = s3.LATITUDE | s3.LONGITUDE | s3.DISTANCE | (this.polyline ? s3.NONE : s3.AREA | s3.LONG_UNROLL), this.polyline || (this._areasum = new a4.Accumulator(0)), this._perimetersum = new a4.Accumulator(0), this.Clear();
          }, t3.PolygonArea.prototype.Clear = function() {
            this.num = 0, this._crossings = 0, this.polyline || this._areasum.Set(0), this._perimetersum.Set(0), this._lat0 = this._lon0 = this.lat = this.lon = NaN;
          }, t3.PolygonArea.prototype.AddPoint = function(t4, s4) {
            var i4;
            0 === this.num ? (this._lat0 = this.lat = t4, this._lon0 = this.lon = s4) : (i4 = this._geod.Inverse(this.lat, this.lon, t4, s4, this._mask), this._perimetersum.Add(i4.s12), this.polyline || (this._areasum.Add(i4.S12), this._crossings += h3(this.lon, s4)), this.lat = t4, this.lon = s4), ++this.num;
          }, t3.PolygonArea.prototype.AddEdge = function(t4, s4) {
            var i4;
            this.num && (i4 = this._geod.Direct(this.lat, this.lon, t4, s4, this._mask), this._perimetersum.Add(s4), this.polyline || (this._areasum.Add(i4.S12), this._crossings += e2(this.lon, i4.lon2)), this.lat = i4.lat2, this.lon = i4.lon2), ++this.num;
          }, t3.PolygonArea.prototype.Compute = function(t4, s4) {
            var i4, e3, r3 = { number: this.num };
            return this.num < 2 ? (r3.perimeter = 0, this.polyline || (r3.area = 0), r3) : this.polyline ? (r3.perimeter = this._perimetersum.Sum(), r3) : (i4 = this._geod.Inverse(this.lat, this.lon, this._lat0, this._lon0, this._mask), r3.perimeter = this._perimetersum.Sum(i4.s12), (e3 = new a4.Accumulator(this._areasum)).Add(i4.S12), r3.area = n2(e3, this._area0, this._crossings + h3(this.lon, this._lon0), t4, s4), r3);
          }, t3.PolygonArea.prototype.TestPoint = function(t4, s4, i4, a5) {
            var e3, n3, o2, l2, c2 = { number: this.num + 1 };
            if (0 === this.num) return c2.perimeter = 0, this.polyline || (c2.area = 0), c2;
            for (c2.perimeter = this._perimetersum.Sum(), n3 = this.polyline ? 0 : this._areasum.Sum(), o2 = this._crossings, l2 = 0; l2 < (this.polyline ? 1 : 2); ++l2) e3 = this._geod.Inverse(0 === l2 ? this.lat : t4, 0 === l2 ? this.lon : s4, 0 !== l2 ? this._lat0 : t4, 0 !== l2 ? this._lon0 : s4, this._mask), c2.perimeter += e3.s12, this.polyline || (n3 += e3.S12, o2 += h3(0 === l2 ? this.lon : s4, 0 !== l2 ? this._lon0 : s4));
            return this.polyline || (c2.area = r2(n3, this._area0, o2, i4, a5)), c2;
          }, t3.PolygonArea.prototype.TestEdge = function(t4, s4, i4, a5) {
            var n3, o2, l2, c2 = { number: this.num ? this.num + 1 : 0 };
            return 0 === this.num || (c2.perimeter = this._perimetersum.Sum() + s4, this.polyline || (o2 = this._areasum.Sum(), l2 = this._crossings, o2 += (n3 = this._geod.Direct(this.lat, this.lon, t4, s4, this._mask)).S12, l2 += e2(this.lon, n3.lon2), l2 += h3(n3.lon2, this._lon0), n3 = this._geod.Inverse(n3.lat2, n3.lon2, this._lat0, this._lon0, this._mask), c2.perimeter += n3.s12, o2 += n3.S12, c2.area = r2(o2, this._area0, l2, i4, a5))), c2;
          };
        }(h2.PolygonArea, h2.Geodesic, h2.Math, h2.Accumulator), a3 = h2, t2.exports ? t2.exports = a3 : window.geodesic = a3;
      }(Qs)), Qs.exports);
      var Xs = { init: function() {
        this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0), this.g = new Ks.Geodesic.Geodesic(this.a, this.es / (1 + Math.sqrt(1 - this.es)));
      }, forward: function(t2) {
        var s2, i2, n2, r2, o2, l2, c2, _2, u2, M5, g2, f2, d2, p5, m2, y2 = t2.x, S2 = t2.y, E5 = Math.sin(t2.y), w2 = Math.cos(t2.y), v2 = z(y2 - this.long0);
        return this.sphere ? Math.abs(this.sin_p12 - 1) <= h ? (t2.x = this.x0 + this.a * (a - S2) * Math.sin(v2), t2.y = this.y0 - this.a * (a - S2) * Math.cos(v2), t2) : Math.abs(this.sin_p12 + 1) <= h ? (t2.x = this.x0 + this.a * (a + S2) * Math.sin(v2), t2.y = this.y0 + this.a * (a + S2) * Math.cos(v2), t2) : (u2 = this.sin_p12 * E5 + this.cos_p12 * w2 * Math.cos(v2), _2 = (c2 = Math.acos(u2)) ? c2 / Math.sin(c2) : 1, t2.x = this.x0 + this.a * _2 * w2 * Math.sin(v2), t2.y = this.y0 + this.a * _2 * (this.cos_p12 * E5 - this.sin_p12 * w2 * Math.cos(v2)), t2) : (s2 = ps(this.es), i2 = ms(this.es), n2 = ys(this.es), r2 = Ss(this.es), Math.abs(this.sin_p12 - 1) <= h ? (o2 = this.a * ds(s2, i2, n2, r2, a), l2 = this.a * ds(s2, i2, n2, r2, S2), t2.x = this.x0 + (o2 - l2) * Math.sin(v2), t2.y = this.y0 - (o2 - l2) * Math.cos(v2), t2) : Math.abs(this.sin_p12 + 1) <= h ? (o2 = this.a * ds(s2, i2, n2, r2, a), l2 = this.a * ds(s2, i2, n2, r2, S2), t2.x = this.x0 + (o2 + l2) * Math.sin(v2), t2.y = this.y0 + (o2 + l2) * Math.cos(v2), t2) : Math.abs(y2) < h && Math.abs(S2 - this.lat0) < h ? (t2.x = t2.y = 0, t2) : (M5 = this.lat0 / e, g2 = this.long0 / e, f2 = S2 / e, d2 = y2 / e, m2 = (p5 = this.g.Inverse(M5, g2, f2, d2, this.g.AZIMUTH)).azi1 * e, t2.x = p5.s12 * Math.sin(m2), t2.y = p5.s12 * Math.cos(m2), t2));
      }, inverse: function(t2) {
        var s2, i2, n2, r2, o2, l2, c2, _2, u2, M5, g2, f2, d2, p5, m2, y2, S2;
        if (t2.x -= this.x0, t2.y -= this.y0, this.sphere) {
          if ((s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y)) > 2 * a * this.a) return;
          return i2 = s2 / this.a, n2 = Math.sin(i2), r2 = Math.cos(i2), o2 = this.long0, Math.abs(s2) <= h ? l2 = this.lat0 : (l2 = Os(r2 * this.sin_p12 + t2.y * n2 * this.cos_p12 / s2), c2 = Math.abs(this.lat0) - a, o2 = Math.abs(c2) <= h ? this.lat0 >= 0 ? z(this.long0 + Math.atan2(t2.x, -t2.y)) : z(this.long0 - Math.atan2(-t2.x, t2.y)) : z(this.long0 + Math.atan2(t2.x * n2, s2 * this.cos_p12 * r2 - t2.y * this.sin_p12 * n2))), t2.x = o2, t2.y = l2, t2;
        }
        return _2 = ps(this.es), u2 = ms(this.es), M5 = ys(this.es), g2 = Ss(this.es), Math.abs(this.sin_p12 - 1) <= h ? (l2 = vs(((f2 = this.a * ds(_2, u2, M5, g2, a)) - (s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y))) / this.a, _2, u2, M5, g2), o2 = z(this.long0 + Math.atan2(t2.x, -1 * t2.y)), t2.x = o2, t2.y = l2, t2) : Math.abs(this.sin_p12 + 1) <= h ? (f2 = this.a * ds(_2, u2, M5, g2, a), l2 = vs(((s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y)) - f2) / this.a, _2, u2, M5, g2), o2 = z(this.long0 + Math.atan2(t2.x, t2.y)), t2.x = o2, t2.y = l2, t2) : (d2 = this.lat0 / e, p5 = this.long0 / e, m2 = Math.atan2(t2.x, t2.y) / e, y2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), S2 = this.g.Direct(d2, p5, m2, y2, this.g.STANDARD), t2.x = S2.lon2 * e, t2.y = S2.lat2 * e, t2);
      }, names: ["Azimuthal_Equidistant", "aeqd"] };
      var Vs = { init: function() {
        this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
      }, forward: function(t2) {
        var s2, i2, a3, e2, n2, r2, o2, l2 = t2.x, c2 = t2.y;
        return a3 = z(l2 - this.long0), s2 = Math.sin(c2), i2 = Math.cos(c2), e2 = Math.cos(a3), ((n2 = this.sin_p14 * s2 + this.cos_p14 * i2 * e2) > 0 || Math.abs(n2) <= h) && (r2 = 1 * this.a * i2 * Math.sin(a3), o2 = this.y0 + 1 * this.a * (this.cos_p14 * s2 - this.sin_p14 * i2 * e2)), t2.x = r2, t2.y = o2, t2;
      }, inverse: function(t2) {
        var s2, i2, e2, n2, r2, o2, l2;
        return t2.x -= this.x0, t2.y -= this.y0, i2 = Os((s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y)) / this.a), e2 = Math.sin(i2), n2 = Math.cos(i2), o2 = this.long0, Math.abs(s2) <= h ? (l2 = this.lat0, t2.x = o2, t2.y = l2, t2) : (l2 = Os(n2 * this.sin_p14 + t2.y * e2 * this.cos_p14 / s2), r2 = Math.abs(this.lat0) - a, Math.abs(r2) <= h ? (o2 = this.lat0 >= 0 ? z(this.long0 + Math.atan2(t2.x, -t2.y)) : z(this.long0 - Math.atan2(-t2.x, t2.y)), t2.x = o2, t2.y = l2, t2) : (o2 = z(this.long0 + Math.atan2(t2.x * e2, s2 * this.cos_p14 * n2 - t2.y * this.sin_p14 * e2)), t2.x = o2, t2.y = l2, t2));
      }, names: ["ortho"] }, Js = 1, Zs = 2, Ys = 3, $s = 4, ti = 5, si = 6, ii = 1, ai = 2, hi = 3, ei = 4;
      function ni(t2, s2, i2, e2) {
        var n2;
        return t2 < h ? (e2.value = ii, n2 = 0) : (n2 = Math.atan2(s2, i2), Math.abs(n2) <= r ? e2.value = ii : n2 > r && n2 <= a + r ? (e2.value = ai, n2 -= a) : n2 > a + r || n2 <= -(a + r) ? (e2.value = hi, n2 = n2 >= 0 ? n2 - l : n2 + l) : (e2.value = ei, n2 += a)), n2;
      }
      function ri(t2, s2) {
        var i2 = t2 + s2;
        return i2 < -3.14159265359 ? i2 += o : i2 > 3.14159265359 && (i2 -= o), i2;
      }
      var oi = { init: function() {
        this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= a - r / 2 ? this.face = ti : this.lat0 <= -(a - r / 2) ? this.face = si : Math.abs(this.long0) <= r ? this.face = Js : Math.abs(this.long0) <= a + r ? this.face = this.long0 > 0 ? Zs : $s : this.face = Ys, 0 !== this.es && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
      }, forward: function(t2) {
        var s2, i2, h2, e2, n2, o2, c2 = { x: 0, y: 0 }, _2 = { value: 0 };
        if (t2.x -= this.long0, s2 = 0 !== this.es ? Math.atan(this.one_minus_f_squared * Math.tan(t2.y)) : t2.y, i2 = t2.x, this.face === ti) e2 = a - s2, i2 >= r && i2 <= a + r ? (_2.value = ii, h2 = i2 - a) : i2 > a + r || i2 <= -(a + r) ? (_2.value = ai, h2 = i2 > 0 ? i2 - l : i2 + l) : i2 > -(a + r) && i2 <= -r ? (_2.value = hi, h2 = i2 + a) : (_2.value = ei, h2 = i2);
        else if (this.face === si) e2 = a + s2, i2 >= r && i2 <= a + r ? (_2.value = ii, h2 = -i2 + a) : i2 < r && i2 >= -r ? (_2.value = ai, h2 = -i2) : i2 < -r && i2 >= -(a + r) ? (_2.value = hi, h2 = -i2 - a) : (_2.value = ei, h2 = i2 > 0 ? -i2 + l : -i2 - l);
        else {
          var u2, M5, g2, f2, d2, p5;
          this.face === Zs ? i2 = ri(i2, +a) : this.face === Ys ? i2 = ri(i2, 3.14159265359) : this.face === $s && (i2 = ri(i2, -a)), f2 = Math.sin(s2), d2 = Math.cos(s2), p5 = Math.sin(i2), u2 = d2 * Math.cos(i2), M5 = d2 * p5, g2 = f2, this.face === Js ? h2 = ni(e2 = Math.acos(u2), g2, M5, _2) : this.face === Zs ? h2 = ni(e2 = Math.acos(M5), g2, -u2, _2) : this.face === Ys ? h2 = ni(e2 = Math.acos(-u2), g2, -M5, _2) : this.face === $s ? h2 = ni(e2 = Math.acos(-M5), g2, u2, _2) : (e2 = h2 = 0, _2.value = ii);
        }
        return o2 = Math.atan(12 / l * (h2 + Math.acos(Math.sin(h2) * Math.cos(r)) - a)), n2 = Math.sqrt((1 - Math.cos(e2)) / (Math.cos(o2) * Math.cos(o2)) / (1 - Math.cos(Math.atan(1 / Math.cos(h2))))), _2.value === ai ? o2 += a : _2.value === hi ? o2 += l : _2.value === ei && (o2 += 1.5 * l), c2.x = n2 * Math.cos(o2), c2.y = n2 * Math.sin(o2), c2.x = c2.x * this.a + this.x0, c2.y = c2.y * this.a + this.y0, t2.x = c2.x, t2.y = c2.y, t2;
      }, inverse: function(t2) {
        var s2, i2, h2, e2, n2, r2, o2, c2, _2, u2, M5, g2, f2 = { lam: 0, phi: 0 }, d2 = { value: 0 };
        if (t2.x = (t2.x - this.x0) / this.a, t2.y = (t2.y - this.y0) / this.a, i2 = Math.atan(Math.sqrt(t2.x * t2.x + t2.y * t2.y)), s2 = Math.atan2(t2.y, t2.x), t2.x >= 0 && t2.x >= Math.abs(t2.y) ? d2.value = ii : t2.y >= 0 && t2.y >= Math.abs(t2.x) ? (d2.value = ai, s2 -= a) : t2.x < 0 && -t2.x >= Math.abs(t2.y) ? (d2.value = hi, s2 = s2 < 0 ? s2 + l : s2 - l) : (d2.value = ei, s2 += a), _2 = l / 12 * Math.tan(s2), n2 = Math.sin(_2) / (Math.cos(_2) - 1 / Math.sqrt(2)), r2 = Math.atan(n2), (o2 = 1 - (h2 = Math.cos(s2)) * h2 * (e2 = Math.tan(i2)) * e2 * (1 - Math.cos(Math.atan(1 / Math.cos(r2))))) < -1 ? o2 = -1 : o2 > 1 && (o2 = 1), this.face === ti) c2 = Math.acos(o2), f2.phi = a - c2, d2.value === ii ? f2.lam = r2 + a : d2.value === ai ? f2.lam = r2 < 0 ? r2 + l : r2 - l : d2.value === hi ? f2.lam = r2 - a : f2.lam = r2;
        else if (this.face === si) c2 = Math.acos(o2), f2.phi = c2 - a, d2.value === ii ? f2.lam = -r2 + a : d2.value === ai ? f2.lam = -r2 : d2.value === hi ? f2.lam = -r2 - a : f2.lam = r2 < 0 ? -r2 - l : -r2 + l;
        else {
          var p5, m2, y2;
          _2 = (p5 = o2) * p5, m2 = (_2 += (y2 = _2 >= 1 ? 0 : Math.sqrt(1 - _2) * Math.sin(r2)) * y2) >= 1 ? 0 : Math.sqrt(1 - _2), d2.value === ai ? (_2 = m2, m2 = -y2, y2 = _2) : d2.value === hi ? (m2 = -m2, y2 = -y2) : d2.value === ei && (_2 = m2, m2 = y2, y2 = -_2), this.face === Zs ? (_2 = p5, p5 = -m2, m2 = _2) : this.face === Ys ? (p5 = -p5, m2 = -m2) : this.face === $s && (_2 = p5, p5 = m2, m2 = -_2), f2.phi = Math.acos(-y2) - a, f2.lam = Math.atan2(m2, p5), this.face === Zs ? f2.lam = ri(f2.lam, -a) : this.face === Ys ? f2.lam = ri(f2.lam, -3.14159265359) : this.face === $s && (f2.lam = ri(f2.lam, +a));
        }
        return 0 !== this.es && (u2 = f2.phi < 0 ? 1 : 0, M5 = Math.tan(f2.phi), g2 = this.b / Math.sqrt(M5 * M5 + this.one_minus_f_squared), f2.phi = Math.atan(Math.sqrt(this.a * this.a - g2 * g2) / (this.one_minus_f * g2)), u2 && (f2.phi = -f2.phi)), f2.lam += this.long0, t2.x = f2.lam, t2.y = f2.phi, t2;
      }, names: ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"] }, li = [[1, 22199e-21, -715515e-10, 31103e-10], [0.9986, -482243e-9, -24897e-9, -13309e-10], [0.9954, -83103e-8, -448605e-10, -986701e-12], [0.99, -135364e-8, -59661e-9, 36777e-10], [0.9822, -167442e-8, -449547e-11, -572411e-11], [0.973, -214868e-8, -903571e-10, 18736e-12], [0.96, -305085e-8, -900761e-10, 164917e-11], [0.9427, -382792e-8, -653386e-10, -26154e-10], [0.9216, -467746e-8, -10457e-8, 481243e-11], [0.8962, -536223e-8, -323831e-10, -543432e-11], [0.8679, -609363e-8, -113898e-9, 332484e-11], [0.835, -698325e-8, -640253e-10, 934959e-12], [0.7986, -755338e-8, -500009e-10, 935324e-12], [0.7597, -798324e-8, -35971e-9, -227626e-11], [0.7186, -851367e-8, -701149e-10, -86303e-10], [0.6732, -986209e-8, -199569e-9, 191974e-10], [0.6213, -0.010418, 883923e-10, 624051e-11], [0.5722, -906601e-8, 182e-6, 624051e-11], [0.5322, -677797e-8, 275608e-9, 624051e-11]], ci = [[-520417e-23, 0.0124, 121431e-23, -845284e-16], [0.062, 0.0124, -126793e-14, 422642e-15], [0.124, 0.0124, 507171e-14, -160604e-14], [0.186, 0.0123999, -190189e-13, 600152e-14], [0.248, 0.0124002, 710039e-13, -224e-10], [0.31, 0.0123992, -264997e-12, 835986e-13], [0.372, 0.0124029, 988983e-12, -311994e-12], [0.434, 0.0123893, -369093e-11, -435621e-12], [0.4958, 0.0123198, -102252e-10, -345523e-12], [0.5571, 0.0121916, -154081e-10, -582288e-12], [0.6176, 0.0119938, -241424e-10, -525327e-12], [0.6769, 0.011713, -320223e-10, -516405e-12], [0.7346, 0.0113541, -397684e-10, -609052e-12], [0.7903, 0.0109107, -489042e-10, -104739e-11], [0.8435, 0.0103431, -64615e-9, -140374e-14], [0.8936, 969686e-8, -64636e-9, -8547e-9], [0.9394, 840947e-8, -192841e-9, -42106e-10], [0.9761, 616527e-8, -256e-6, -42106e-10], [1, 328947e-8, -319159e-9, -42106e-10]], _i = 0.8487, ui = 1.3523, Mi = n / 5, gi = 1 / Mi, fi = 18, di = function(t2, s2) {
        return t2[0] + s2 * (t2[1] + s2 * (t2[2] + s2 * t2[3]));
      };
      var pi = { init: function() {
        this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
      }, forward: function(t2) {
        var s2 = z(t2.x - this.long0), i2 = Math.abs(t2.y), a3 = Math.floor(i2 * Mi);
        a3 < 0 ? a3 = 0 : a3 >= fi && (a3 = 17);
        var h2 = { x: di(li[a3], i2 = n * (i2 - gi * a3)) * s2, y: di(ci[a3], i2) };
        return t2.y < 0 && (h2.y = -h2.y), h2.x = h2.x * this.a * _i + this.x0, h2.y = h2.y * this.a * ui + this.y0, h2;
      }, inverse: function(t2) {
        var s2 = { x: (t2.x - this.x0) / (this.a * _i), y: Math.abs(t2.y - this.y0) / (this.a * ui) };
        if (s2.y >= 1) s2.x /= li[18][0], s2.y = t2.y < 0 ? -a : a;
        else {
          var i2 = Math.floor(s2.y * fi);
          for (i2 < 0 ? i2 = 0 : i2 >= fi && (i2 = 17); ; ) if (ci[i2][0] > s2.y) --i2;
          else {
            if (!(ci[i2 + 1][0] <= s2.y)) break;
            ++i2;
          }
          var n2 = ci[i2], r2 = 5 * (s2.y - n2[0]) / (ci[i2 + 1][0] - n2[0]);
          r2 = function(t3, s3, i3, a3) {
            for (var h2 = s3; a3; --a3) {
              var e2 = t3(h2);
              if (h2 -= e2, Math.abs(e2) < i3) break;
            }
            return h2;
          }(function(t3) {
            return (di(n2, t3) - s2.y) / function(t4, s3) {
              return t4[1] + s3 * (2 * t4[2] + 3 * s3 * t4[3]);
            }(n2, t3);
          }, r2, h, 100), s2.x /= di(li[i2], r2), s2.y = (5 * i2 + r2) * e, t2.y < 0 && (s2.y = -s2.y);
        }
        return s2.x = z(s2.x + this.long0), s2;
      }, names: ["Robinson", "robin"] };
      var mi = { init: function() {
        this.name = "geocent";
      }, forward: function(t2) {
        return gt(t2, this.es, this.a);
      }, inverse: function(t2) {
        return ft(t2, this.es, this.a, this.b);
      }, names: ["Geocentric", "geocentric", "geocent", "Geocent"] }, yi = 0, Si = 1, Ei = 2, wi = 3, vi = { h: { def: 1e5, num: true }, azi: { def: 0, num: true, degrees: true }, tilt: { def: 0, num: true, degrees: true }, long0: { def: 0, num: true }, lat0: { def: 0, num: true } };
      var Gi = { init: function() {
        if (Object.keys(vi).forEach(function(t3) {
          if (void 0 === this[t3]) this[t3] = vi[t3].def;
          else {
            if (vi[t3].num && isNaN(this[t3])) throw new Error("Invalid parameter value, must be numeric " + t3 + " = " + this[t3]);
            vi[t3].num && (this[t3] = parseFloat(this[t3]));
          }
          vi[t3].degrees && (this[t3] = this[t3] * e);
        }.bind(this)), Math.abs(Math.abs(this.lat0) - a) < h ? this.mode = this.lat0 < 0 ? Si : yi : Math.abs(this.lat0) < h ? this.mode = Ei : (this.mode = wi, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10) throw new Error("Invalid height");
        this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
        var t2 = this.tilt, s2 = this.azi;
        this.cg = Math.cos(s2), this.sg = Math.sin(s2), this.cw = Math.cos(t2), this.sw = Math.sin(t2);
      }, forward: function(t2) {
        t2.x -= this.long0;
        var s2, i2, a3, h2, e2 = Math.sin(t2.y), n2 = Math.cos(t2.y), r2 = Math.cos(t2.x);
        switch (this.mode) {
          case wi:
            i2 = this.sinph0 * e2 + this.cosph0 * n2 * r2;
            break;
          case Ei:
            i2 = n2 * r2;
            break;
          case Si:
            i2 = -e2;
            break;
          case yi:
            i2 = e2;
        }
        switch (s2 = (i2 = this.pn1 / (this.p - i2)) * n2 * Math.sin(t2.x), this.mode) {
          case wi:
            i2 *= this.cosph0 * e2 - this.sinph0 * n2 * r2;
            break;
          case Ei:
            i2 *= e2;
            break;
          case yi:
            i2 *= -n2 * r2;
            break;
          case Si:
            i2 *= n2 * r2;
        }
        return h2 = 1 / ((a3 = i2 * this.cg + s2 * this.sg) * this.sw * this.h1 + this.cw), s2 = (s2 * this.cg - i2 * this.sg) * this.cw * h2, i2 = a3 * h2, t2.x = s2 * this.a, t2.y = i2 * this.a, t2;
      }, inverse: function(t2) {
        t2.x /= this.a, t2.y /= this.a;
        var s2, i2, a3, e2 = { x: t2.x, y: t2.y };
        a3 = 1 / (this.pn1 - t2.y * this.sw), s2 = this.pn1 * t2.x * a3, i2 = this.pn1 * t2.y * this.cw * a3, t2.x = s2 * this.cg + i2 * this.sg, t2.y = i2 * this.cg - s2 * this.sg;
        var n2 = ss(t2.x, t2.y);
        if (Math.abs(n2) < h) e2.x = 0, e2.y = t2.y;
        else {
          var r2, o2;
          switch (o2 = 1 - n2 * n2 * this.pfact, o2 = (this.p - Math.sqrt(o2)) / (this.pn1 / n2 + n2 / this.pn1), r2 = Math.sqrt(1 - o2 * o2), this.mode) {
            case wi:
              e2.y = Math.asin(r2 * this.sinph0 + t2.y * o2 * this.cosph0 / n2), t2.y = (r2 - this.sinph0 * Math.sin(e2.y)) * n2, t2.x *= o2 * this.cosph0;
              break;
            case Ei:
              e2.y = Math.asin(t2.y * o2 / n2), t2.y = r2 * n2, t2.x *= o2;
              break;
            case yi:
              e2.y = Math.asin(r2), t2.y = -t2.y;
              break;
            case Si:
              e2.y = -Math.asin(r2);
          }
          e2.x = Math.atan2(t2.x, t2.y);
        }
        return t2.x = e2.x + this.long0, t2.y = e2.y, t2;
      }, names: ["Tilted_Perspective", "tpers"] };
      var xi = { init: function() {
        if (this.flip_axis = "x" === this.sweep ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) throw new Error();
        if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, 0 !== this.es) {
          var t2 = 1 - this.es, s2 = 1 / t2;
          this.radius_p = Math.sqrt(t2), this.radius_p2 = t2, this.radius_p_inv2 = s2, this.shape = "ellipse";
        } else this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
        this.title || (this.title = "Geostationary Satellite View");
      }, forward: function(t2) {
        var s2, i2, a3, h2, e2 = t2.x, n2 = t2.y;
        if (e2 -= this.long0, "ellipse" === this.shape) {
          n2 = Math.atan(this.radius_p2 * Math.tan(n2));
          var r2 = this.radius_p / ss(this.radius_p * Math.cos(n2), Math.sin(n2));
          if (i2 = r2 * Math.cos(e2) * Math.cos(n2), a3 = r2 * Math.sin(e2) * Math.cos(n2), h2 = r2 * Math.sin(n2), (this.radius_g - i2) * i2 - a3 * a3 - h2 * h2 * this.radius_p_inv2 < 0) return t2.x = Number.NaN, t2.y = Number.NaN, t2;
          s2 = this.radius_g - i2, this.flip_axis ? (t2.x = this.radius_g_1 * Math.atan(a3 / ss(h2, s2)), t2.y = this.radius_g_1 * Math.atan(h2 / s2)) : (t2.x = this.radius_g_1 * Math.atan(a3 / s2), t2.y = this.radius_g_1 * Math.atan(h2 / ss(a3, s2)));
        } else "sphere" === this.shape && (s2 = Math.cos(n2), i2 = Math.cos(e2) * s2, a3 = Math.sin(e2) * s2, h2 = Math.sin(n2), s2 = this.radius_g - i2, this.flip_axis ? (t2.x = this.radius_g_1 * Math.atan(a3 / ss(h2, s2)), t2.y = this.radius_g_1 * Math.atan(h2 / s2)) : (t2.x = this.radius_g_1 * Math.atan(a3 / s2), t2.y = this.radius_g_1 * Math.atan(h2 / ss(a3, s2))));
        return t2.x = t2.x * this.a, t2.y = t2.y * this.a, t2;
      }, inverse: function(t2) {
        var s2, i2, a3, h2, e2 = -1, n2 = 0, r2 = 0;
        if (t2.x = t2.x / this.a, t2.y = t2.y / this.a, "ellipse" === this.shape) {
          this.flip_axis ? (r2 = Math.tan(t2.y / this.radius_g_1), n2 = Math.tan(t2.x / this.radius_g_1) * ss(1, r2)) : (n2 = Math.tan(t2.x / this.radius_g_1), r2 = Math.tan(t2.y / this.radius_g_1) * ss(1, n2));
          var o2 = r2 / this.radius_p;
          if (s2 = n2 * n2 + o2 * o2 + e2 * e2, (a3 = (i2 = 2 * this.radius_g * e2) * i2 - 4 * s2 * this.C) < 0) return t2.x = Number.NaN, t2.y = Number.NaN, t2;
          h2 = (-i2 - Math.sqrt(a3)) / (2 * s2), e2 = this.radius_g + h2 * e2, n2 *= h2, r2 *= h2, t2.x = Math.atan2(n2, e2), t2.y = Math.atan(r2 * Math.cos(t2.x) / e2), t2.y = Math.atan(this.radius_p_inv2 * Math.tan(t2.y));
        } else if ("sphere" === this.shape) {
          if (this.flip_axis ? (r2 = Math.tan(t2.y / this.radius_g_1), n2 = Math.tan(t2.x / this.radius_g_1) * Math.sqrt(1 + r2 * r2)) : (n2 = Math.tan(t2.x / this.radius_g_1), r2 = Math.tan(t2.y / this.radius_g_1) * Math.sqrt(1 + n2 * n2)), s2 = n2 * n2 + r2 * r2 + e2 * e2, (a3 = (i2 = 2 * this.radius_g * e2) * i2 - 4 * s2 * this.C) < 0) return t2.x = Number.NaN, t2.y = Number.NaN, t2;
          h2 = (-i2 - Math.sqrt(a3)) / (2 * s2), e2 = this.radius_g + h2 * e2, n2 *= h2, r2 *= h2, t2.x = Math.atan2(n2, e2), t2.y = Math.atan(r2 * Math.cos(t2.x) / e2);
        }
        return t2.x = t2.x + this.long0, t2;
      }, names: ["Geostationary Satellite View", "Geostationary_Satellite", "geos"] }, Pi = 1.340264, bi = -0.081106, Ai = 893e-6, Ci = 3796e-6, Ni = Math.sqrt(3) / 2;
      var Ii = { init: function() {
        this.es = 0, this.long0 = void 0 !== this.long0 ? this.long0 : 0;
      }, forward: function(t2) {
        var s2 = z(t2.x - this.long0), i2 = t2.y, a3 = Math.asin(Ni * Math.sin(i2)), h2 = a3 * a3, e2 = h2 * h2 * h2;
        return t2.x = s2 * Math.cos(a3) / (Ni * (Pi + 3 * bi * h2 + e2 * (7 * Ai + 9 * Ci * h2))), t2.y = a3 * (Pi + bi * h2 + e2 * (Ai + Ci * h2)), t2.x = this.a * t2.x + this.x0, t2.y = this.a * t2.y + this.y0, t2;
      }, inverse: function(t2) {
        t2.x = (t2.x - this.x0) / this.a, t2.y = (t2.y - this.y0) / this.a;
        var s2, i2, a3, h2, e2 = t2.y;
        for (h2 = 0; h2 < 12 && (e2 -= a3 = (e2 * (Pi + bi * (s2 = e2 * e2) + (i2 = s2 * s2 * s2) * (Ai + Ci * s2)) - t2.y) / (Pi + 3 * bi * s2 + i2 * (7 * Ai + 9 * Ci * s2)), !(Math.abs(a3) < 1e-9)); ++h2) ;
        return i2 = (s2 = e2 * e2) * s2 * s2, t2.x = Ni * t2.x * (Pi + 3 * bi * s2 + i2 * (7 * Ai + 9 * Ci * s2)) / Math.cos(e2), t2.y = Math.asin(Math.sin(e2) / Ni), t2.x = z(t2.x + this.long0), t2;
      }, names: ["eqearth", "Equal Earth", "Equal_Earth"] }, Li = 1e-10;
      function Oi(t2) {
        var s2, i2, a3, h2 = z(t2.x - (this.long0 || 0)), e2 = t2.y;
        return s2 = this.am1 + this.m1 - Zt(e2, i2 = Math.sin(e2), a3 = Math.cos(e2), this.en), i2 = a3 * h2 / (s2 * Math.sqrt(1 - this.es * i2 * i2)), t2.x = s2 * Math.sin(i2), t2.y = this.am1 - s2 * Math.cos(i2), t2.x = this.a * t2.x + (this.x0 || 0), t2.y = this.a * t2.y + (this.y0 || 0), t2;
      }
      function Ri(t2) {
        var s2, i2, h2, e2;
        if (t2.x = (t2.x - (this.x0 || 0)) / this.a, t2.y = (t2.y - (this.y0 || 0)) / this.a, i2 = ss(t2.x, t2.y = this.am1 - t2.y), e2 = Yt(this.am1 + this.m1 - i2, this.es, this.en), (s2 = Math.abs(e2)) < a) s2 = Math.sin(e2), h2 = i2 * Math.atan2(t2.x, t2.y) * Math.sqrt(1 - this.es * s2 * s2) / Math.cos(e2);
        else {
          if (!(Math.abs(s2 - a) <= Li)) throw new Error();
          h2 = 0;
        }
        return t2.x = z(h2 + (this.long0 || 0)), t2.y = ws(e2), t2;
      }
      function qi(t2) {
        var s2, i2, a3 = z(t2.x - (this.long0 || 0)), h2 = t2.y;
        return i2 = this.cphi1 + this.phi1 - h2, Math.abs(i2) > Li ? (t2.x = i2 * Math.sin(s2 = a3 * Math.cos(h2) / i2), t2.y = this.cphi1 - i2 * Math.cos(s2)) : t2.x = t2.y = 0, t2.x = this.a * t2.x + (this.x0 || 0), t2.y = this.a * t2.y + (this.y0 || 0), t2;
      }
      function Ti(t2) {
        var s2, i2;
        t2.x = (t2.x - (this.x0 || 0)) / this.a, t2.y = (t2.y - (this.y0 || 0)) / this.a;
        var h2 = ss(t2.x, t2.y = this.cphi1 - t2.y);
        if (i2 = this.cphi1 + this.phi1 - h2, Math.abs(i2) > a) throw new Error();
        return s2 = Math.abs(Math.abs(i2) - a) <= Li ? 0 : h2 * Math.atan2(t2.x, t2.y) / Math.cos(i2), t2.x = z(s2 + (this.long0 || 0)), t2.y = ws(i2), t2;
      }
      var ki = { init: function() {
        var t2;
        if (this.phi1 = this.lat1, Math.abs(this.phi1) < Li) throw new Error();
        this.es ? (this.en = Jt(this.es), this.m1 = Zt(this.phi1, this.am1 = Math.sin(this.phi1), t2 = Math.cos(this.phi1), this.en), this.am1 = t2 / (Math.sqrt(1 - this.es * this.am1 * this.am1) * this.am1), this.inverse = Ri, this.forward = Oi) : (Math.abs(this.phi1) + Li >= a ? this.cphi1 = 0 : this.cphi1 = 1 / Math.tan(this.phi1), this.inverse = Ti, this.forward = qi);
      }, names: ["bonne", "Bonne (Werner lat_1=90)"] };
      return At.defaultDatum = "WGS84", At.Proj = Mt, At.WGS84 = new At.Proj("WGS84"), At.Point = Qt, At.toPoint = wt, At.defs = k, At.nadgrid = function(t2, s2, i2) {
        return s2 instanceof ArrayBuffer ? function(t3, s3, i3) {
          var a3 = true;
          void 0 !== i3 && false === i3.includeErrorFields && (a3 = false);
          var h2 = new DataView(s3), e2 = function(t4) {
            var s4 = t4.getInt32(8, false);
            if (11 === s4) return false;
            s4 = t4.getInt32(8, true), 11 !== s4 && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian");
            return true;
          }(h2), n2 = function(t4, s4) {
            return { nFields: t4.getInt32(8, s4), nSubgridFields: t4.getInt32(24, s4), nSubgrids: t4.getInt32(40, s4), shiftType: lt(t4, 56, 64).trim(), fromSemiMajorAxis: t4.getFloat64(120, s4), fromSemiMinorAxis: t4.getFloat64(136, s4), toSemiMajorAxis: t4.getFloat64(152, s4), toSemiMinorAxis: t4.getFloat64(168, s4) };
          }(h2, e2), r2 = function(t4, s4, i4, a4) {
            for (var h3 = 176, e3 = [], n3 = 0; n3 < s4.nSubgrids; n3++) {
              var r3 = _t(t4, h3, i4), o3 = ut(t4, h3, r3, i4, a4), l2 = Math.round(1 + (r3.upperLongitude - r3.lowerLongitude) / r3.longitudeInterval), c2 = Math.round(1 + (r3.upperLatitude - r3.lowerLatitude) / r3.latitudeInterval);
              e3.push({ ll: [ot(r3.lowerLongitude), ot(r3.lowerLatitude)], del: [ot(r3.longitudeInterval), ot(r3.latitudeInterval)], lim: [l2, c2], count: r3.gridNodeCount, cvs: ct(o3) });
              var _2 = 16;
              false === a4 && (_2 = 8), h3 += 176 + r3.gridNodeCount * _2;
            }
            return e3;
          }(h2, n2, e2, a3), o2 = { header: n2, subgrids: r2 };
          return ht[t3] = o2, o2;
        }(t2, s2, i2) : { ready: et(t2, s2) };
      }, At.transform = Gt, At.mgrs = Tt, At.version = "2.17.0", function(t2) {
        t2.Proj.projections.add($t), t2.Proj.projections.add(es), t2.Proj.projections.add(ns), t2.Proj.projections.add(ls), t2.Proj.projections.add(cs), t2.Proj.projections.add(_s), t2.Proj.projections.add(Ms), t2.Proj.projections.add(gs), t2.Proj.projections.add(fs), t2.Proj.projections.add(Gs), t2.Proj.projections.add(Ls), t2.Proj.projections.add(Rs), t2.Proj.projections.add(qs), t2.Proj.projections.add(Ts), t2.Proj.projections.add(ks), t2.Proj.projections.add(Ds), t2.Proj.projections.add(js), t2.Proj.projections.add(Us), t2.Proj.projections.add(Fs), t2.Proj.projections.add(Bs), t2.Proj.projections.add(zs), t2.Proj.projections.add(Ws), t2.Proj.projections.add(Xs), t2.Proj.projections.add(Vs), t2.Proj.projections.add(oi), t2.Proj.projections.add(pi), t2.Proj.projections.add(mi), t2.Proj.projections.add(Gi), t2.Proj.projections.add(xi), t2.Proj.projections.add(Ii), t2.Proj.projections.add(ki);
      }(At), At;
    });
  }
});

// node_modules/ol/CollectionEventType.js
var CollectionEventType_default = {
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: "add",
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: "remove"
};

// node_modules/ol/ObjectEventType.js
var ObjectEventType_default = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: "propertychange"
};

// node_modules/ol/events/EventType.js
var EventType_default = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: "change",
  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: "error",
  BLUR: "blur",
  CLEAR: "clear",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  DRAGENTER: "dragenter",
  DRAGOVER: "dragover",
  DROP: "drop",
  FOCUS: "focus",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  RESIZE: "resize",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};

// node_modules/ol/Disposable.js
var Disposable = class {
  constructor() {
    this.disposed = false;
  }
  /**
   * Clean up.
   */
  dispose() {
    if (!this.disposed) {
      this.disposed = true;
      this.disposeInternal();
    }
  }
  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {
  }
};
var Disposable_default = Disposable;

// node_modules/ol/array.js
function binarySearch(haystack, needle, comparator) {
  let mid, cmp;
  comparator = comparator || ascending;
  let low = 0;
  let high = haystack.length;
  let found = false;
  while (low < high) {
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid;
      found = !cmp;
    }
  }
  return found ? low : ~low;
}
function ascending(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
function descending(a, b) {
  return a < b ? 1 : a > b ? -1 : 0;
}
function linearFindNearest(arr, target, direction) {
  if (arr[0] <= target) {
    return 0;
  }
  const n = arr.length;
  if (target <= arr[n - 1]) {
    return n - 1;
  }
  if (typeof direction === "function") {
    for (let i = 1; i < n; ++i) {
      const candidate = arr[i];
      if (candidate === target) {
        return i;
      }
      if (candidate < target) {
        if (direction(target, arr[i - 1], candidate) > 0) {
          return i - 1;
        }
        return i;
      }
    }
    return n - 1;
  }
  if (direction > 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] < target) {
        return i - 1;
      }
    }
    return n - 1;
  }
  if (direction < 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] <= target) {
        return i;
      }
    }
    return n - 1;
  }
  for (let i = 1; i < n; ++i) {
    if (arr[i] == target) {
      return i;
    }
    if (arr[i] < target) {
      if (arr[i - 1] - target < target - arr[i]) {
        return i - 1;
      }
      return i;
    }
  }
  return n - 1;
}
function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    const tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}
function extend(arr, data) {
  const extension = Array.isArray(data) ? data : [data];
  const length = extension.length;
  for (let i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}
function equals(arr1, arr2) {
  const len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (let i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
function isSorted(arr, func, strict) {
  const compare = func || ascending;
  return arr.every(function(currentVal, index) {
    if (index === 0) {
      return true;
    }
    const res = compare(arr[index - 1], currentVal);
    return !(res > 0 || strict && res === 0);
  });
}

// node_modules/ol/functions.js
function TRUE() {
  return true;
}
function FALSE() {
  return false;
}
function VOID() {
}
function memoizeOne(fn) {
  let lastResult;
  let lastArgs;
  let lastThis;
  return function() {
    const nextArgs = Array.prototype.slice.call(arguments);
    if (!lastArgs || this !== lastThis || !equals(nextArgs, lastArgs)) {
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn.apply(this, arguments);
    }
    return lastResult;
  };
}
function toPromise(getter) {
  function promiseGetter() {
    let value;
    try {
      value = getter();
    } catch (err) {
      return Promise.reject(err);
    }
    if (value instanceof Promise) {
      return value;
    }
    return Promise.resolve(value);
  }
  return promiseGetter();
}

// node_modules/ol/obj.js
function clear(object) {
  for (const property in object) {
    delete object[property];
  }
}
function isEmpty(object) {
  let property;
  for (property in object) {
    return false;
  }
  return !property;
}

// node_modules/ol/events/Event.js
var BaseEvent = class {
  /**
   * @param {string} type Type.
   */
  constructor(type) {
    this.propagationStopped;
    this.defaultPrevented;
    this.type = type;
    this.target = null;
  }
  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = true;
  }
  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = true;
  }
};
function stopPropagation(evt) {
  evt.stopPropagation();
}
var Event_default = BaseEvent;

// node_modules/ol/events/Target.js
var Target = class extends Disposable_default {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(target) {
    super();
    this.eventTarget_ = target;
    this.pendingRemovals_ = null;
    this.dispatching_ = null;
    this.listeners_ = null;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(type, listener) {
    if (!type || !listener) {
      return;
    }
    const listeners = this.listeners_ || (this.listeners_ = {});
    const listenersForType = listeners[type] || (listeners[type] = []);
    if (!listenersForType.includes(listener)) {
      listenersForType.push(listener);
    }
  }
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(event) {
    const isString = typeof event === "string";
    const type = isString ? event : event.type;
    const listeners = this.listeners_ && this.listeners_[type];
    if (!listeners) {
      return;
    }
    const evt = isString ? new Event_default(event) : (
      /** @type {Event} */
      event
    );
    if (!evt.target) {
      evt.target = this.eventTarget_ || this;
    }
    const dispatching = this.dispatching_ || (this.dispatching_ = {});
    const pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    if (!(type in dispatching)) {
      dispatching[type] = 0;
      pendingRemovals[type] = 0;
    }
    ++dispatching[type];
    let propagate;
    for (let i = 0, ii = listeners.length; i < ii; ++i) {
      if ("handleEvent" in listeners[i]) {
        propagate = /** @type {import("../events.js").ListenerObject} */
        listeners[i].handleEvent(evt);
      } else {
        propagate = /** @type {import("../events.js").ListenerFunction} */
        listeners[i].call(this, evt);
      }
      if (propagate === false || evt.propagationStopped) {
        propagate = false;
        break;
      }
    }
    if (--dispatching[type] === 0) {
      let pr = pendingRemovals[type];
      delete pendingRemovals[type];
      while (pr--) {
        this.removeEventListener(type, VOID);
      }
      delete dispatching[type];
    }
    return propagate;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.listeners_ && clear(this.listeners_);
  }
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(type) {
    return this.listeners_ && this.listeners_[type] || void 0;
  }
  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(type) {
    if (!this.listeners_) {
      return false;
    }
    return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(type, listener) {
    if (!this.listeners_) {
      return;
    }
    const listeners = this.listeners_[type];
    if (!listeners) {
      return;
    }
    const index = listeners.indexOf(listener);
    if (index !== -1) {
      if (this.pendingRemovals_ && type in this.pendingRemovals_) {
        listeners[index] = VOID;
        ++this.pendingRemovals_[type];
      } else {
        listeners.splice(index, 1);
        if (listeners.length === 0) {
          delete this.listeners_[type];
        }
      }
    }
  }
};
var Target_default = Target;

// node_modules/ol/events.js
function listen(target, type, listener, thisArg, once) {
  if (once) {
    const originalListener = listener;
    listener = function(event) {
      target.removeEventListener(type, listener);
      return originalListener.call(thisArg ?? this, event);
    };
  } else if (thisArg && thisArg !== target) {
    listener = listener.bind(thisArg);
  }
  const eventsKey = {
    target,
    type,
    listener
  };
  target.addEventListener(type, listener);
  return eventsKey;
}
function listenOnce(target, type, listener, thisArg) {
  return listen(target, type, listener, thisArg, true);
}
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    clear(key);
  }
}

// node_modules/ol/Observable.js
var Observable = class extends Target_default {
  constructor() {
    super();
    this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onInternal;
    this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onceInternal;
    this.un = /** @type {ObservableOnSignature<void>} */
    this.unInternal;
    this.revision_ = 0;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_;
    this.dispatchEvent(EventType_default.CHANGE);
  }
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(type, listener) {
    if (Array.isArray(type)) {
      const len = type.length;
      const keys = new Array(len);
      for (let i = 0; i < len; ++i) {
        keys[i] = listen(this, type[i], listener);
      }
      return keys;
    }
    return listen(
      this,
      /** @type {string} */
      type,
      listener
    );
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(type, listener) {
    let key;
    if (Array.isArray(type)) {
      const len = type.length;
      key = new Array(len);
      for (let i = 0; i < len; ++i) {
        key[i] = listenOnce(this, type[i], listener);
      }
    } else {
      key = listenOnce(
        this,
        /** @type {string} */
        type,
        listener
      );
    }
    listener.ol_key = key;
    return key;
  }
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(type, listener) {
    const key = (
      /** @type {Object} */
      listener.ol_key
    );
    if (key) {
      unByKey(key);
    } else if (Array.isArray(type)) {
      for (let i = 0, ii = type.length; i < ii; ++i) {
        this.removeEventListener(type[i], listener);
      }
    } else {
      this.removeEventListener(type, listener);
    }
  }
};
Observable.prototype.on;
Observable.prototype.once;
Observable.prototype.un;
function unByKey(key) {
  if (Array.isArray(key)) {
    for (let i = 0, ii = key.length; i < ii; ++i) {
      unlistenByKey(key[i]);
    }
  } else {
    unlistenByKey(
      /** @type {import("./events.js").EventsKey} */
      key
    );
  }
}
var Observable_default = Observable;

// node_modules/ol/util.js
function abstract() {
  throw new Error("Unimplemented abstract method.");
}
var uidCounter_ = 0;
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}

// node_modules/ol/Object.js
var ObjectEvent = class extends Event_default {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(type, key, oldValue) {
    super(type);
    this.key = key;
    this.oldValue = oldValue;
  }
};
var BaseObject = class extends Observable_default {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(values) {
    super();
    this.on;
    this.once;
    this.un;
    getUid(this);
    this.values_ = null;
    if (values !== void 0) {
      this.setProperties(values);
    }
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(key) {
    let value;
    if (this.values_ && this.values_.hasOwnProperty(key)) {
      value = this.values_[key];
    }
    return value;
  }
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return this.values_ && Object.keys(this.values_) || [];
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return this.values_ && Object.assign({}, this.values_) || {};
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.values_;
  }
  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(key, oldValue) {
    let eventType;
    eventType = `change:${key}`;
    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
    eventType = ObjectEventType_default.PROPERTYCHANGE;
    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(key, listener) {
    this.addEventListener(`change:${key}`, listener);
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(key, listener) {
    this.removeEventListener(`change:${key}`, listener);
  }
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(key, value, silent) {
    const values = this.values_ || (this.values_ = {});
    if (silent) {
      values[key] = value;
    } else {
      const oldValue = values[key];
      values[key] = value;
      if (oldValue !== value) {
        this.notify(key, oldValue);
      }
    }
  }
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(values, silent) {
    for (const key in values) {
      this.set(key, values[key], silent);
    }
  }
  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(source) {
    if (!source.values_) {
      return;
    }
    Object.assign(this.values_ || (this.values_ = {}), source.values_);
  }
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(key, silent) {
    if (this.values_ && key in this.values_) {
      const oldValue = this.values_[key];
      delete this.values_[key];
      if (isEmpty(this.values_)) {
        this.values_ = null;
      }
      if (!silent) {
        this.notify(key, oldValue);
      }
    }
  }
};
var Object_default = BaseObject;

// node_modules/ol/Collection.js
var Property = {
  LENGTH: "length"
};
var CollectionEvent = class extends Event_default {
  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */
  constructor(type, element, index) {
    super(type);
    this.element = element;
    this.index = index;
  }
};
var Collection = class extends Object_default {
  /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */
  constructor(array, options) {
    super();
    this.on;
    this.once;
    this.un;
    options = options || {};
    this.unique_ = !!options.unique;
    this.array_ = array ? array : [];
    if (this.unique_) {
      for (let i = 0, ii = this.array_.length; i < ii; ++i) {
        this.assertUnique_(this.array_[i], i);
      }
    }
    this.updateLength_();
  }
  /**
   * Remove all elements from the collection.
   * @api
   */
  clear() {
    while (this.getLength() > 0) {
      this.pop();
    }
  }
  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */
  extend(arr) {
    for (let i = 0, ii = arr.length; i < ii; ++i) {
      this.push(arr[i]);
    }
    return this;
  }
  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  forEach(f) {
    const array = this.array_;
    for (let i = 0, ii = array.length; i < ii; ++i) {
      f(array[i], i, array);
    }
  }
  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */
  getArray() {
    return this.array_;
  }
  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  item(index) {
    return this.array_[index];
  }
  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  getLength() {
    return this.get(Property.LENGTH);
  }
  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  insertAt(index, elem) {
    if (index < 0 || index > this.getLength()) {
      throw new Error("Index out of bounds: " + index);
    }
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    this.array_.splice(index, 0, elem);
    this.updateLength_();
    this.dispatchEvent(
      new CollectionEvent(CollectionEventType_default.ADD, elem, index)
    );
  }
  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  pop() {
    return this.removeAt(this.getLength() - 1);
  }
  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  push(elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    const n = this.getLength();
    this.insertAt(n, elem);
    return this.getLength();
  }
  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  remove(elem) {
    const arr = this.array_;
    for (let i = 0, ii = arr.length; i < ii; ++i) {
      if (arr[i] === elem) {
        return this.removeAt(i);
      }
    }
    return void 0;
  }
  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  removeAt(index) {
    if (index < 0 || index >= this.getLength()) {
      return void 0;
    }
    const prev = this.array_[index];
    this.array_.splice(index, 1);
    this.updateLength_();
    this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new CollectionEvent(CollectionEventType_default.REMOVE, prev, index)
    );
    return prev;
  }
  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  setAt(index, elem) {
    const n = this.getLength();
    if (index >= n) {
      this.insertAt(index, elem);
      return;
    }
    if (index < 0) {
      throw new Error("Index out of bounds: " + index);
    }
    if (this.unique_) {
      this.assertUnique_(elem, index);
    }
    const prev = this.array_[index];
    this.array_[index] = elem;
    this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new CollectionEvent(CollectionEventType_default.REMOVE, prev, index)
    );
    this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new CollectionEvent(CollectionEventType_default.ADD, elem, index)
    );
  }
  /**
   * @private
   */
  updateLength_() {
    this.set(Property.LENGTH, this.array_.length);
  }
  /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */
  assertUnique_(elem, except) {
    for (let i = 0, ii = this.array_.length; i < ii; ++i) {
      if (this.array_[i] === elem && i !== except) {
        throw new Error("Duplicate item added to a unique collection");
      }
    }
  }
};
var Collection_default = Collection;

// node_modules/ol/MapEvent.js
var MapEvent = class extends Event_default {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  constructor(type, map, frameState) {
    super(type);
    this.map = map;
    this.frameState = frameState !== void 0 ? frameState : null;
  }
};
var MapEvent_default = MapEvent;

// node_modules/ol/MapBrowserEvent.js
var MapBrowserEvent = class extends MapEvent_default {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  constructor(type, map, originalEvent, dragging, frameState, activePointers) {
    super(type, map, frameState);
    this.originalEvent = originalEvent;
    this.pixel_ = null;
    this.coordinate_ = null;
    this.dragging = dragging !== void 0 ? dragging : false;
    this.activePointers = activePointers;
  }
  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */
  get pixel() {
    if (!this.pixel_) {
      this.pixel_ = this.map.getEventPixel(this.originalEvent);
    }
    return this.pixel_;
  }
  set pixel(pixel) {
    this.pixel_ = pixel;
  }
  /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */
  get coordinate() {
    if (!this.coordinate_) {
      this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
    }
    return this.coordinate_;
  }
  set coordinate(coordinate) {
    this.coordinate_ = coordinate;
  }
  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   * @override
   */
  preventDefault() {
    super.preventDefault();
    if ("preventDefault" in this.originalEvent) {
      this.originalEvent.preventDefault();
    }
  }
  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   * @override
   */
  stopPropagation() {
    super.stopPropagation();
    if ("stopPropagation" in this.originalEvent) {
      this.originalEvent.stopPropagation();
    }
  }
};
var MapBrowserEvent_default = MapBrowserEvent;

// node_modules/ol/MapBrowserEventType.js
var MapBrowserEventType_default = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: "singleclick",
  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: EventType_default.CLICK,
  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: EventType_default.DBLCLICK,
  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: "pointerdrag",
  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};

// node_modules/ol/has.js
var ua = typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined" ? navigator.userAgent.toLowerCase() : "";
var SAFARI = ua.includes("safari") && !ua.includes("chrom");
var SAFARI_BUG_237906 = SAFARI && (ua.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(ua));
var WEBKIT = ua.includes("webkit") && !ua.includes("edge");
var MAC = ua.includes("macintosh");
var DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== "undefined" ? devicePixelRatio : 1;
var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== "undefined" && typeof OffscreenCanvas !== "undefined" && self instanceof WorkerGlobalScope;
var IMAGE_DECODE = typeof Image !== "undefined" && Image.prototype.decode;
var PASSIVE_EVENT_LISTENERS = function() {
  let passive = false;
  try {
    const options = Object.defineProperty({}, "passive", {
      get: function() {
        passive = true;
      }
    });
    window.addEventListener("_", null, options);
    window.removeEventListener("_", null, options);
  } catch {
  }
  return passive;
}();

// node_modules/ol/pointer/EventType.js
var EventType_default2 = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};

// node_modules/ol/MapBrowserEventHandler.js
var MapBrowserEventHandler = class extends Target_default {
  /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */
  constructor(map, moveTolerance) {
    super(map);
    this.map_ = map;
    this.clickTimeoutId_;
    this.emulateClicks_ = false;
    this.dragging_ = false;
    this.dragListenerKeys_ = [];
    this.moveTolerance_ = moveTolerance === void 0 ? 1 : moveTolerance;
    this.down_ = null;
    const element = this.map_.getViewport();
    this.activePointers_ = [];
    this.trackedTouches_ = {};
    this.element_ = element;
    this.pointerdownListenerKey_ = listen(
      element,
      EventType_default2.POINTERDOWN,
      this.handlePointerDown_,
      this
    );
    this.originalPointerMoveEvent_;
    this.relayedListenerKey_ = listen(
      element,
      EventType_default2.POINTERMOVE,
      this.relayMoveEvent_,
      this
    );
    this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this);
    this.element_.addEventListener(
      EventType_default.TOUCHMOVE,
      this.boundHandleTouchMove_,
      PASSIVE_EVENT_LISTENERS ? { passive: false } : false
    );
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  emulateClick_(pointerEvent) {
    let newEvent = new MapBrowserEvent_default(
      MapBrowserEventType_default.CLICK,
      this.map_,
      pointerEvent
    );
    this.dispatchEvent(newEvent);
    if (this.clickTimeoutId_ !== void 0) {
      clearTimeout(this.clickTimeoutId_);
      this.clickTimeoutId_ = void 0;
      newEvent = new MapBrowserEvent_default(
        MapBrowserEventType_default.DBLCLICK,
        this.map_,
        pointerEvent
      );
      this.dispatchEvent(newEvent);
    } else {
      this.clickTimeoutId_ = setTimeout(() => {
        this.clickTimeoutId_ = void 0;
        const newEvent2 = new MapBrowserEvent_default(
          MapBrowserEventType_default.SINGLECLICK,
          this.map_,
          pointerEvent
        );
        this.dispatchEvent(newEvent2);
      }, 250);
    }
  }
  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  updateActivePointers_(pointerEvent) {
    const event = pointerEvent;
    const id = event.pointerId;
    if (event.type == MapBrowserEventType_default.POINTERUP || event.type == MapBrowserEventType_default.POINTERCANCEL) {
      delete this.trackedTouches_[id];
      for (const pointerId in this.trackedTouches_) {
        if (this.trackedTouches_[pointerId].target !== event.target) {
          delete this.trackedTouches_[pointerId];
          break;
        }
      }
    } else if (event.type == MapBrowserEventType_default.POINTERDOWN || event.type == MapBrowserEventType_default.POINTERMOVE) {
      this.trackedTouches_[id] = event;
    }
    this.activePointers_ = Object.values(this.trackedTouches_);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerUp_(pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    const newEvent = new MapBrowserEvent_default(
      MapBrowserEventType_default.POINTERUP,
      this.map_,
      pointerEvent,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(newEvent);
    if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
      this.emulateClick_(this.down_);
    }
    if (this.activePointers_.length === 0) {
      this.dragListenerKeys_.forEach(unlistenByKey);
      this.dragListenerKeys_.length = 0;
      this.dragging_ = false;
      this.down_ = null;
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  isMouseActionButton_(pointerEvent) {
    return pointerEvent.button === 0;
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerDown_(pointerEvent) {
    this.emulateClicks_ = this.activePointers_.length === 0;
    this.updateActivePointers_(pointerEvent);
    const newEvent = new MapBrowserEvent_default(
      MapBrowserEventType_default.POINTERDOWN,
      this.map_,
      pointerEvent,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(newEvent);
    this.down_ = new PointerEvent(pointerEvent.type, pointerEvent);
    Object.defineProperty(this.down_, "target", {
      writable: false,
      value: pointerEvent.target
    });
    if (this.dragListenerKeys_.length === 0) {
      const doc = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        listen(
          doc,
          MapBrowserEventType_default.POINTERMOVE,
          this.handlePointerMove_,
          this
        ),
        listen(doc, MapBrowserEventType_default.POINTERUP, this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        listen(
          this.element_,
          MapBrowserEventType_default.POINTERCANCEL,
          this.handlePointerUp_,
          this
        )
      );
      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
        this.dragListenerKeys_.push(
          listen(
            this.element_.getRootNode(),
            MapBrowserEventType_default.POINTERUP,
            this.handlePointerUp_,
            this
          )
        );
      }
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerMove_(pointerEvent) {
    if (this.isMoving_(pointerEvent)) {
      this.updateActivePointers_(pointerEvent);
      this.dragging_ = true;
      const newEvent = new MapBrowserEvent_default(
        MapBrowserEventType_default.POINTERDRAG,
        this.map_,
        pointerEvent,
        this.dragging_,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(newEvent);
    }
  }
  /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  relayMoveEvent_(pointerEvent) {
    this.originalPointerMoveEvent_ = pointerEvent;
    const dragging = !!(this.down_ && this.isMoving_(pointerEvent));
    this.dispatchEvent(
      new MapBrowserEvent_default(
        MapBrowserEventType_default.POINTERMOVE,
        this.map_,
        pointerEvent,
        dragging
      )
    );
  }
  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */
  handleTouchMove_(event) {
    const originalEvent = this.originalPointerMoveEvent_;
    if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== "boolean" || event.cancelable === true)) {
      event.preventDefault();
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  isMoving_(pointerEvent) {
    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    if (this.relayedListenerKey_) {
      unlistenByKey(this.relayedListenerKey_);
      this.relayedListenerKey_ = null;
    }
    this.element_.removeEventListener(
      EventType_default.TOUCHMOVE,
      this.boundHandleTouchMove_
    );
    if (this.pointerdownListenerKey_) {
      unlistenByKey(this.pointerdownListenerKey_);
      this.pointerdownListenerKey_ = null;
    }
    this.dragListenerKeys_.forEach(unlistenByKey);
    this.dragListenerKeys_.length = 0;
    this.element_ = null;
    super.disposeInternal();
  }
};
var MapBrowserEventHandler_default = MapBrowserEventHandler;

// node_modules/ol/MapEventType.js
var MapEventType_default = {
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: "movestart",
  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: "moveend",
  /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */
  LOADSTART: "loadstart",
  /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */
  LOADEND: "loadend"
};

// node_modules/ol/MapProperty.js
var MapProperty_default = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
};

// node_modules/ol/TileState.js
var TileState_default = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
};

// node_modules/ol/asserts.js
function assert(assertion, errorMessage) {
  if (!assertion) {
    throw new Error(errorMessage);
  }
}

// node_modules/ol/structs/PriorityQueue.js
var DROP = Infinity;
var PriorityQueue = class {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  constructor(priorityFunction, keyFunction) {
    this.priorityFunction_ = priorityFunction;
    this.keyFunction_ = keyFunction;
    this.elements_ = [];
    this.priorities_ = [];
    this.queuedElements_ = {};
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.elements_.length = 0;
    this.priorities_.length = 0;
    clear(this.queuedElements_);
  }
  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */
  dequeue() {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const element = elements[0];
    if (elements.length == 1) {
      elements.length = 0;
      priorities.length = 0;
    } else {
      elements[0] = /** @type {T} */
      elements.pop();
      priorities[0] = /** @type {number} */
      priorities.pop();
      this.siftUp_(0);
    }
    const elementKey = this.keyFunction_(element);
    delete this.queuedElements_[elementKey];
    return element;
  }
  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(element) {
    assert(
      !(this.keyFunction_(element) in this.queuedElements_),
      "Tried to enqueue an `element` that was already added to the queue"
    );
    const priority = this.priorityFunction_(element);
    if (priority != DROP) {
      this.elements_.push(element);
      this.priorities_.push(priority);
      this.queuedElements_[this.keyFunction_(element)] = true;
      this.siftDown_(0, this.elements_.length - 1);
      return true;
    }
    return false;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.elements_.length;
  }
  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */
  getLeftChildIndex_(index) {
    return index * 2 + 1;
  }
  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */
  getRightChildIndex_(index) {
    return index * 2 + 2;
  }
  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */
  getParentIndex_(index) {
    return index - 1 >> 1;
  }
  /**
   * Make this a heap. O(N).
   * @private
   */
  heapify_() {
    let i;
    for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
      this.siftUp_(i);
    }
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.elements_.length === 0;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */
  isKeyQueued(key) {
    return key in this.queuedElements_;
  }
  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */
  isQueued(element) {
    return this.isKeyQueued(this.keyFunction_(element));
  }
  /**
   * @param {number} index The index of the node to move down.
   * @private
   */
  siftUp_(index) {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const count = elements.length;
    const element = elements[index];
    const priority = priorities[index];
    const startIndex = index;
    while (index < count >> 1) {
      const lIndex = this.getLeftChildIndex_(index);
      const rIndex = this.getRightChildIndex_(index);
      const smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
      elements[index] = elements[smallerChildIndex];
      priorities[index] = priorities[smallerChildIndex];
      index = smallerChildIndex;
    }
    elements[index] = element;
    priorities[index] = priority;
    this.siftDown_(startIndex, index);
  }
  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */
  siftDown_(startIndex, index) {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const element = elements[index];
    const priority = priorities[index];
    while (index > startIndex) {
      const parentIndex = this.getParentIndex_(index);
      if (priorities[parentIndex] > priority) {
        elements[index] = elements[parentIndex];
        priorities[index] = priorities[parentIndex];
        index = parentIndex;
      } else {
        break;
      }
    }
    elements[index] = element;
    priorities[index] = priority;
  }
  /**
   * FIXME empty description for jsdoc
   */
  reprioritize() {
    const priorityFunction = this.priorityFunction_;
    const elements = this.elements_;
    const priorities = this.priorities_;
    let index = 0;
    const n = elements.length;
    let element, i, priority;
    for (i = 0; i < n; ++i) {
      element = elements[i];
      priority = priorityFunction(element);
      if (priority == DROP) {
        delete this.queuedElements_[this.keyFunction_(element)];
      } else {
        priorities[index] = priority;
        elements[index++] = element;
      }
    }
    elements.length = index;
    priorities.length = index;
    this.heapify_();
  }
};
var PriorityQueue_default = PriorityQueue;

// node_modules/ol/TileQueue.js
var TileQueue = class extends PriorityQueue_default {
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */
  constructor(tilePriorityFunction, tileChangeCallback) {
    super(
      (element) => tilePriorityFunction.apply(null, element),
      (element) => element[0].getKey()
    );
    this.boundHandleTileChange_ = this.handleTileChange.bind(this);
    this.tileChangeCallback_ = tileChangeCallback;
    this.tilesLoading_ = 0;
    this.tilesLoadingKeys_ = {};
  }
  /**
   * @param {TileQueueElement} element Element.
   * @return {boolean} The element was added to the queue.
   * @override
   */
  enqueue(element) {
    const added = super.enqueue(element);
    if (added) {
      const tile = element[0];
      tile.addEventListener(EventType_default.CHANGE, this.boundHandleTileChange_);
    }
    return added;
  }
  /**
   * @return {number} Number of tiles loading.
   */
  getTilesLoading() {
    return this.tilesLoading_;
  }
  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(event) {
    const tile = (
      /** @type {import("./Tile.js").default} */
      event.target
    );
    const state = tile.getState();
    if (state === TileState_default.LOADED || state === TileState_default.ERROR || state === TileState_default.EMPTY) {
      if (state !== TileState_default.ERROR) {
        tile.removeEventListener(EventType_default.CHANGE, this.boundHandleTileChange_);
      }
      const tileKey = tile.getKey();
      if (tileKey in this.tilesLoadingKeys_) {
        delete this.tilesLoadingKeys_[tileKey];
        --this.tilesLoading_;
      }
      this.tileChangeCallback_();
    }
  }
  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  loadMoreTiles(maxTotalLoading, maxNewLoads) {
    let newLoads = 0;
    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
      const tile = this.dequeue()[0];
      const tileKey = tile.getKey();
      const state = tile.getState();
      if (state === TileState_default.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
        this.tilesLoadingKeys_[tileKey] = true;
        ++this.tilesLoading_;
        ++newLoads;
        tile.load();
      }
    }
  }
};
var TileQueue_default = TileQueue;
function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return DROP;
  }
  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
    return DROP;
  }
  const center = frameState.viewState.center;
  const deltaX = tileCenter[0] - center[0];
  const deltaY = tileCenter[1] - center[1];
  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
}

// node_modules/ol/ViewHint.js
var ViewHint_default = {
  ANIMATING: 0,
  INTERACTING: 1
};

// node_modules/ol/ViewProperty.js
var ViewProperty_default = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
};

// node_modules/ol/math.js
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return squaredDistance(x, y, x1, y1);
}
function squaredDistance(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return dx * dx + dy * dy;
}
function solveLinearSystem(mat) {
  const n = mat.length;
  for (let i = 0; i < n; i++) {
    let maxRow = i;
    let maxEl = Math.abs(mat[i][i]);
    for (let r = i + 1; r < n; r++) {
      const absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }
    if (maxEl === 0) {
      return null;
    }
    const tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;
    for (let j = i + 1; j < n; j++) {
      const coef = -mat[j][i] / mat[i][i];
      for (let k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }
  const x = new Array(n);
  for (let l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (let m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
}
function toDegrees(angleInRadians) {
  return angleInRadians * 180 / Math.PI;
}
function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}
function modulo(a, b) {
  const r = a % b;
  return r * b < 0 ? r + b : r;
}
function lerp(a, b, x) {
  return a + x * (b - a);
}
function toFixed(n, decimals) {
  const factor = Math.pow(10, decimals);
  return Math.round(n * factor) / factor;
}
function round(n, decimals) {
  return Math.round(toFixed(n, decimals));
}
function floor(n, decimals) {
  return Math.floor(toFixed(n, decimals));
}
function ceil(n, decimals) {
  return Math.ceil(toFixed(n, decimals));
}
function wrap(n, min, max) {
  if (n >= min && n < max) {
    return n;
  }
  const range = max - min;
  return ((n - min) % range + range) % range + min;
}

// node_modules/ol/centerconstraint.js
function createExtent(extent, onlyCenter, smooth) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(center, resolution, size, isMoving, centerShift) {
      if (!center) {
        return void 0;
      }
      if (!resolution && !onlyCenter) {
        return center;
      }
      const viewWidth = onlyCenter ? 0 : size[0] * resolution;
      const viewHeight = onlyCenter ? 0 : size[1] * resolution;
      const shiftX = centerShift ? centerShift[0] : 0;
      const shiftY = centerShift ? centerShift[1] : 0;
      let minX = extent[0] + viewWidth / 2 + shiftX;
      let maxX = extent[2] - viewWidth / 2 + shiftX;
      let minY = extent[1] + viewHeight / 2 + shiftY;
      let maxY = extent[3] - viewHeight / 2 + shiftY;
      if (minX > maxX) {
        minX = (maxX + minX) / 2;
        maxX = minX;
      }
      if (minY > maxY) {
        minY = (maxY + minY) / 2;
        maxY = minY;
      }
      let x = clamp(center[0], minX, maxX);
      let y = clamp(center[1], minY, maxY);
      if (isMoving && smooth && resolution) {
        const ratio = 30 * resolution;
        x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
        y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
      }
      return [x, y];
    }
  );
}
function none(center) {
  return center;
}

// node_modules/ol/extent/Relationship.js
var Relationship_default = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};

// node_modules/ol/extent.js
function boundingExtent(coordinates2) {
  const extent = createEmpty();
  for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates2[i]);
  }
  return extent;
}
function _boundingExtentXYs(xs, ys, dest) {
  const minX = Math.min.apply(null, xs);
  const minY = Math.min.apply(null, ys);
  const maxX = Math.max.apply(null, xs);
  const maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, dest);
}
function buffer(extent, value, dest) {
  if (dest) {
    dest[0] = extent[0] - value;
    dest[1] = extent[1] - value;
    dest[2] = extent[2] + value;
    dest[3] = extent[3] + value;
    return dest;
  }
  return [
    extent[0] - value,
    extent[1] - value,
    extent[2] + value,
    extent[3] + value
  ];
}
function clone(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent.slice();
}
function closestSquaredDistanceXY(extent, x, y) {
  let dx, dy;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}
function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}
function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}
function coordinateRelationship(extent, coordinate) {
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const x = coordinate[0];
  const y = coordinate[1];
  let relationship = Relationship_default.UNKNOWN;
  if (x < minX) {
    relationship = relationship | Relationship_default.LEFT;
  } else if (x > maxX) {
    relationship = relationship | Relationship_default.RIGHT;
  }
  if (y < minY) {
    relationship = relationship | Relationship_default.BELOW;
  } else if (y > maxY) {
    relationship = relationship | Relationship_default.ABOVE;
  }
  if (relationship === Relationship_default.UNKNOWN) {
    relationship = Relationship_default.INTERSECTING;
  }
  return relationship;
}
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}
function createOrUpdate(minX, minY, maxX, maxY, dest) {
  if (dest) {
    dest[0] = minX;
    dest[1] = minY;
    dest[2] = maxX;
    dest[3] = maxY;
    return dest;
  }
  return [minX, minY, maxX, maxY];
}
function createOrUpdateEmpty(dest) {
  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);
}
function createOrUpdateFromCoordinate(coordinate, dest) {
  const x = coordinate[0];
  const y = coordinate[1];
  return createOrUpdate(x, y, x, y, dest);
}
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, dest) {
  const extent = createOrUpdateEmpty(dest);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}
function equals2(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
function extend2(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}
function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent;
}
function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}
function forEachCorner(extent, callback) {
  let val;
  val = callback(getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback(getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
}
function getArea(extent) {
  let area = 0;
  if (!isEmpty2(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }
  return area;
}
function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}
function getBottomRight(extent) {
  return [extent[2], extent[1]];
}
function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}
function getCorner(extent, corner) {
  let coordinate;
  if (corner === "bottom-left") {
    coordinate = getBottomLeft(extent);
  } else if (corner === "bottom-right") {
    coordinate = getBottomRight(extent);
  } else if (corner === "top-left") {
    coordinate = getTopLeft(extent);
  } else if (corner === "top-right") {
    coordinate = getTopRight(extent);
  } else {
    throw new Error("Invalid corner");
  }
  return coordinate;
}
function getForViewAndSize(center, resolution, rotation, size, dest) {
  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(
    center,
    resolution,
    rotation,
    size
  );
  return createOrUpdate(
    Math.min(x0, x1, x2, x3),
    Math.min(y0, y1, y2, y3),
    Math.max(x0, x1, x2, x3),
    Math.max(y0, y1, y2, y3),
    dest
  );
}
function getRotatedViewport(center, resolution, rotation, size) {
  const dx = resolution * size[0] / 2;
  const dy = resolution * size[1] / 2;
  const cosRotation = Math.cos(rotation);
  const sinRotation = Math.sin(rotation);
  const xCos = dx * cosRotation;
  const xSin = dx * sinRotation;
  const yCos = dy * cosRotation;
  const ySin = dy * sinRotation;
  const x = center[0];
  const y = center[1];
  return [
    x - xCos + ySin,
    y - xSin - yCos,
    x - xCos - ySin,
    y - xSin + yCos,
    x + xCos - ySin,
    y + xSin + yCos,
    x + xCos + ySin,
    y + xSin - yCos,
    x - xCos + ySin,
    y - xSin - yCos
  ];
}
function getHeight(extent) {
  return extent[3] - extent[1];
}
function getIntersection(extent1, extent2, dest) {
  const intersection = dest ? dest : createEmpty();
  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}
function getTopLeft(extent) {
  return [extent[0], extent[3]];
}
function getTopRight(extent) {
  return [extent[2], extent[3]];
}
function getWidth(extent) {
  return extent[2] - extent[0];
}
function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
function isEmpty2(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}
function returnOrUpdate(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent;
}
function intersectsSegment(extent, start, end) {
  let intersects3 = false;
  const startRel = coordinateRelationship(extent, start);
  const endRel = coordinateRelationship(extent, end);
  if (startRel === Relationship_default.INTERSECTING || endRel === Relationship_default.INTERSECTING) {
    intersects3 = true;
  } else {
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const startX = start[0];
    const startY = start[1];
    const endX = end[0];
    const endY = end[1];
    const slope = (endY - startY) / (endX - startX);
    let x, y;
    if (!!(endRel & Relationship_default.ABOVE) && !(startRel & Relationship_default.ABOVE)) {
      x = endX - (endY - maxY) / slope;
      intersects3 = x >= minX && x <= maxX;
    }
    if (!intersects3 && !!(endRel & Relationship_default.RIGHT) && !(startRel & Relationship_default.RIGHT)) {
      y = endY - (endX - maxX) * slope;
      intersects3 = y >= minY && y <= maxY;
    }
    if (!intersects3 && !!(endRel & Relationship_default.BELOW) && !(startRel & Relationship_default.BELOW)) {
      x = endX - (endY - minY) / slope;
      intersects3 = x >= minX && x <= maxX;
    }
    if (!intersects3 && !!(endRel & Relationship_default.LEFT) && !(startRel & Relationship_default.LEFT)) {
      y = endY - (endX - minX) * slope;
      intersects3 = y >= minY && y <= maxY;
    }
  }
  return intersects3;
}
function applyTransform(extent, transformFn, dest, stops) {
  if (isEmpty2(extent)) {
    return createOrUpdateEmpty(dest);
  }
  let coordinates2 = [];
  if (stops > 1) {
    const width = extent[2] - extent[0];
    const height = extent[3] - extent[1];
    for (let i = 0; i < stops; ++i) {
      coordinates2.push(
        extent[0] + width * i / stops,
        extent[1],
        extent[2],
        extent[1] + height * i / stops,
        extent[2] - width * i / stops,
        extent[3],
        extent[0],
        extent[3] - height * i / stops
      );
    }
  } else {
    coordinates2 = [
      extent[0],
      extent[1],
      extent[2],
      extent[1],
      extent[2],
      extent[3],
      extent[0],
      extent[3]
    ];
  }
  transformFn(coordinates2, coordinates2, 2);
  const xs = [];
  const ys = [];
  for (let i = 0, l = coordinates2.length; i < l; i += 2) {
    xs.push(coordinates2[i]);
    ys.push(coordinates2[i + 1]);
  }
  return _boundingExtentXYs(xs, ys, dest);
}
function wrapX(extent, projection) {
  const projectionExtent = projection.getExtent();
  const center = getCenter(extent);
  if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.floor(
      (center[0] - projectionExtent[0]) / worldWidth
    );
    const offset = worldsAway * worldWidth;
    extent[0] -= offset;
    extent[2] -= offset;
  }
  return extent;
}
function wrapAndSliceX(extent, projection, multiWorld) {
  if (projection.canWrapX()) {
    const projectionExtent = projection.getExtent();
    if (!isFinite(extent[0]) || !isFinite(extent[2])) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    wrapX(extent, projection);
    const worldWidth = getWidth(projectionExtent);
    if (getWidth(extent) > worldWidth && !multiWorld) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    if (extent[0] < projectionExtent[0]) {
      return [
        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2], extent[3]]
      ];
    }
    if (extent[2] > projectionExtent[2]) {
      return [
        [extent[0], extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]]
      ];
    }
  }
  return [extent];
}

// node_modules/ol/string.js
function compareVersions(v1, v2) {
  const s1 = ("" + v1).split(".");
  const s2 = ("" + v2).split(".");
  for (let i = 0; i < Math.max(s1.length, s2.length); i++) {
    const n1 = parseInt(s1[i] || "0", 10);
    const n2 = parseInt(s2[i] || "0", 10);
    if (n1 > n2) {
      return 1;
    }
    if (n2 > n1) {
      return -1;
    }
  }
  return 0;
}

// node_modules/ol/coordinate.js
function add(coordinate, delta) {
  coordinate[0] += +delta[0];
  coordinate[1] += +delta[1];
  return coordinate;
}
function equals3(coordinate1, coordinate2) {
  let equals4 = true;
  for (let i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals4 = false;
      break;
    }
  }
  return equals4;
}
function rotate(coordinate, angle) {
  const cosAngle = Math.cos(angle);
  const sinAngle = Math.sin(angle);
  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
}
function scale(coordinate, scale4) {
  coordinate[0] *= scale4;
  coordinate[1] *= scale4;
  return coordinate;
}
function wrapX2(coordinate, projection) {
  if (projection.canWrapX()) {
    const worldWidth = getWidth(projection.getExtent());
    const worldsAway = getWorldsAway(coordinate, projection, worldWidth);
    if (worldsAway) {
      coordinate[0] -= worldsAway * worldWidth;
    }
  }
  return coordinate;
}
function getWorldsAway(coordinate, projection, sourceExtentWidth) {
  const projectionExtent = projection.getExtent();
  let worldsAway = 0;
  if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
    sourceExtentWidth = sourceExtentWidth || getWidth(projectionExtent);
    worldsAway = Math.floor(
      (coordinate[0] - projectionExtent[0]) / sourceExtentWidth
    );
  }
  return worldsAway;
}

// node_modules/ol/easing.js
function easeIn(t) {
  return Math.pow(t, 3);
}
function easeOut(t) {
  return 1 - easeIn(1 - t);
}
function inAndOut(t) {
  return 3 * t * t - 2 * t * t * t;
}
function linear(t) {
  return t;
}

// node_modules/ol/sphere.js
var DEFAULT_RADIUS = 63710088e-1;
function getDistance(c1, c2, radius) {
  radius = radius || DEFAULT_RADIUS;
  const lat1 = toRadians(c1[1]);
  const lat2 = toRadians(c2[1]);
  const deltaLatBy2 = (lat2 - lat1) / 2;
  const deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;
  const a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

// node_modules/ol/console.js
var levels = {
  info: 1,
  warn: 2,
  error: 3,
  none: 4
};
var level = levels.info;
function warn(...args) {
  if (level > levels.warn) {
    return;
  }
  console.warn(...args);
}

// node_modules/ol/proj/Units.js
var METERS_PER_UNIT = {
  // use the radius of the Normal sphere
  "radians": 6370997 / (2 * Math.PI),
  "degrees": 2 * Math.PI * 6370997 / 360,
  "ft": 0.3048,
  "m": 1,
  "us-ft": 1200 / 3937
};

// node_modules/ol/proj/Projection.js
var Projection = class {
  /**
   * @param {Options} options Projection options.
   */
  constructor(options) {
    this.code_ = options.code;
    this.units_ = /** @type {import("./Units.js").Units} */
    options.units;
    this.extent_ = options.extent !== void 0 ? options.extent : null;
    this.worldExtent_ = options.worldExtent !== void 0 ? options.worldExtent : null;
    this.axisOrientation_ = options.axisOrientation !== void 0 ? options.axisOrientation : "enu";
    this.global_ = options.global !== void 0 ? options.global : false;
    this.canWrapX_ = !!(this.global_ && this.extent_);
    this.getPointResolutionFunc_ = options.getPointResolution;
    this.defaultTileGrid_ = null;
    this.metersPerUnit_ = options.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];
  }
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(global) {
    this.global_ = global;
    this.canWrapX_ = !!(global && this.extent_);
  }
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(tileGrid) {
    this.defaultTileGrid_ = tileGrid;
  }
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(extent) {
    this.extent_ = extent;
    this.canWrapX_ = !!(this.global_ && extent);
  }
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(worldExtent) {
    this.worldExtent_ = worldExtent;
  }
  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(func) {
    this.getPointResolutionFunc_ = func;
  }
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {GetPointResolution|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
};
var Projection_default = Projection;

// node_modules/ol/proj/epsg3857.js
var RADIUS = 6378137;
var HALF_SIZE = Math.PI * RADIUS;
var EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
var WORLD_EXTENT = [-180, -85, 180, 85];
var MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
var EPSG3857Projection = class extends Projection_default {
  /**
   * @param {string} code Code.
   */
  constructor(code) {
    super({
      code,
      units: "m",
      extent: EXTENT,
      global: true,
      worldExtent: WORLD_EXTENT,
      getPointResolution: function(resolution, point) {
        return resolution / Math.cosh(point[1] / RADIUS);
      }
    });
  }
};
var PROJECTIONS = [
  new EPSG3857Projection("EPSG:3857"),
  new EPSG3857Projection("EPSG:102100"),
  new EPSG3857Projection("EPSG:102113"),
  new EPSG3857Projection("EPSG:900913"),
  new EPSG3857Projection("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new EPSG3857Projection("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function fromEPSG4326(input, output, dimension, stride) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  stride = stride ?? dimension;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += stride) {
    output[i] = HALF_SIZE * input[i] / 180;
    let y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));
    if (y > MAX_SAFE_Y) {
      y = MAX_SAFE_Y;
    } else if (y < -MAX_SAFE_Y) {
      y = -MAX_SAFE_Y;
    }
    output[i + 1] = y;
  }
  return output;
}
function toEPSG4326(input, output, dimension, stride) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  stride = stride ?? dimension;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += stride) {
    output[i] = 180 * input[i] / HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
  }
  return output;
}

// node_modules/ol/proj/epsg4326.js
var RADIUS2 = 6378137;
var EXTENT2 = [-180, -90, 180, 90];
var METERS_PER_UNIT2 = Math.PI * RADIUS2 / 180;
var EPSG4326Projection = class extends Projection_default {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(code, axisOrientation) {
    super({
      code,
      units: "degrees",
      extent: EXTENT2,
      axisOrientation,
      global: true,
      metersPerUnit: METERS_PER_UNIT2,
      worldExtent: EXTENT2
    });
  }
};
var PROJECTIONS2 = [
  new EPSG4326Projection("CRS:84"),
  new EPSG4326Projection("EPSG:4326", "neu"),
  new EPSG4326Projection("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new EPSG4326Projection("urn:ogc:def:crs:OGC:2:84"),
  new EPSG4326Projection("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new EPSG4326Projection("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new EPSG4326Projection("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];

// node_modules/ol/proj/projections.js
var cache = {};
function get(code) {
  return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function add2(code, projection) {
  cache[code] = projection;
}

// node_modules/ol/proj/transforms.js
var transforms = {};
function add3(source, destination, transformFn) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}
function get2(sourceCode, destinationCode) {
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    return transforms[sourceCode][destinationCode];
  }
  return null;
}

// node_modules/ol/proj/utm.js
var K0 = 0.9996;
var E = 669438e-8;
var E2 = E * E;
var E3 = E2 * E;
var E_P2 = E / (1 - E);
var SQRT_E = Math.sqrt(1 - E);
var _E = (1 - SQRT_E) / (1 + SQRT_E);
var _E2 = _E * _E;
var _E3 = _E2 * _E;
var _E4 = _E3 * _E;
var _E5 = _E4 * _E;
var M1 = 1 - E / 4 - 3 * E2 / 64 - 5 * E3 / 256;
var M2 = 3 * E / 8 + 3 * E2 / 32 + 45 * E3 / 1024;
var M3 = 15 * E2 / 256 + 45 * E3 / 1024;
var M4 = 35 * E3 / 3072;
var P2 = 3 / 2 * _E - 27 / 32 * _E3 + 269 / 512 * _E5;
var P3 = 21 / 16 * _E2 - 55 / 32 * _E4;
var P4 = 151 / 96 * _E3 - 417 / 128 * _E5;
var P5 = 1097 / 512 * _E4;
var R = 6378137;
function toLonLat(easting, northing, zone) {
  const x = easting - 5e5;
  const y = zone.north ? northing : northing - 1e7;
  const m = y / K0;
  const mu = m / (R * M1);
  const pRad = mu + P2 * Math.sin(2 * mu) + P3 * Math.sin(4 * mu) + P4 * Math.sin(6 * mu) + P5 * Math.sin(8 * mu);
  const pSin = Math.sin(pRad);
  const pSin2 = pSin * pSin;
  const pCos = Math.cos(pRad);
  const pTan = pSin / pCos;
  const pTan2 = pTan * pTan;
  const pTan4 = pTan2 * pTan2;
  const epSin = 1 - E * pSin2;
  const epSinSqrt = Math.sqrt(1 - E * pSin2);
  const n = R / epSinSqrt;
  const r = (1 - E) / epSin;
  const c = E_P2 * pCos ** 2;
  const c2 = c * c;
  const d = x / (n * K0);
  const d2 = d * d;
  const d3 = d2 * d;
  const d4 = d3 * d;
  const d5 = d4 * d;
  const d6 = d5 * d;
  const latitude = pRad - pTan / r * (d2 / 2 - d4 / 24 * (5 + 3 * pTan2 + 10 * c - 4 * c2 - 9 * E_P2)) + d6 / 720 * (61 + 90 * pTan2 + 298 * c + 45 * pTan4 - 252 * E_P2 - 3 * c2);
  let longitude = (d - d3 / 6 * (1 + 2 * pTan2 + c) + d5 / 120 * (5 - 2 * c + 28 * pTan2 - 3 * c2 + 8 * E_P2 + 24 * pTan4)) / pCos;
  longitude = wrap(
    longitude + toRadians(zoneToCentralLongitude(zone.number)),
    -Math.PI,
    Math.PI
  );
  return [toDegrees(longitude), toDegrees(latitude)];
}
var MIN_LATITUDE = -80;
var MAX_LATITUDE = 84;
var MIN_LONGITUDE = -180;
var MAX_LONGITUDE = 180;
function fromLonLat(longitude, latitude, zone) {
  longitude = wrap(longitude, MIN_LONGITUDE, MAX_LONGITUDE);
  if (latitude < MIN_LATITUDE) {
    latitude = MIN_LATITUDE;
  } else if (latitude > MAX_LATITUDE) {
    latitude = MAX_LATITUDE;
  }
  const latRad = toRadians(latitude);
  const latSin = Math.sin(latRad);
  const latCos = Math.cos(latRad);
  const latTan = latSin / latCos;
  const latTan2 = latTan * latTan;
  const latTan4 = latTan2 * latTan2;
  const lonRad = toRadians(longitude);
  const centralLon = zoneToCentralLongitude(zone.number);
  const centralLonRad = toRadians(centralLon);
  const n = R / Math.sqrt(1 - E * latSin ** 2);
  const c = E_P2 * latCos ** 2;
  const a = latCos * wrap(lonRad - centralLonRad, -Math.PI, Math.PI);
  const a22 = a * a;
  const a3 = a22 * a;
  const a4 = a3 * a;
  const a5 = a4 * a;
  const a6 = a5 * a;
  const m = R * (M1 * latRad - M2 * Math.sin(2 * latRad) + M3 * Math.sin(4 * latRad) - M4 * Math.sin(6 * latRad));
  const easting = K0 * n * (a + a3 / 6 * (1 - latTan2 + c) + a5 / 120 * (5 - 18 * latTan2 + latTan4 + 72 * c - 58 * E_P2)) + 5e5;
  let northing = K0 * (m + n * latTan * (a22 / 2 + a4 / 24 * (5 - latTan2 + 9 * c + 4 * c ** 2) + a6 / 720 * (61 - 58 * latTan2 + latTan4 + 600 * c - 330 * E_P2)));
  if (!zone.north) {
    northing += 1e7;
  }
  return [easting, northing];
}
function zoneToCentralLongitude(zone) {
  return (zone - 1) * 6 - 180 + 3;
}
var epsgRegExes = [
  /^EPSG:(\d+)$/,
  /^urn:ogc:def:crs:EPSG::(\d+)$/,
  /^http:\/\/www\.opengis\.net\/def\/crs\/EPSG\/0\/(\d+)$/
];
function zoneFromCode(code) {
  let epsgId = 0;
  for (const re of epsgRegExes) {
    const match = code.match(re);
    if (match) {
      epsgId = parseInt(match[1]);
      break;
    }
  }
  if (!epsgId) {
    return null;
  }
  let number = 0;
  let north = false;
  if (epsgId > 32700 && epsgId < 32761) {
    number = epsgId - 32700;
  } else if (epsgId > 32600 && epsgId < 32661) {
    north = true;
    number = epsgId - 32600;
  }
  if (!number) {
    return null;
  }
  return { number, north };
}
function makeTransformFunction(transformer, zone) {
  return function(input, output, dimension, stride) {
    const length = input.length;
    dimension = dimension > 1 ? dimension : 2;
    stride = stride ?? dimension;
    if (!output) {
      if (dimension > 2) {
        output = input.slice();
      } else {
        output = new Array(length);
      }
    }
    for (let i = 0; i < length; i += stride) {
      const x = input[i];
      const y = input[i + 1];
      const coord = transformer(x, y, zone);
      output[i] = coord[0];
      output[i + 1] = coord[1];
    }
    return output;
  };
}
function makeProjection(code) {
  const zone = zoneFromCode(code);
  if (!zone) {
    return null;
  }
  return new Projection_default({ code, units: "m" });
}
function makeTransforms(projection) {
  const zone = zoneFromCode(projection.getCode());
  if (!zone) {
    return null;
  }
  return {
    forward: makeTransformFunction(fromLonLat, zone),
    inverse: makeTransformFunction(toLonLat, zone)
  };
}

// node_modules/ol/proj.js
var transformFactories = [makeTransforms];
var projectionFactories = [makeProjection];
var showCoordinateWarning = true;
function disableCoordinateWarning(disable2) {
  const hide = disable2 === void 0 ? true : disable2;
  showCoordinateWarning = !hide;
}
function cloneTransform(input, output) {
  if (output !== void 0) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    output = output;
  } else {
    output = input.slice();
  }
  return output;
}
function addProjection(projection) {
  add2(projection.getCode(), projection);
  add3(projection, projection, cloneTransform);
}
function addProjections(projections) {
  projections.forEach(addProjection);
}
function get3(projectionLike) {
  if (!(typeof projectionLike === "string")) {
    return projectionLike;
  }
  const projection = get(projectionLike);
  if (projection) {
    return projection;
  }
  for (const makeProjection2 of projectionFactories) {
    const projection2 = makeProjection2(projectionLike);
    if (projection2) {
      return projection2;
    }
  }
  return null;
}
function getPointResolution(projection, resolution, point, units) {
  projection = get3(projection);
  let pointResolution;
  const getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
    if (units && units !== projection.getUnits()) {
      const metersPerUnit = projection.getMetersPerUnit();
      if (metersPerUnit) {
        pointResolution = pointResolution * metersPerUnit / METERS_PER_UNIT[units];
      }
    }
  } else {
    const projUnits = projection.getUnits();
    if (projUnits == "degrees" && !units || units == "degrees") {
      pointResolution = resolution;
    } else {
      const toEPSG43262 = getTransformFromProjections(
        projection,
        get3("EPSG:4326")
      );
      if (!toEPSG43262 && projUnits !== "degrees") {
        pointResolution = resolution * projection.getMetersPerUnit();
      } else {
        let vertices = [
          point[0] - resolution / 2,
          point[1],
          point[0] + resolution / 2,
          point[1],
          point[0],
          point[1] - resolution / 2,
          point[0],
          point[1] + resolution / 2
        ];
        vertices = toEPSG43262(vertices, vertices, 2);
        const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
        const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
        pointResolution = (width + height) / 2;
      }
      const metersPerUnit = units ? METERS_PER_UNIT[units] : projection.getMetersPerUnit();
      if (metersPerUnit !== void 0) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
}
function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function(source) {
    projections.forEach(function(destination) {
      if (source !== destination) {
        add3(source, destination, cloneTransform);
      }
    });
  });
}
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function(projection1) {
    projections2.forEach(function(projection2) {
      add3(projection1, projection2, forwardTransform);
      add3(projection2, projection1, inverseTransform);
    });
  });
}
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get3(defaultCode);
  }
  if (typeof projection === "string") {
    return get3(projection);
  }
  return (
    /** @type {Projection} */
    projection
  );
}
function createTransformFromCoordinateTransform(coordTransform) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimensions that should be transformed.
     * @param {number} [stride] Stride.
     * @return {Array<number>} Output.
     */
    function(input, output, dimension, stride) {
      const length = input.length;
      dimension = dimension !== void 0 ? dimension : 2;
      stride = stride ?? dimension;
      output = output !== void 0 ? output : new Array(length);
      for (let i = 0; i < length; i += stride) {
        const point = coordTransform(input.slice(i, i + dimension));
        const pointLength = point.length;
        for (let j = 0, jj = stride; j < jj; ++j) {
          output[i + j] = j >= pointLength ? input[i + j] : point[j];
        }
      }
      return output;
    }
  );
}
function addCoordinateTransforms(source, destination, forward, inverse) {
  const sourceProj = get3(source);
  const destProj = get3(destination);
  add3(
    sourceProj,
    destProj,
    createTransformFromCoordinateTransform(forward)
  );
  add3(
    destProj,
    sourceProj,
    createTransformFromCoordinateTransform(inverse)
  );
}
function fromLonLat2(coordinate, projection) {
  disableCoordinateWarning();
  return transform(
    coordinate,
    "EPSG:4326",
    projection !== void 0 ? projection : "EPSG:3857"
  );
}
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  const equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  }
  const transformFunc = getTransformFromProjections(projection1, projection2);
  return transformFunc === cloneTransform && equalUnits;
}
function getTransformFromProjections(source, destination) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  let transformFunc = get2(sourceCode, destinationCode);
  if (transformFunc) {
    return transformFunc;
  }
  let sourceTransforms = null;
  let destinationTransforms = null;
  for (const makeTransforms2 of transformFactories) {
    if (!sourceTransforms) {
      sourceTransforms = makeTransforms2(source);
    }
    if (!destinationTransforms) {
      destinationTransforms = makeTransforms2(destination);
    }
  }
  if (!sourceTransforms && !destinationTransforms) {
    return null;
  }
  const intermediateCode = "EPSG:4326";
  if (!destinationTransforms) {
    const toDestination = get2(intermediateCode, destinationCode);
    if (toDestination) {
      transformFunc = composeTransformFuncs(
        sourceTransforms.inverse,
        toDestination
      );
    }
  } else if (!sourceTransforms) {
    const fromSource = get2(sourceCode, intermediateCode);
    if (fromSource) {
      transformFunc = composeTransformFuncs(
        fromSource,
        destinationTransforms.forward
      );
    }
  } else {
    transformFunc = composeTransformFuncs(
      sourceTransforms.inverse,
      destinationTransforms.forward
    );
  }
  if (transformFunc) {
    addProjection(source);
    addProjection(destination);
    add3(source, destination, transformFunc);
  }
  return transformFunc;
}
function composeTransformFuncs(t1, t2) {
  return function(input, output, dimensions, stride) {
    output = t1(input, output, dimensions, stride);
    return t2(output, output, dimensions, stride);
  };
}
function getTransform(source, destination) {
  const sourceProjection = get3(source);
  const destinationProjection = get3(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}
function transform(coordinate, source, destination) {
  const transformFunc = getTransform(source, destination);
  if (!transformFunc) {
    const sourceCode = get3(source).getCode();
    const destinationCode = get3(destination).getCode();
    throw new Error(
      `No transform available between ${sourceCode} and ${destinationCode}`
    );
  }
  return transformFunc(coordinate, void 0, coordinate.length);
}
function transformExtent(extent, source, destination, stops) {
  const transformFunc = getTransform(source, destination);
  return applyTransform(extent, transformFunc, void 0, stops);
}
var userProjection = null;
function getUserProjection() {
  return userProjection;
}
function toUserCoordinate(coordinate, sourceProjection) {
  if (!userProjection) {
    return coordinate;
  }
  return transform(coordinate, sourceProjection, userProjection);
}
function fromUserCoordinate(coordinate, destProjection) {
  if (!userProjection) {
    if (showCoordinateWarning && !equals3(coordinate, [0, 0]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
      showCoordinateWarning = false;
      warn(
        "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
      );
    }
    return coordinate;
  }
  return transform(coordinate, userProjection, destProjection);
}
function toUserExtent(extent, sourceProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, sourceProjection, userProjection);
}
function fromUserExtent(extent, destProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, userProjection, destProjection);
}
function toUserResolution(resolution, sourceProjection) {
  if (!userProjection) {
    return resolution;
  }
  const sourceMetersPerUnit = get3(sourceProjection).getMetersPerUnit();
  const userMetersPerUnit = userProjection.getMetersPerUnit();
  return sourceMetersPerUnit && userMetersPerUnit ? resolution * sourceMetersPerUnit / userMetersPerUnit : resolution;
}
function createSafeCoordinateTransform(sourceProj, destProj, transform2) {
  return function(coord) {
    let transformed, worldsAway;
    if (sourceProj.canWrapX()) {
      const sourceExtent = sourceProj.getExtent();
      const sourceExtentWidth = getWidth(sourceExtent);
      coord = coord.slice(0);
      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);
      if (worldsAway) {
        coord[0] = coord[0] - worldsAway * sourceExtentWidth;
      }
      coord[0] = clamp(coord[0], sourceExtent[0], sourceExtent[2]);
      coord[1] = clamp(coord[1], sourceExtent[1], sourceExtent[3]);
      transformed = transform2(coord);
    } else {
      transformed = transform2(coord);
    }
    if (worldsAway && destProj.canWrapX()) {
      transformed[0] += worldsAway * getWidth(destProj.getExtent());
    }
    return transformed;
  };
}
function addCommon() {
  addEquivalentProjections(PROJECTIONS);
  addEquivalentProjections(PROJECTIONS2);
  addEquivalentTransforms(
    PROJECTIONS2,
    PROJECTIONS,
    fromEPSG4326,
    toEPSG4326
  );
}
addCommon();

// node_modules/ol/transform.js
var tmp_ = new Array(6);
function create() {
  return [1, 0, 0, 1, 0, 0];
}
function setFromArray(transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
}
function apply(transform2, coordinate) {
  const x = coordinate[0];
  const y = coordinate[1];
  coordinate[0] = transform2[0] * x + transform2[2] * y + transform2[4];
  coordinate[1] = transform2[1] * x + transform2[3] * y + transform2[5];
  return coordinate;
}
function compose(transform2, dx1, dy1, sx, sy, angle, dx2, dy2) {
  const sin = Math.sin(angle);
  const cos = Math.cos(angle);
  transform2[0] = sx * cos;
  transform2[1] = sy * sin;
  transform2[2] = -sx * sin;
  transform2[3] = sy * cos;
  transform2[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform2[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform2;
}
function makeInverse(target, source) {
  const det = determinant(source);
  assert(det !== 0, "Transformation matrix cannot be inverted");
  const a = source[0];
  const b = source[1];
  const c = source[2];
  const d = source[3];
  const e = source[4];
  const f = source[5];
  target[0] = d / det;
  target[1] = -b / det;
  target[2] = -c / det;
  target[3] = a / det;
  target[4] = (c * f - d * e) / det;
  target[5] = -(a * f - b * e) / det;
  return target;
}
function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}
var matrixPrecision = [1e5, 1e5, 1e5, 1e5, 2, 2];
function toString(mat) {
  const transformString = "matrix(" + mat.join(", ") + ")";
  return transformString;
}
function fromString(cssTransform) {
  const values = cssTransform.substring(7, cssTransform.length - 1).split(",");
  return values.map(parseFloat);
}
function equivalent2(cssTransform1, cssTransform2) {
  const mat1 = fromString(cssTransform1);
  const mat2 = fromString(cssTransform2);
  for (let i = 0; i < 6; ++i) {
    if (Math.round((mat1[i] - mat2[i]) * matrixPrecision[i]) !== 0) {
      return false;
    }
  }
  return true;
}

// node_modules/ol/geom/flat/transform.js
function transform2D(flatCoordinates, offset, end, stride, transform2, dest, destinationStride) {
  dest = dest ? dest : [];
  destinationStride = destinationStride ? destinationStride : 2;
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const x = flatCoordinates[j];
    const y = flatCoordinates[j + 1];
    dest[i++] = transform2[0] * x + transform2[2] * y + transform2[4];
    dest[i++] = transform2[1] * x + transform2[3] * y + transform2[5];
    for (let k = 2; k < destinationStride; k++) {
      dest[i++] = flatCoordinates[j + k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function rotate2(flatCoordinates, offset, end, stride, angle, anchor, dest) {
  dest = dest ? dest : [];
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function scale2(flatCoordinates, offset, end, stride, sx, sy, anchor, dest) {
  dest = dest ? dest : [];
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, dest) {
  dest = dest ? dest : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}

// node_modules/ol/geom/Geometry.js
var tmpTransform = create();
var tmpPoint = [NaN, NaN];
var Geometry = class extends Object_default {
  constructor() {
    super();
    this.extent_ = createEmpty();
    this.extentRevision_ = -1;
    this.simplifiedGeometryMaxMinSquaredTolerance = 0;
    this.simplifiedGeometryRevision = 0;
    this.simplifyTransformedInternal = memoizeOne(
      (revision, squaredTolerance, transform2) => {
        if (!transform2) {
          return this.getSimplifiedGeometry(squaredTolerance);
        }
        const clone2 = this.clone();
        clone2.applyTransform(transform2);
        return clone2.getSimplifiedGeometry(squaredTolerance);
      }
    );
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */
  simplifyTransformed(squaredTolerance, transform2) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      squaredTolerance,
      transform2
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  clone() {
    return abstract();
  }
  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    return abstract();
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(x, y) {
    return this.closestPointXY(x, y, tmpPoint, Number.MIN_VALUE) === 0;
  }
  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  getClosestPoint(point, closestPoint) {
    closestPoint = closestPoint ? closestPoint : [NaN, NaN];
    this.closestPointXY(point[0], point[1], closestPoint, Infinity);
    return closestPoint;
  }
  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  intersectsCoordinate(coordinate) {
    return this.containsXY(coordinate[0], coordinate[1]);
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(extent) {
    return abstract();
  }
  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  getExtent(extent) {
    if (this.extentRevision_ != this.getRevision()) {
      const extent2 = this.computeExtent(this.extent_);
      if (isNaN(extent2[0]) || isNaN(extent2[1])) {
        createOrUpdateEmpty(extent2);
      }
      this.extentRevision_ = this.getRevision();
    }
    return returnOrUpdate(this.extent_, extent);
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(angle, anchor) {
    abstract();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(sx, sy, anchor) {
    abstract();
  }
  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  simplify(tolerance) {
    return this.getSimplifiedGeometry(tolerance * tolerance);
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  getSimplifiedGeometry(squaredTolerance) {
    return abstract();
  }
  /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */
  getType() {
    return abstract();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */
  applyTransform(transformFn) {
    abstract();
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  intersectsExtent(extent) {
    return abstract();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(deltaX, deltaY) {
    abstract();
  }
  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {this} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  transform(source, destination) {
    const sourceProj = get3(source);
    const transformFn = sourceProj.getUnits() == "tile-pixels" ? function(inCoordinates, outCoordinates, stride) {
      const pixelExtent = sourceProj.getExtent();
      const projectedExtent = sourceProj.getWorldExtent();
      const scale4 = getHeight(projectedExtent) / getHeight(pixelExtent);
      compose(
        tmpTransform,
        projectedExtent[0],
        projectedExtent[3],
        scale4,
        -scale4,
        0,
        0,
        0
      );
      const transformed = transform2D(
        inCoordinates,
        0,
        inCoordinates.length,
        stride,
        tmpTransform,
        outCoordinates
      );
      const projTransform = getTransform(sourceProj, destination);
      if (projTransform) {
        return projTransform(transformed, transformed, stride);
      }
      return transformed;
    } : getTransform(sourceProj, destination);
    this.applyTransform(transformFn);
    return this;
  }
};
var Geometry_default = Geometry;

// node_modules/ol/geom/SimpleGeometry.js
var SimpleGeometry = class extends Geometry_default {
  constructor() {
    super();
    this.layout = "XY";
    this.stride = 2;
    this.flatCoordinates;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   * @override
   */
  computeExtent(extent) {
    return createOrUpdateFromFlatCoordinates(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      extent
    );
  }
  /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */
  getCoordinates() {
    return abstract();
  }
  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getFlatCoordinates() {
    return this.flatCoordinates;
  }
  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride
    );
  }
  /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */
  getLayout() {
    return this.layout;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @override
   */
  getSimplifiedGeometry(squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }
    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
      return this;
    }
    const simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
    const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
      return simplifiedGeometry;
    }
    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
    return this;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    return this;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride;
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  setFlatCoordinates(layout, flatCoordinates) {
    this.stride = getStrideForLayout(layout);
    this.layout = layout;
    this.flatCoordinates = flatCoordinates;
  }
  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  setCoordinates(coordinates2, layout) {
    abstract();
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  setLayout(layout, coordinates2, nesting) {
    let stride;
    if (layout) {
      stride = getStrideForLayout(layout);
    } else {
      for (let i = 0; i < nesting; ++i) {
        if (coordinates2.length === 0) {
          this.layout = "XY";
          this.stride = 2;
          return;
        }
        coordinates2 = /** @type {Array<unknown>} */
        coordinates2[0];
      }
      stride = coordinates2.length;
      layout = getLayoutForStride(stride);
    }
    this.layout = layout;
    this.stride = stride;
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   * @override
   */
  applyTransform(transformFn) {
    if (this.flatCoordinates) {
      transformFn(
        this.flatCoordinates,
        this.flatCoordinates,
        this.layout.startsWith("XYZ") ? 3 : 2,
        this.stride
      );
      this.changed();
    }
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   * @override
   */
  rotate(angle, anchor) {
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      rotate2(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        angle,
        anchor,
        flatCoordinates
      );
      this.changed();
    }
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   * @override
   */
  scale(sx, sy, anchor) {
    if (sy === void 0) {
      sy = sx;
    }
    if (!anchor) {
      anchor = getCenter(this.getExtent());
    }
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      scale2(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        sx,
        sy,
        anchor,
        flatCoordinates
      );
      this.changed();
    }
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   * @override
   */
  translate(deltaX, deltaY) {
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      translate(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        deltaX,
        deltaY,
        flatCoordinates
      );
      this.changed();
    }
  }
};
function getLayoutForStride(stride) {
  let layout;
  if (stride == 2) {
    layout = "XY";
  } else if (stride == 3) {
    layout = "XYZ";
  } else if (stride == 4) {
    layout = "XYZM";
  }
  return (
    /** @type {import("./Geometry.js").GeometryLayout} */
    layout
  );
}
function getStrideForLayout(layout) {
  let stride;
  if (layout == "XY") {
    stride = 2;
  } else if (layout == "XYZ" || layout == "XYM") {
    stride = 3;
  } else if (layout == "XYZM") {
    stride = 4;
  }
  return (
    /** @type {number} */
    stride
  );
}
function transformGeom2D(simpleGeometry, transform2, dest) {
  const flatCoordinates = simpleGeometry.getFlatCoordinates();
  if (!flatCoordinates) {
    return null;
  }
  const stride = simpleGeometry.getStride();
  return transform2D(
    flatCoordinates,
    0,
    flatCoordinates.length,
    stride,
    transform2,
    dest
  );
}
var SimpleGeometry_default = SimpleGeometry;

// node_modules/ol/geom/flat/area.js
function linearRing(flatCoordinates, offset, end, stride) {
  let twiceArea = 0;
  const x0 = flatCoordinates[end - stride];
  const y0 = flatCoordinates[end - stride + 1];
  let dx1 = 0;
  let dy1 = 0;
  for (; offset < end; offset += stride) {
    const dx2 = flatCoordinates[offset] - x0;
    const dy2 = flatCoordinates[offset + 1] - y0;
    twiceArea += dy1 * dx2 - dx1 * dy2;
    dx1 = dx2;
    dy1 = dy2;
  }
  return twiceArea / 2;
}
function linearRings(flatCoordinates, offset, ends, stride) {
  let area = 0;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    area += linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }
  return area;
}

// node_modules/ol/geom/flat/closest.js
function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  const x1 = flatCoordinates[offset1];
  const y1 = flatCoordinates[offset1 + 1];
  const dx = flatCoordinates[offset2] - x1;
  const dy = flatCoordinates[offset2 + 1] - y1;
  let offset;
  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      offset = offset2;
    } else if (t > 0) {
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = lerp(
          flatCoordinates[offset1 + i],
          flatCoordinates[offset2 + i],
          t
        );
      }
      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }
  for (let i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset + i];
  }
  closestPoint.length = stride;
}
function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  for (offset += stride; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    const squaredDelta = squaredDistance(x1, y1, x2, y2);
    if (squaredDelta > max) {
      max = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return max;
}
function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
    offset = end;
  }
  return max;
}
function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint2) {
  if (offset == end) {
    return minSquaredDistance;
  }
  let i, squaredDistance2;
  if (maxDelta === 0) {
    squaredDistance2 = squaredDistance(
      x,
      y,
      flatCoordinates[offset],
      flatCoordinates[offset + 1]
    );
    if (squaredDistance2 < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }
      closestPoint.length = stride;
      return squaredDistance2;
    }
    return minSquaredDistance;
  }
  tmpPoint2 = tmpPoint2 ? tmpPoint2 : [NaN, NaN];
  let index = offset + stride;
  while (index < end) {
    assignClosest(
      flatCoordinates,
      index - stride,
      index,
      stride,
      x,
      y,
      tmpPoint2
    );
    squaredDistance2 = squaredDistance(x, y, tmpPoint2[0], tmpPoint2[1]);
    if (squaredDistance2 < minSquaredDistance) {
      minSquaredDistance = squaredDistance2;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint2[i];
      }
      closestPoint.length = stride;
      index += stride;
    } else {
      index += stride * Math.max(
        (Math.sqrt(squaredDistance2) - Math.sqrt(minSquaredDistance)) / maxDelta | 0,
        1
      );
    }
  }
  if (isRing) {
    assignClosest(
      flatCoordinates,
      end - stride,
      offset,
      stride,
      x,
      y,
      tmpPoint2
    );
    squaredDistance2 = squaredDistance(x, y, tmpPoint2[0], tmpPoint2[1]);
    if (squaredDistance2 < minSquaredDistance) {
      minSquaredDistance = squaredDistance2;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint2[i];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}
function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint2) {
  tmpPoint2 = tmpPoint2 ? tmpPoint2 : [NaN, NaN];
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    minSquaredDistance = assignClosestPoint(
      flatCoordinates,
      offset,
      end,
      stride,
      maxDelta,
      isRing,
      x,
      y,
      closestPoint,
      minSquaredDistance,
      tmpPoint2
    );
    offset = end;
  }
  return minSquaredDistance;
}

// node_modules/ol/geom/flat/deflate.js
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
  for (let i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }
  return offset;
}
function deflateCoordinates(flatCoordinates, offset, coordinates2, stride) {
  for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
    const coordinate = coordinates2[i];
    for (let j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }
  return offset;
}
function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, ends) {
  ends = ends ? ends : [];
  let i = 0;
  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {
    const end = deflateCoordinates(
      flatCoordinates,
      offset,
      coordinatess[j],
      stride
    );
    ends[i++] = end;
    offset = end;
  }
  ends.length = i;
  return ends;
}

// node_modules/ol/geom/flat/inflate.js
function inflateCoordinates(flatCoordinates, offset, end, stride, coordinates2) {
  coordinates2 = coordinates2 !== void 0 ? coordinates2 : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    coordinates2[i++] = flatCoordinates.slice(j, j + stride);
  }
  coordinates2.length = i;
  return coordinates2;
}
function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatess) {
  coordinatess = coordinatess !== void 0 ? coordinatess : [];
  let i = 0;
  for (let j = 0, jj = ends.length; j < jj; ++j) {
    const end = ends[j];
    coordinatess[i++] = inflateCoordinates(
      flatCoordinates,
      offset,
      end,
      stride,
      coordinatess[i]
    );
    offset = end;
  }
  coordinatess.length = i;
  return coordinatess;
}
function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, coordinatesss) {
  coordinatesss = coordinatesss !== void 0 ? coordinatesss : [];
  let i = 0;
  for (let j = 0, jj = endss.length; j < jj; ++j) {
    const ends = endss[j];
    coordinatesss[i++] = ends.length === 1 && ends[0] === offset ? [] : inflateCoordinatesArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      coordinatesss[i]
    );
    offset = ends[ends.length - 1];
  }
  coordinatesss.length = i;
  return coordinatesss;
}

// node_modules/ol/geom/flat/simplify.js
function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  const n = (end - offset) / stride;
  if (n < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  const markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  const stack = [offset, end - stride];
  let index = 0;
  while (stack.length > 0) {
    const last = stack.pop();
    const first = stack.pop();
    let maxSquaredDistance = 0;
    const x1 = flatCoordinates[first];
    const y1 = flatCoordinates[first + 1];
    const x2 = flatCoordinates[last];
    const y2 = flatCoordinates[last + 1];
    for (let i = first + stride; i < last; i += stride) {
      const x = flatCoordinates[i];
      const y = flatCoordinates[i + 1];
      const squaredDistance2 = squaredSegmentDistance(x, y, x1, y1, x2, y2);
      if (squaredDistance2 > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance2;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset) / stride] = 1;
      if (first + stride < index) {
        stack.push(first, index);
      }
      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }
  for (let i = 0; i < n; ++i) {
    if (markers[i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];
    }
  }
  return simplifiedOffset;
}
function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = douglasPeucker(
      flatCoordinates,
      offset,
      end,
      stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}
function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (offset == end) {
    return simplifiedOffset;
  }
  let x1 = snap(flatCoordinates[offset], tolerance);
  let y1 = snap(flatCoordinates[offset + 1], tolerance);
  offset += stride;
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  let x2, y2;
  do {
    x2 = snap(flatCoordinates[offset], tolerance);
    y2 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (offset == end) {
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset < end) {
    const x3 = snap(flatCoordinates[offset], tolerance);
    const y3 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    const dx1 = x2 - x1;
    const dy1 = y2 - y1;
    const dx2 = x3 - x1;
    const dy2 = y3 - y1;
    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      x2 = x3;
      y2 = y3;
      continue;
    }
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}
function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = quantize(
      flatCoordinates,
      offset,
      end,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}

// node_modules/ol/geom/LinearRing.js
var LinearRing = class _LinearRing extends SimpleGeometry_default {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(coordinates2, layout) {
    super();
    this.maxDelta_ = -1;
    this.maxDeltaRevision_ = -1;
    if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */
        coordinates2
      );
    } else {
      this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */
        coordinates2,
        layout
      );
    }
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   * @override
   */
  clone() {
    return new _LinearRing(this.flatCoordinates.slice(), this.layout);
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        maxSquaredDelta(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestPoint(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      true,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }
  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return linearRing(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return inflateCoordinates(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = douglasPeucker(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      0
    );
    return new _LinearRing(simplifiedFlatCoordinates, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "LinearRing";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(extent) {
    return false;
  }
  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinates(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride
    );
    this.changed();
  }
};
var LinearRing_default = LinearRing;

// node_modules/ol/geom/Point.js
var Point = class _Point extends SimpleGeometry_default {
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(coordinates2, layout) {
    super();
    this.setCoordinates(coordinates2, layout);
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   * @override
   */
  clone() {
    const point = new _Point(this.flatCoordinates.slice(), this.layout);
    point.applyProperties(this);
    return point;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    const flatCoordinates = this.flatCoordinates;
    const squaredDistance2 = squaredDistance(
      x,
      y,
      flatCoordinates[0],
      flatCoordinates[1]
    );
    if (squaredDistance2 < minSquaredDistance) {
      const stride = this.stride;
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[i];
      }
      closestPoint.length = stride;
      return squaredDistance2;
    }
    return minSquaredDistance;
  }
  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return this.flatCoordinates.slice();
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   * @override
   */
  computeExtent(extent) {
    return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "Point";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(extent) {
    return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
  }
  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinate(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride
    );
    this.changed();
  }
};
var Point_default = Point;

// node_modules/ol/geom/flat/contains.js
function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
  const outside = forEachCorner(
    extent,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(coordinate) {
      return !linearRingContainsXY(
        flatCoordinates,
        offset,
        end,
        stride,
        coordinate[0],
        coordinate[1]
      );
    }
  );
  return !outside;
}
function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
  let wn = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }
    x1 = x2;
    y1 = y2;
  }
  return wn !== 0;
}
function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }
  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }
  return true;
}

// node_modules/ol/geom/flat/interiorpoint.js
function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, dest) {
  let i, ii, x, x1, x2, y1, y2;
  const y = flatCenters[flatCentersOffset + 1];
  const intersections = [];
  for (let r = 0, rr = ends.length; r < rr; ++r) {
    const end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i = offset; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];
      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }
      x1 = x2;
      y1 = y2;
    }
  }
  let pointX = NaN;
  let maxSegmentLength = -Infinity;
  intersections.sort(ascending);
  x1 = intersections[0];
  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    const segmentLength = Math.abs(x2 - x1);
    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;
      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x2;
  }
  if (isNaN(pointX)) {
    pointX = flatCenters[flatCentersOffset];
  }
  if (dest) {
    dest.push(pointX, y, maxSegmentLength);
    return dest;
  }
  return [pointX, y, maxSegmentLength];
}
function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
  let interiorPoints = [];
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    interiorPoints = getInteriorPointOfArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      flatCenters,
      2 * i,
      interiorPoints
    );
    offset = ends[ends.length - 1];
  }
  return interiorPoints;
}

// node_modules/ol/geom/flat/segments.js
function forEach(flatCoordinates, offset, end, stride, callback) {
  let ret;
  offset += stride;
  for (; offset < end; offset += stride) {
    ret = callback(
      flatCoordinates.slice(offset - stride, offset),
      flatCoordinates.slice(offset, offset + stride)
    );
    if (ret) {
      return ret;
    }
  }
  return false;
}

// node_modules/ol/geom/flat/intersectsextent.js
function intersectsLineString(flatCoordinates, offset, end, stride, extent, coordinatesExtent) {
  coordinatesExtent = coordinatesExtent ?? extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);
  if (!intersects(extent, coordinatesExtent)) {
    return false;
  }
  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2] || coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return forEach(
    flatCoordinates,
    offset,
    end,
    stride,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(point1, point2) {
      return intersectsSegment(extent, point1, point2);
    }
  );
}
function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[0],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[0],
    extent[3]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[2],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[2],
    extent[3]
  )) {
    return true;
  }
  return false;
}
function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsExtent(
      flatCoordinates,
      ends[i - 1],
      ends[i],
      stride,
      extent
    )) {
      if (!intersectsLineString(
        flatCoordinates,
        ends[i - 1],
        ends[i],
        stride,
        extent
      )) {
        return false;
      }
    }
  }
  return true;
}

// node_modules/ol/geom/flat/reverse.js
function coordinates(flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    for (let i = 0; i < stride; ++i) {
      const tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }
    offset += stride;
    end -= stride;
  }
}

// node_modules/ol/geom/flat/orient.js
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
  let edge = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge === 0 ? void 0 : edge > 0;
}
function linearRingsAreOriented(flatCoordinates, offset, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride
    );
    if (i === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }
    offset = end;
  }
  return true;
}
function orientLinearRings(flatCoordinates, offset, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride
    );
    const reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
    if (reverse) {
      coordinates(flatCoordinates, offset, end, stride);
    }
    offset = end;
  }
  return offset;
}
function inflateEnds(flatCoordinates, ends) {
  const endss = [];
  let offset = 0;
  let prevEndIndex = 0;
  let startOrientation;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const orientation = linearRingIsClockwise(flatCoordinates, offset, end, 2);
    if (startOrientation === void 0) {
      startOrientation = orientation;
    }
    if (orientation === startOrientation) {
      endss.push(ends.slice(prevEndIndex, i + 1));
    } else {
      if (endss.length === 0) {
        continue;
      }
      endss[endss.length - 1].push(ends[prevEndIndex]);
    }
    prevEndIndex = i + 1;
    offset = end;
  }
  return endss;
}

// node_modules/ol/geom/Polygon.js
var Polygon = class _Polygon extends SimpleGeometry_default {
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  constructor(coordinates2, layout, ends) {
    super();
    this.ends_ = [];
    this.flatInteriorPointRevision_ = -1;
    this.flatInteriorPoint_ = null;
    this.maxDelta_ = -1;
    this.maxDeltaRevision_ = -1;
    this.orientedRevision_ = -1;
    this.orientedFlatCoordinates_ = null;
    if (layout !== void 0 && ends) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */
        coordinates2
      );
      this.ends_ = ends;
    } else {
      this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
        coordinates2,
        layout
      );
    }
  }
  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  appendLinearRing(linearRing2) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = linearRing2.getFlatCoordinates().slice();
    } else {
      extend(this.flatCoordinates, linearRing2.getFlatCoordinates());
    }
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   * @override
   */
  clone() {
    const polygon = new _Polygon(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    polygon.applyProperties(this);
    return polygon;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        arrayMaxSquaredDelta(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestArrayPoint(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      true,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   * @override
   */
  containsXY(x, y) {
    return linearRingsContainsXY(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      x,
      y
    );
  }
  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return linearRings(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   * @override
   */
  getCoordinates(right) {
    let flatCoordinates;
    if (right !== void 0) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }
    return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * @return {Array<number>} Interior point.
   */
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const flatCenter = getCenter(this.getExtent());
      this.flatInteriorPoint_ = getInteriorPointOfArray(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        flatCenter,
        0
      );
      this.flatInteriorPointRevision_ = this.getRevision();
    }
    return (
      /** @type {import("../coordinate.js").Coordinate} */
      this.flatInteriorPoint_
    );
  }
  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoint() {
    return new Point_default(this.getFlatInteriorPoint(), "XYM");
  }
  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  getLinearRingCount() {
    return this.ends_.length;
  }
  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */
  getLinearRing(index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }
    return new LinearRing_default(
      this.flatCoordinates.slice(
        index === 0 ? 0 : this.ends_[index - 1],
        this.ends_[index]
      ),
      this.layout
    );
  }
  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  getLinearRings() {
    const layout = this.layout;
    const flatCoordinates = this.flatCoordinates;
    const ends = this.ends_;
    const linearRings2 = [];
    let offset = 0;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      const linearRing2 = new LinearRing_default(
        flatCoordinates.slice(offset, end),
        layout
      );
      linearRings2.push(linearRing2);
      offset = end;
    }
    return linearRings2;
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const flatCoordinates = this.flatCoordinates;
      if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = orientLinearRings(
          this.orientedFlatCoordinates_,
          0,
          this.ends_,
          this.stride
        );
      }
      this.orientedRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.orientedFlatCoordinates_
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    const simplifiedEnds = [];
    simplifiedFlatCoordinates.length = quantizeArray(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(squaredTolerance),
      simplifiedFlatCoordinates,
      0,
      simplifiedEnds
    );
    return new _Polygon(simplifiedFlatCoordinates, "XY", simplifiedEnds);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "Polygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(extent) {
    return intersectsLinearRingArray(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      extent
    );
  }
  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    const ends = deflateCoordinatesArray(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
};
var Polygon_default = Polygon;
function fromExtent(extent) {
  if (isEmpty2(extent)) {
    throw new Error("Cannot create polygon from empty extent");
  }
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const flatCoordinates = [
    minX,
    minY,
    minX,
    maxY,
    maxX,
    maxY,
    maxX,
    minY,
    minX,
    minY
  ];
  return new Polygon(flatCoordinates, "XY", [flatCoordinates.length]);
}

// node_modules/ol/resolutionconstraint.js
function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
  const xResolution = getWidth(maxExtent) / viewportSize[0];
  const yResolution = getHeight(maxExtent) / viewportSize[1];
  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }
  return Math.min(resolution, Math.min(xResolution, yResolution));
}
function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  let result = Math.min(resolution, maxResolution);
  const ratio = 50;
  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
  if (minResolution) {
    result = Math.max(result, minResolution);
    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
  }
  return clamp(result, minResolution / 2, maxResolution * 2);
}
function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const maxResolution = resolutions[0];
        const minResolution = resolutions[resolutions.length - 1];
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (isMoving) {
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }
        const capped = Math.min(cappedMaxRes, resolution);
        const z = Math.floor(linearFindNearest(resolutions, capped, direction));
        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
          return resolutions[z + 1];
        }
        return resolutions[z];
      }
      return void 0;
    }
  );
}
function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  minResolution = minResolution !== void 0 ? minResolution : 0;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (isMoving) {
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }
        const tolerance = 1e-9;
        const minZoomLevel = Math.ceil(
          Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance
        );
        const offset = -direction * (0.5 - tolerance) + 0.5;
        const capped = Math.min(cappedMaxRes, resolution);
        const cappedZoomLevel = Math.floor(
          Math.log(maxResolution / capped) / Math.log(power) + offset
        );
        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
        const newResolution = maxResolution / Math.pow(power, zoomLevel);
        return clamp(newResolution, minResolution, cappedMaxRes);
      }
      return void 0;
    }
  );
}
function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (!smooth || !isMoving) {
          return clamp(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(
          resolution,
          cappedMaxRes,
          minResolution
        );
      }
      return void 0;
    }
  );
}

// node_modules/ol/rotationconstraint.js
function disable(rotation) {
  if (rotation !== void 0) {
    return 0;
  }
  return void 0;
}
function none2(rotation) {
  if (rotation !== void 0) {
    return rotation;
  }
  return void 0;
}
function createSnapToN(n) {
  const theta = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(rotation, isMoving) {
      if (isMoving) {
        return rotation;
      }
      if (rotation !== void 0) {
        rotation = Math.floor(rotation / theta + 0.5) * theta;
        return rotation;
      }
      return void 0;
    }
  );
}
function createSnapToZero(tolerance) {
  const t = tolerance === void 0 ? toRadians(5) : tolerance;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(rotation, isMoving) {
      if (isMoving || rotation === void 0) {
        return rotation;
      }
      if (Math.abs(rotation) <= t) {
        return 0;
      }
      return rotation;
    }
  );
}

// node_modules/ol/tilegrid/common.js
var DEFAULT_MAX_ZOOM = 42;
var DEFAULT_TILE_SIZE = 256;

// node_modules/ol/View.js
var DEFAULT_MIN_ZOOM = 0;
var View = class extends Object_default {
  /**
   * @param {ViewOptions} [options] View options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    options = Object.assign({}, options);
    this.hints_ = [0, 0];
    this.animations_ = [];
    this.updateAnimationKey_;
    this.projection_ = createProjection(options.projection, "EPSG:3857");
    this.viewportSize_ = [100, 100];
    this.targetCenter_ = null;
    this.targetResolution_;
    this.targetRotation_;
    this.nextCenter_ = null;
    this.nextResolution_;
    this.nextRotation_;
    this.cancelAnchor_ = void 0;
    if (options.projection) {
      disableCoordinateWarning();
    }
    if (options.center) {
      options.center = fromUserCoordinate(options.center, this.projection_);
    }
    if (options.extent) {
      options.extent = fromUserExtent(options.extent, this.projection_);
    }
    this.applyOptions_(options);
  }
  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  applyOptions_(options) {
    const properties = Object.assign({}, options);
    for (const key in ViewProperty_default) {
      delete properties[key];
    }
    this.setProperties(properties, true);
    const resolutionConstraintInfo = createResolutionConstraint(options);
    this.maxResolution_ = resolutionConstraintInfo.maxResolution;
    this.minResolution_ = resolutionConstraintInfo.minResolution;
    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
    this.resolutions_ = options.resolutions;
    this.padding_ = options.padding;
    this.minZoom_ = resolutionConstraintInfo.minZoom;
    const centerConstraint = createCenterConstraint(options);
    const resolutionConstraint = resolutionConstraintInfo.constraint;
    const rotationConstraint = createRotationConstraint(options);
    this.constraints_ = {
      center: centerConstraint,
      resolution: resolutionConstraint,
      rotation: rotationConstraint
    };
    this.setRotation(options.rotation !== void 0 ? options.rotation : 0);
    this.setCenterInternal(
      options.center !== void 0 ? options.center : null
    );
    if (options.resolution !== void 0) {
      this.setResolution(options.resolution);
    } else if (options.zoom !== void 0) {
      this.setZoom(options.zoom);
    }
  }
  /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */
  get padding() {
    return this.padding_;
  }
  set padding(padding) {
    let oldPadding = this.padding_;
    this.padding_ = padding;
    const center = this.getCenterInternal();
    if (center) {
      const newPadding = padding || [0, 0, 0, 0];
      oldPadding = oldPadding || [0, 0, 0, 0];
      const resolution = this.getResolution();
      const offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
      const offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
      this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
    }
  }
  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */
  getUpdatedOptions_(newOptions) {
    const options = this.getProperties();
    if (options.resolution !== void 0) {
      options.resolution = this.getResolution();
    } else {
      options.zoom = this.getZoom();
    }
    options.center = this.getCenterInternal();
    options.rotation = this.getRotation();
    return Object.assign({}, options, newOptions);
  }
  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  animate(var_args) {
    if (this.isDef() && !this.getAnimating()) {
      this.resolveConstraints(0);
    }
    const args = new Array(arguments.length);
    for (let i = 0; i < args.length; ++i) {
      let options = arguments[i];
      if (options.center) {
        options = Object.assign({}, options);
        options.center = fromUserCoordinate(
          options.center,
          this.getProjection()
        );
      }
      if (options.anchor) {
        options = Object.assign({}, options);
        options.anchor = fromUserCoordinate(
          options.anchor,
          this.getProjection()
        );
      }
      args[i] = options;
    }
    this.animateInternal.apply(this, args);
  }
  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */
  animateInternal(var_args) {
    let animationCount = arguments.length;
    let callback;
    if (animationCount > 1 && typeof arguments[animationCount - 1] === "function") {
      callback = arguments[animationCount - 1];
      --animationCount;
    }
    let i = 0;
    for (; i < animationCount && !this.isDef(); ++i) {
      const state = arguments[i];
      if (state.center) {
        this.setCenterInternal(state.center);
      }
      if (state.zoom !== void 0) {
        this.setZoom(state.zoom);
      } else if (state.resolution) {
        this.setResolution(state.resolution);
      }
      if (state.rotation !== void 0) {
        this.setRotation(state.rotation);
      }
    }
    if (i === animationCount) {
      if (callback) {
        animationCallback(callback, true);
      }
      return;
    }
    let start = Date.now();
    let center = this.targetCenter_.slice();
    let resolution = this.targetResolution_;
    let rotation = this.targetRotation_;
    const series = [];
    for (; i < animationCount; ++i) {
      const options = (
        /** @type {AnimationOptions} */
        arguments[i]
      );
      const animation = {
        start,
        complete: false,
        anchor: options.anchor,
        duration: options.duration !== void 0 ? options.duration : 1e3,
        easing: options.easing || inAndOut,
        callback
      };
      if (options.center) {
        animation.sourceCenter = center;
        animation.targetCenter = options.center.slice();
        center = animation.targetCenter;
      }
      if (options.zoom !== void 0) {
        animation.sourceResolution = resolution;
        animation.targetResolution = this.getResolutionForZoom(options.zoom);
        resolution = animation.targetResolution;
      } else if (options.resolution) {
        animation.sourceResolution = resolution;
        animation.targetResolution = options.resolution;
        resolution = animation.targetResolution;
      }
      if (options.rotation !== void 0) {
        animation.sourceRotation = rotation;
        const delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
        animation.targetRotation = rotation + delta;
        rotation = animation.targetRotation;
      }
      if (isNoopAnimation(animation)) {
        animation.complete = true;
      } else {
        start += animation.duration;
      }
      series.push(animation);
    }
    this.animations_.push(series);
    this.setHint(ViewHint_default.ANIMATING, 1);
    this.updateAnimations_();
  }
  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  getAnimating() {
    return this.hints_[ViewHint_default.ANIMATING] > 0;
  }
  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  getInteracting() {
    return this.hints_[ViewHint_default.INTERACTING] > 0;
  }
  /**
   * Cancel any ongoing animations.
   * @api
   */
  cancelAnimations() {
    this.setHint(ViewHint_default.ANIMATING, -this.hints_[ViewHint_default.ANIMATING]);
    let anchor;
    for (let i = 0, ii = this.animations_.length; i < ii; ++i) {
      const series = this.animations_[i];
      if (series[0].callback) {
        animationCallback(series[0].callback, false);
      }
      if (!anchor) {
        for (let j = 0, jj = series.length; j < jj; ++j) {
          const animation = series[j];
          if (!animation.complete) {
            anchor = animation.anchor;
            break;
          }
        }
      }
    }
    this.animations_.length = 0;
    this.cancelAnchor_ = anchor;
    this.nextCenter_ = null;
    this.nextResolution_ = NaN;
    this.nextRotation_ = NaN;
  }
  /**
   * Update all animations.
   */
  updateAnimations_() {
    if (this.updateAnimationKey_ !== void 0) {
      cancelAnimationFrame(this.updateAnimationKey_);
      this.updateAnimationKey_ = void 0;
    }
    if (!this.getAnimating()) {
      return;
    }
    const now = Date.now();
    let more = false;
    for (let i = this.animations_.length - 1; i >= 0; --i) {
      const series = this.animations_[i];
      let seriesComplete = true;
      for (let j = 0, jj = series.length; j < jj; ++j) {
        const animation = series[j];
        if (animation.complete) {
          continue;
        }
        const elapsed = now - animation.start;
        let fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
        if (fraction >= 1) {
          animation.complete = true;
          fraction = 1;
        } else {
          seriesComplete = false;
        }
        const progress = animation.easing(fraction);
        if (animation.sourceCenter) {
          const x0 = animation.sourceCenter[0];
          const y0 = animation.sourceCenter[1];
          const x1 = animation.targetCenter[0];
          const y1 = animation.targetCenter[1];
          this.nextCenter_ = animation.targetCenter;
          const x = x0 + progress * (x1 - x0);
          const y = y0 + progress * (y1 - y0);
          this.targetCenter_ = [x, y];
        }
        if (animation.sourceResolution && animation.targetResolution) {
          const resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
          if (animation.anchor) {
            const size = this.getViewportSize_(this.getRotation());
            const constrainedResolution = this.constraints_.resolution(
              resolution,
              0,
              size,
              true
            );
            this.targetCenter_ = this.calculateCenterZoom(
              constrainedResolution,
              animation.anchor
            );
          }
          this.nextResolution_ = animation.targetResolution;
          this.targetResolution_ = resolution;
          this.applyTargetState_(true);
        }
        if (animation.sourceRotation !== void 0 && animation.targetRotation !== void 0) {
          const rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
          if (animation.anchor) {
            const constrainedRotation = this.constraints_.rotation(
              rotation,
              true
            );
            this.targetCenter_ = this.calculateCenterRotate(
              constrainedRotation,
              animation.anchor
            );
          }
          this.nextRotation_ = animation.targetRotation;
          this.targetRotation_ = rotation;
        }
        this.applyTargetState_(true);
        more = true;
        if (!animation.complete) {
          break;
        }
      }
      if (seriesComplete) {
        this.animations_[i] = null;
        this.setHint(ViewHint_default.ANIMATING, -1);
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
        const callback = series[0].callback;
        if (callback) {
          animationCallback(callback, true);
        }
      }
    }
    this.animations_ = this.animations_.filter(Boolean);
    if (more && this.updateAnimationKey_ === void 0) {
      this.updateAnimationKey_ = requestAnimationFrame(
        this.updateAnimations_.bind(this)
      );
    }
  }
  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */
  calculateCenterRotate(rotation, anchor) {
    let center;
    const currentCenter = this.getCenterInternal();
    if (currentCenter !== void 0) {
      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
      rotate(center, rotation - this.getRotation());
      add(center, anchor);
    }
    return center;
  }
  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */
  calculateCenterZoom(resolution, anchor) {
    let center;
    const currentCenter = this.getCenterInternal();
    const currentResolution = this.getResolution();
    if (currentCenter !== void 0 && currentResolution !== void 0) {
      const x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
      const y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
      center = [x, y];
    }
    return center;
  }
  /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  getViewportSize_(rotation) {
    const size = this.viewportSize_;
    if (rotation) {
      const w = size[0];
      const h = size[1];
      return [
        Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)),
        Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation))
      ];
    }
    return size;
  }
  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */
  setViewportSize(size) {
    this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];
    if (!this.getAnimating()) {
      this.resolveConstraints(0);
    }
  }
  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  getCenter() {
    const center = this.getCenterInternal();
    if (!center) {
      return center;
    }
    return toUserCoordinate(center, this.getProjection());
  }
  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */
  getCenterInternal() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(ViewProperty_default.CENTER)
    );
  }
  /**
   * @return {Constraints} Constraints.
   */
  getConstraints() {
    return this.constraints_;
  }
  /**
   * @return {boolean} Resolution constraint is set
   */
  getConstrainResolution() {
    return this.get("constrainResolution");
  }
  /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */
  getHints(hints) {
    if (hints !== void 0) {
      hints[0] = this.hints_[0];
      hints[1] = this.hints_[1];
      return hints;
    }
    return this.hints_.slice();
  }
  /**
   * Calculate the extent for the current view state and the passed box size.
   * @param {import("./size.js").Size} [size] The pixel dimensions of the box
   * into which the calculated extent should fit. Defaults to the size of the
   * map the view is associated with.
   * If no map or multiple maps are connected to the view, provide the desired
   * box size (e.g. `map.getSize()`).
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */
  calculateExtent(size) {
    const extent = this.calculateExtentInternal(size);
    return toUserExtent(extent, this.getProjection());
  }
  /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */
  calculateExtentInternal(size) {
    size = size || this.getViewportSizeMinusPadding_();
    const center = (
      /** @type {!import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    assert(center, "The view center is not defined");
    const resolution = (
      /** @type {!number} */
      this.getResolution()
    );
    assert(resolution !== void 0, "The view resolution is not defined");
    const rotation = (
      /** @type {!number} */
      this.getRotation()
    );
    assert(rotation !== void 0, "The view rotation is not defined");
    return getForViewAndSize(center, resolution, rotation, size);
  }
  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  getMaxResolution() {
    return this.maxResolution_;
  }
  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  getMinResolution() {
    return this.minResolution_;
  }
  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.minResolution_)
    );
  }
  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  setMaxZoom(zoom) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
  }
  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.maxResolution_)
    );
  }
  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  setMinZoom(zoom) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
  }
  /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */
  setConstrainResolution(enabled) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
  }
  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */
  getProjection() {
    return this.projection_;
  }
  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  getResolution() {
    return (
      /** @type {number|undefined} */
      this.get(ViewProperty_default.RESOLUTION)
    );
  }
  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  getResolutionForExtent(extent, size) {
    return this.getResolutionForExtentInternal(
      fromUserExtent(extent, this.getProjection()),
      size
    );
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */
  getResolutionForExtentInternal(extent, size) {
    size = size || this.getViewportSizeMinusPadding_();
    const xResolution = getWidth(extent) / size[0];
    const yResolution = getHeight(extent) / size[1];
    return Math.max(xResolution, yResolution);
  }
  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */
  getResolutionForValueFunction(power) {
    power = power || 2;
    const maxResolution = this.getConstrainedResolution(this.maxResolution_);
    const minResolution = this.minResolution_;
    const max = Math.log(maxResolution / minResolution) / Math.log(power);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function(value) {
        const resolution = maxResolution / Math.pow(power, value * max);
        return resolution;
      }
    );
  }
  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  getRotation() {
    return (
      /** @type {number} */
      this.get(ViewProperty_default.ROTATION)
    );
  }
  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */
  getValueForResolutionFunction(power) {
    const logPower = Math.log(power || 2);
    const maxResolution = this.getConstrainedResolution(this.maxResolution_);
    const minResolution = this.minResolution_;
    const max = Math.log(maxResolution / minResolution) / logPower;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function(resolution) {
        const value = Math.log(maxResolution / resolution) / logPower / max;
        return value;
      }
    );
  }
  /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */
  getViewportSizeMinusPadding_(rotation) {
    let size = this.getViewportSize_(rotation);
    const padding = this.padding_;
    if (padding) {
      size = [
        size[0] - padding[1] - padding[3],
        size[1] - padding[0] - padding[2]
      ];
    }
    return size;
  }
  /**
   * @return {State} View state.
   */
  getState() {
    const projection = this.getProjection();
    const resolution = this.getResolution();
    const rotation = this.getRotation();
    let center = (
      /** @type {import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    const padding = this.padding_;
    if (padding) {
      const reducedSize = this.getViewportSizeMinusPadding_();
      center = calculateCenterOn(
        center,
        this.getViewportSize_(),
        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
        resolution,
        rotation
      );
    }
    return {
      center: center.slice(0),
      projection: projection !== void 0 ? projection : null,
      resolution,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation,
      zoom: this.getZoom()
    };
  }
  /**
   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
   */
  getViewStateAndExtent() {
    return {
      viewState: this.getState(),
      extent: this.calculateExtent()
    };
  }
  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */
  getZoom() {
    let zoom;
    const resolution = this.getResolution();
    if (resolution !== void 0) {
      zoom = this.getZoomForResolution(resolution);
    }
    return zoom;
  }
  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  getZoomForResolution(resolution) {
    let offset = this.minZoom_ || 0;
    let max, zoomFactor;
    if (this.resolutions_) {
      const nearest = linearFindNearest(this.resolutions_, resolution, 1);
      offset = nearest;
      max = this.resolutions_[nearest];
      if (nearest == this.resolutions_.length - 1) {
        zoomFactor = 2;
      } else {
        zoomFactor = max / this.resolutions_[nearest + 1];
      }
    } else {
      max = this.maxResolution_;
      zoomFactor = this.zoomFactor_;
    }
    return offset + Math.log(max / resolution) / Math.log(zoomFactor);
  }
  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  getResolutionForZoom(zoom) {
    if (this.resolutions_?.length) {
      if (this.resolutions_.length === 1) {
        return this.resolutions_[0];
      }
      const baseLevel = clamp(
        Math.floor(zoom),
        0,
        this.resolutions_.length - 2
      );
      const zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
      return this.resolutions_[baseLevel] / Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1));
    }
    return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
  }
  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */
  fit(geometryOrExtent, options) {
    let geometry;
    assert(
      Array.isArray(geometryOrExtent) || typeof /** @type {?} */
      geometryOrExtent.getSimplifiedGeometry === "function",
      "Invalid extent or geometry provided as `geometry`"
    );
    if (Array.isArray(geometryOrExtent)) {
      assert(
        !isEmpty2(geometryOrExtent),
        "Cannot fit empty extent provided as `geometry`"
      );
      const extent = fromUserExtent(geometryOrExtent, this.getProjection());
      geometry = fromExtent(extent);
    } else if (geometryOrExtent.getType() === "Circle") {
      const extent = fromUserExtent(
        geometryOrExtent.getExtent(),
        this.getProjection()
      );
      geometry = fromExtent(extent);
      geometry.rotate(this.getRotation(), getCenter(extent));
    } else {
      const userProjection2 = getUserProjection();
      if (userProjection2) {
        geometry = /** @type {import("./geom/SimpleGeometry.js").default} */
        geometryOrExtent.clone().transform(userProjection2, this.getProjection());
      } else {
        geometry = geometryOrExtent;
      }
    }
    this.fitInternal(geometry, options);
  }
  /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */
  rotatedExtentForGeometry(geometry) {
    const rotation = this.getRotation();
    const cosAngle = Math.cos(rotation);
    const sinAngle = Math.sin(-rotation);
    const coords = geometry.getFlatCoordinates();
    const stride = geometry.getStride();
    let minRotX = Infinity;
    let minRotY = Infinity;
    let maxRotX = -Infinity;
    let maxRotY = -Infinity;
    for (let i = 0, ii = coords.length; i < ii; i += stride) {
      const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
      const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
      minRotX = Math.min(minRotX, rotX);
      minRotY = Math.min(minRotY, rotY);
      maxRotX = Math.max(maxRotX, rotX);
      maxRotY = Math.max(maxRotY, rotY);
    }
    return [minRotX, minRotY, maxRotX, maxRotY];
  }
  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */
  fitInternal(geometry, options) {
    options = options || {};
    let size = options.size;
    if (!size) {
      size = this.getViewportSizeMinusPadding_();
    }
    const padding = options.padding !== void 0 ? options.padding : [0, 0, 0, 0];
    const nearest = options.nearest !== void 0 ? options.nearest : false;
    let minResolution;
    if (options.minResolution !== void 0) {
      minResolution = options.minResolution;
    } else if (options.maxZoom !== void 0) {
      minResolution = this.getResolutionForZoom(options.maxZoom);
    } else {
      minResolution = 0;
    }
    const rotatedExtent = this.rotatedExtentForGeometry(geometry);
    let resolution = this.getResolutionForExtentInternal(rotatedExtent, [
      size[0] - padding[1] - padding[3],
      size[1] - padding[0] - padding[2]
    ]);
    resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
    const rotation = this.getRotation();
    const sinAngle = Math.sin(rotation);
    const cosAngle = Math.cos(rotation);
    const centerRot = getCenter(rotatedExtent);
    centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
    centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
    const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
    const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
    const center = this.getConstrainedCenter([centerX, centerY], resolution);
    const callback = options.callback ? options.callback : VOID;
    if (options.duration !== void 0) {
      this.animateInternal(
        {
          resolution,
          center,
          duration: options.duration,
          easing: options.easing
        },
        callback
      );
    } else {
      this.targetResolution_ = resolution;
      this.targetCenter_ = center;
      this.applyTargetState_(false, true);
      animationCallback(callback, true);
    }
  }
  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */
  centerOn(coordinate, size, position) {
    this.centerOnInternal(
      fromUserCoordinate(coordinate, this.getProjection()),
      size,
      position
    );
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */
  centerOnInternal(coordinate, size, position) {
    this.setCenterInternal(
      calculateCenterOn(
        coordinate,
        size,
        position,
        this.getResolution(),
        this.getRotation()
      )
    );
  }
  /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */
  calculateCenterShift(center, resolution, rotation, size) {
    let centerShift;
    const padding = this.padding_;
    if (padding && center) {
      const reducedSize = this.getViewportSizeMinusPadding_(-rotation);
      const shiftedCenter = calculateCenterOn(
        center,
        size,
        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
        resolution,
        rotation
      );
      centerShift = [
        center[0] - shiftedCenter[0],
        center[1] - shiftedCenter[1]
      ];
    }
    return centerShift;
  }
  /**
   * @return {boolean} Is defined.
   */
  isDef() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */
  adjustCenter(deltaCoordinates) {
    const center = toUserCoordinate(this.targetCenter_, this.getProjection());
    this.setCenter([
      center[0] + deltaCoordinates[0],
      center[1] + deltaCoordinates[1]
    ]);
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */
  adjustCenterInternal(deltaCoordinates) {
    const center = this.targetCenter_;
    this.setCenterInternal([
      center[0] + deltaCoordinates[0],
      center[1] + deltaCoordinates[1]
    ]);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustResolution(ratio, anchor) {
    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
    this.adjustResolutionInternal(ratio, anchor);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  adjustResolutionInternal(ratio, anchor) {
    const isMoving = this.getAnimating() || this.getInteracting();
    const size = this.getViewportSize_(this.getRotation());
    const newResolution = this.constraints_.resolution(
      this.targetResolution_ * ratio,
      0,
      size,
      isMoving
    );
    if (anchor) {
      this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
    }
    this.targetResolution_ *= ratio;
    this.applyTargetState_();
  }
  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustZoom(delta, anchor) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
  }
  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */
  adjustRotation(delta, anchor) {
    if (anchor) {
      anchor = fromUserCoordinate(anchor, this.getProjection());
    }
    this.adjustRotationInternal(delta, anchor);
  }
  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */
  adjustRotationInternal(delta, anchor) {
    const isMoving = this.getAnimating() || this.getInteracting();
    const newRotation = this.constraints_.rotation(
      this.targetRotation_ + delta,
      isMoving
    );
    if (anchor) {
      this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
    }
    this.targetRotation_ += delta;
    this.applyTargetState_();
  }
  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  setCenter(center) {
    this.setCenterInternal(
      center ? fromUserCoordinate(center, this.getProjection()) : center
    );
  }
  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */
  setCenterInternal(center) {
    this.targetCenter_ = center;
    this.applyTargetState_();
  }
  /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  setHint(hint, delta) {
    this.hints_[hint] += delta;
    this.changed();
    return this.hints_[hint];
  }
  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  setResolution(resolution) {
    this.targetResolution_ = resolution;
    this.applyTargetState_();
  }
  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  setRotation(rotation) {
    this.targetRotation_ = rotation;
    this.applyTargetState_();
  }
  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */
  setZoom(zoom) {
    this.setResolution(this.getResolutionForZoom(zoom));
  }
  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */
  applyTargetState_(doNotCancelAnims, forceMoving) {
    const isMoving = this.getAnimating() || this.getInteracting() || forceMoving;
    const newRotation = this.constraints_.rotation(
      this.targetRotation_,
      isMoving
    );
    const size = this.getViewportSize_(newRotation);
    const newResolution = this.constraints_.resolution(
      this.targetResolution_,
      0,
      size,
      isMoving
    );
    const newCenter = this.constraints_.center(
      this.targetCenter_,
      newResolution,
      size,
      isMoving,
      this.calculateCenterShift(
        this.targetCenter_,
        newResolution,
        newRotation,
        size
      )
    );
    if (this.get(ViewProperty_default.ROTATION) !== newRotation) {
      this.set(ViewProperty_default.ROTATION, newRotation);
    }
    if (this.get(ViewProperty_default.RESOLUTION) !== newResolution) {
      this.set(ViewProperty_default.RESOLUTION, newResolution);
      this.set("zoom", this.getZoom(), true);
    }
    if (!newCenter || !this.get(ViewProperty_default.CENTER) || !equals3(this.get(ViewProperty_default.CENTER), newCenter)) {
      this.set(ViewProperty_default.CENTER, newCenter);
    }
    if (this.getAnimating() && !doNotCancelAnims) {
      this.cancelAnimations();
    }
    this.cancelAnchor_ = void 0;
  }
  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  resolveConstraints(duration, resolutionDirection, anchor) {
    duration = duration !== void 0 ? duration : 200;
    const direction = resolutionDirection || 0;
    const newRotation = this.constraints_.rotation(this.targetRotation_);
    const size = this.getViewportSize_(newRotation);
    const newResolution = this.constraints_.resolution(
      this.targetResolution_,
      direction,
      size
    );
    const newCenter = this.constraints_.center(
      this.targetCenter_,
      newResolution,
      size,
      false,
      this.calculateCenterShift(
        this.targetCenter_,
        newResolution,
        newRotation,
        size
      )
    );
    if (duration === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = newResolution;
      this.targetRotation_ = newRotation;
      this.targetCenter_ = newCenter;
      this.applyTargetState_();
      return;
    }
    anchor = anchor || (duration === 0 ? this.cancelAnchor_ : void 0);
    this.cancelAnchor_ = void 0;
    if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !equals3(this.getCenterInternal(), newCenter)) {
      if (this.getAnimating()) {
        this.cancelAnimations();
      }
      this.animateInternal({
        rotation: newRotation,
        center: newCenter,
        resolution: newResolution,
        duration,
        easing: easeOut,
        anchor
      });
    }
  }
  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */
  beginInteraction() {
    this.resolveConstraints(0);
    this.setHint(ViewHint_default.INTERACTING, 1);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  endInteraction(duration, resolutionDirection, anchor) {
    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
    this.endInteractionInternal(duration, resolutionDirection, anchor);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  endInteractionInternal(duration, resolutionDirection, anchor) {
    if (!this.getInteracting()) {
      return;
    }
    this.setHint(ViewHint_default.INTERACTING, -1);
    this.resolveConstraints(duration, resolutionDirection, anchor);
  }
  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */
  getConstrainedCenter(targetCenter, targetResolution) {
    const size = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(
      targetCenter,
      targetResolution || this.getResolution(),
      size
    );
  }
  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */
  getConstrainedZoom(targetZoom, direction) {
    const targetRes = this.getResolutionForZoom(targetZoom);
    return this.getZoomForResolution(
      this.getConstrainedResolution(targetRes, direction)
    );
  }
  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */
  getConstrainedResolution(targetResolution, direction) {
    direction = direction || 0;
    const size = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(targetResolution, direction, size);
  }
};
function animationCallback(callback, returnValue) {
  setTimeout(function() {
    callback(returnValue);
  }, 0);
}
function createCenterConstraint(options) {
  if (options.extent !== void 0) {
    const smooth = options.smoothExtentConstraint !== void 0 ? options.smoothExtentConstraint : true;
    return createExtent(options.extent, options.constrainOnlyCenter, smooth);
  }
  const projection = createProjection(options.projection, "EPSG:3857");
  if (options.multiWorld !== true && projection.isGlobal()) {
    const extent = projection.getExtent().slice();
    extent[0] = -Infinity;
    extent[2] = Infinity;
    return createExtent(extent, false, false);
  }
  return none;
}
function createResolutionConstraint(options) {
  let resolutionConstraint;
  let maxResolution;
  let minResolution;
  const defaultMaxZoom = 28;
  const defaultZoomFactor = 2;
  let minZoom = options.minZoom !== void 0 ? options.minZoom : DEFAULT_MIN_ZOOM;
  let maxZoom = options.maxZoom !== void 0 ? options.maxZoom : defaultMaxZoom;
  const zoomFactor = options.zoomFactor !== void 0 ? options.zoomFactor : defaultZoomFactor;
  const multiWorld = options.multiWorld !== void 0 ? options.multiWorld : false;
  const smooth = options.smoothResolutionConstraint !== void 0 ? options.smoothResolutionConstraint : true;
  const showFullExtent = options.showFullExtent !== void 0 ? options.showFullExtent : false;
  const projection = createProjection(options.projection, "EPSG:3857");
  const projExtent = projection.getExtent();
  let constrainOnlyCenter = options.constrainOnlyCenter;
  let extent = options.extent;
  if (!multiWorld && !extent && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent = projExtent;
  }
  if (options.resolutions !== void 0) {
    const resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== void 0 ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToResolutions(
        resolutions,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  } else {
    const size = !projExtent ? (
      // use an extent that can fit the whole world if need be
      360 * METERS_PER_UNIT.degrees / projection.getMetersPerUnit()
    ) : Math.max(getWidth(projExtent), getHeight(projExtent));
    const defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
    const defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
    maxResolution = options.maxResolution;
    if (maxResolution !== void 0) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }
    minResolution = options.minResolution;
    if (minResolution === void 0) {
      if (options.maxZoom !== void 0) {
        if (options.maxResolution !== void 0) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }
    maxZoom = minZoom + Math.floor(
      Math.log(maxResolution / minResolution) / Math.log(zoomFactor)
    );
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToPower(
        zoomFactor,
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  }
  return {
    constraint: resolutionConstraint,
    maxResolution,
    minResolution,
    minZoom,
    zoomFactor
  };
}
function createRotationConstraint(options) {
  const enableRotation = options.enableRotation !== void 0 ? options.enableRotation : true;
  if (enableRotation) {
    const constrainRotation = options.constrainRotation;
    if (constrainRotation === void 0 || constrainRotation === true) {
      return createSnapToZero();
    }
    if (constrainRotation === false) {
      return none2;
    }
    if (typeof constrainRotation === "number") {
      return createSnapToN(constrainRotation);
    }
    return none2;
  }
  return disable;
}
function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!equals3(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
}
function calculateCenterOn(coordinate, size, position, resolution, rotation) {
  const cosAngle = Math.cos(-rotation);
  let sinAngle = Math.sin(-rotation);
  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution;
  sinAngle = -sinAngle;
  const centerX = rotX * cosAngle - rotY * sinAngle;
  const centerY = rotY * cosAngle + rotX * sinAngle;
  return [centerX, centerY];
}
var View_default = View;

// node_modules/ol/css.js
var CLASS_HIDDEN = "ol-hidden";
var CLASS_SELECTABLE = "ol-selectable";
var CLASS_UNSELECTABLE = "ol-unselectable";
var CLASS_UNSUPPORTED = "ol-unsupported";
var CLASS_CONTROL = "ol-control";
var CLASS_COLLAPSED = "ol-collapsed";
var fontRegEx = new RegExp(
  [
    "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
    "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
    "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
    "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
    `?\\s*([-,\\"\\'\\sa-z0-9]+?)\\s*$`
  ].join(""),
  "i"
);
var fontRegExMatchIndex = [
  "style",
  "variant",
  "weight",
  "size",
  "lineHeight",
  "family"
];
var getFontParameters = function(fontSpec) {
  const match = fontSpec.match(fontRegEx);
  if (!match) {
    return null;
  }
  const style = (
    /** @type {FontParameters} */
    {
      lineHeight: "normal",
      size: "1.2em",
      style: "normal",
      weight: "normal",
      variant: "normal"
    }
  );
  for (let i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
    const value = match[i + 1];
    if (value !== void 0) {
      style[fontRegExMatchIndex[i]] = value;
    }
  }
  style.families = style.family.split(/,\s?/);
  return style;
};

// node_modules/ol/dom.js
function createCanvasContext2D(width, height, canvasPool3, settings) {
  let canvas;
  if (canvasPool3 && canvasPool3.length) {
    canvas = /** @type {HTMLCanvasElement} */
    canvasPool3.shift();
  } else if (WORKER_OFFSCREEN_CANVAS) {
    canvas = new OffscreenCanvas(width || 300, height || 300);
  } else {
    canvas = document.createElement("canvas");
  }
  if (width) {
    canvas.width = width;
  }
  if (height) {
    canvas.height = height;
  }
  return (
    /** @type {CanvasRenderingContext2D} */
    canvas.getContext("2d", settings)
  );
}
var sharedCanvasContext;
function getSharedCanvasContext2D() {
  if (!sharedCanvasContext) {
    sharedCanvasContext = createCanvasContext2D(1, 1);
  }
  return sharedCanvasContext;
}
function releaseCanvas(context) {
  const canvas = context.canvas;
  canvas.width = 1;
  canvas.height = 1;
  context.clearRect(0, 0, 1, 1);
}
function outerWidth(element) {
  let width = element.offsetWidth;
  const style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
  return width;
}
function outerHeight(element) {
  let height = element.offsetHeight;
  const style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
  return height;
}
function replaceNode(newNode, oldNode) {
  const parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}
function removeChildren(node) {
  while (node.lastChild) {
    node.lastChild.remove();
  }
}
function replaceChildren(node, children) {
  const oldChildren = node.childNodes;
  for (let i = 0; true; ++i) {
    const oldChild = oldChildren[i];
    const newChild = children[i];
    if (!oldChild && !newChild) {
      break;
    }
    if (oldChild === newChild) {
      continue;
    }
    if (!oldChild) {
      node.appendChild(newChild);
      continue;
    }
    if (!newChild) {
      node.removeChild(oldChild);
      --i;
      continue;
    }
    node.insertBefore(newChild, oldChild);
  }
}

// node_modules/ol/control/Control.js
var Control = class extends Object_default {
  /**
   * @param {Options} options Control options.
   */
  constructor(options) {
    super();
    const element = options.element;
    if (element && !options.target && !element.style.pointerEvents) {
      element.style.pointerEvents = "auto";
    }
    this.element = element ? element : null;
    this.target_ = null;
    this.map_ = null;
    this.listenerKeys = [];
    if (options.render) {
      this.render = options.render;
    }
    if (options.target) {
      this.setTarget(options.target);
    }
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.element?.remove();
    super.disposeInternal();
  }
  /**
   * Get the map associated with this control.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(map) {
    if (this.map_) {
      this.element?.remove();
    }
    for (let i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
      unlistenByKey(this.listenerKeys[i]);
    }
    this.listenerKeys.length = 0;
    this.map_ = map;
    if (map) {
      const target = this.target_ ?? map.getOverlayContainerStopEvent();
      if (this.element) {
        target.appendChild(this.element);
      }
      if (this.render !== VOID) {
        this.listenerKeys.push(
          listen(map, MapEventType_default.POSTRENDER, this.render, this)
        );
      }
      map.render();
    }
  }
  /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */
  render(mapEvent) {
  }
  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */
  setTarget(target) {
    this.target_ = typeof target === "string" ? document.getElementById(target) : target;
  }
};
var Control_default = Control;

// node_modules/ol/control/Attribution.js
var Attribution = class extends Control_default {
  /**
   * @param {Options} [options] Attribution options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    });
    this.ulElement_ = document.createElement("ul");
    this.collapsed_ = options.collapsed !== void 0 ? options.collapsed : true;
    this.userCollapsed_ = this.collapsed_;
    this.overrideCollapsible_ = options.collapsible !== void 0;
    this.collapsible_ = options.collapsible !== void 0 ? options.collapsible : true;
    if (!this.collapsible_) {
      this.collapsed_ = false;
    }
    this.attributions_ = options.attributions;
    const className = options.className !== void 0 ? options.className : "ol-attribution";
    const tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Attributions";
    const expandClassName = options.expandClassName !== void 0 ? options.expandClassName : className + "-expand";
    const collapseLabel = options.collapseLabel !== void 0 ? options.collapseLabel : "\u203A";
    const collapseClassName = options.collapseClassName !== void 0 ? options.collapseClassName : className + "-collapse";
    if (typeof collapseLabel === "string") {
      this.collapseLabel_ = document.createElement("span");
      this.collapseLabel_.textContent = collapseLabel;
      this.collapseLabel_.className = collapseClassName;
    } else {
      this.collapseLabel_ = collapseLabel;
    }
    const label = options.label !== void 0 ? options.label : "i";
    if (typeof label === "string") {
      this.label_ = document.createElement("span");
      this.label_.textContent = label;
      this.label_.className = expandClassName;
    } else {
      this.label_ = label;
    }
    const activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
    this.toggleButton_ = document.createElement("button");
    this.toggleButton_.setAttribute("type", "button");
    this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
    this.toggleButton_.title = tipLabel;
    this.toggleButton_.appendChild(activeLabel);
    this.toggleButton_.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this),
      false
    );
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? " " + CLASS_COLLAPSED : "") + (this.collapsible_ ? "" : " ol-uncollapsible");
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(this.toggleButton_);
    element.appendChild(this.ulElement_);
    this.renderedAttributions_ = [];
    this.renderedVisible_ = true;
  }
  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  collectSourceAttributions_(frameState) {
    const layers = this.getMap().getAllLayers();
    const visibleAttributions = new Set(
      layers.flatMap((layer) => layer.getAttributions(frameState))
    );
    if (this.attributions_ !== void 0) {
      Array.isArray(this.attributions_) ? this.attributions_.forEach((item) => visibleAttributions.add(item)) : visibleAttributions.add(this.attributions_);
    }
    if (!this.overrideCollapsible_) {
      const collapsible = !layers.some(
        (layer) => layer.getSource()?.getAttributionsCollapsible() === false
      );
      this.setCollapsible(collapsible);
    }
    return Array.from(visibleAttributions);
  }
  /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  async updateElement_(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    const attributions = await Promise.all(
      this.collectSourceAttributions_(frameState).map(
        (attribution) => toPromise(() => attribution)
      )
    );
    const visible = attributions.length > 0;
    if (this.renderedVisible_ != visible) {
      this.element.style.display = visible ? "" : "none";
      this.renderedVisible_ = visible;
    }
    if (equals(attributions, this.renderedAttributions_)) {
      return;
    }
    removeChildren(this.ulElement_);
    for (let i = 0, ii = attributions.length; i < ii; ++i) {
      const element = document.createElement("li");
      element.innerHTML = attributions[i];
      this.ulElement_.appendChild(element);
    }
    this.renderedAttributions_ = attributions;
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(event) {
    event.preventDefault();
    this.handleToggle_();
    this.userCollapsed_ = this.collapsed_;
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(CLASS_COLLAPSED);
    if (this.collapsed_) {
      replaceNode(this.collapseLabel_, this.label_);
    } else {
      replaceNode(this.label_, this.collapseLabel_);
    }
    this.collapsed_ = !this.collapsed_;
    this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  }
  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }
    this.collapsible_ = collapsible;
    this.element.classList.toggle("ol-uncollapsible");
    if (this.userCollapsed_) {
      this.handleToggle_();
    }
  }
  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(collapsed) {
    this.userCollapsed_ = collapsed;
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }
    this.handleToggle_();
  }
  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    this.updateElement_(mapEvent.frameState);
  }
};
var Attribution_default = Attribution;

// node_modules/ol/control/Rotate.js
var Rotate = class extends Control_default {
  /**
   * @param {Options} [options] Rotate options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    });
    const className = options.className !== void 0 ? options.className : "ol-rotate";
    const label = options.label !== void 0 ? options.label : "\u21E7";
    const compassClassName = options.compassClassName !== void 0 ? options.compassClassName : "ol-compass";
    this.label_ = null;
    if (typeof label === "string") {
      this.label_ = document.createElement("span");
      this.label_.className = compassClassName;
      this.label_.textContent = label;
    } else {
      this.label_ = label;
      this.label_.classList.add(compassClassName);
    }
    const tipLabel = options.tipLabel ? options.tipLabel : "Reset rotation";
    const button = document.createElement("button");
    button.className = className + "-reset";
    button.setAttribute("type", "button");
    button.title = tipLabel;
    button.appendChild(this.label_);
    button.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this),
      false
    );
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(button);
    this.callResetNorth_ = options.resetNorth ? options.resetNorth : void 0;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
    this.autoHide_ = options.autoHide !== void 0 ? options.autoHide : true;
    this.rotation_ = void 0;
    if (this.autoHide_) {
      this.element.classList.add(CLASS_HIDDEN);
    }
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(event) {
    event.preventDefault();
    if (this.callResetNorth_ !== void 0) {
      this.callResetNorth_();
    } else {
      this.resetNorth_();
    }
  }
  /**
   * @private
   */
  resetNorth_() {
    const map = this.getMap();
    const view = map.getView();
    if (!view) {
      return;
    }
    const rotation = view.getRotation();
    if (rotation !== void 0) {
      if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
        view.animate({
          rotation: 0,
          duration: this.duration_,
          easing: easeOut
        });
      } else {
        view.setRotation(0);
      }
    }
  }
  /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    const frameState = mapEvent.frameState;
    if (!frameState) {
      return;
    }
    const rotation = frameState.viewState.rotation;
    if (rotation != this.rotation_) {
      const transform2 = "rotate(" + rotation + "rad)";
      if (this.autoHide_) {
        const contains2 = this.element.classList.contains(CLASS_HIDDEN);
        if (!contains2 && rotation === 0) {
          this.element.classList.add(CLASS_HIDDEN);
        } else if (contains2 && rotation !== 0) {
          this.element.classList.remove(CLASS_HIDDEN);
        }
      }
      this.label_.style.transform = transform2;
    }
    this.rotation_ = rotation;
  }
};
var Rotate_default = Rotate;

// node_modules/ol/control/Zoom.js
var Zoom = class extends Control_default {
  /**
   * @param {Options} [options] Zoom options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      target: options.target
    });
    const className = options.className !== void 0 ? options.className : "ol-zoom";
    const delta = options.delta !== void 0 ? options.delta : 1;
    const zoomInClassName = options.zoomInClassName !== void 0 ? options.zoomInClassName : className + "-in";
    const zoomOutClassName = options.zoomOutClassName !== void 0 ? options.zoomOutClassName : className + "-out";
    const zoomInLabel = options.zoomInLabel !== void 0 ? options.zoomInLabel : "+";
    const zoomOutLabel = options.zoomOutLabel !== void 0 ? options.zoomOutLabel : "\u2013";
    const zoomInTipLabel = options.zoomInTipLabel !== void 0 ? options.zoomInTipLabel : "Zoom in";
    const zoomOutTipLabel = options.zoomOutTipLabel !== void 0 ? options.zoomOutTipLabel : "Zoom out";
    const inElement = document.createElement("button");
    inElement.className = zoomInClassName;
    inElement.setAttribute("type", "button");
    inElement.title = zoomInTipLabel;
    inElement.appendChild(
      typeof zoomInLabel === "string" ? document.createTextNode(zoomInLabel) : zoomInLabel
    );
    inElement.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this, delta),
      false
    );
    const outElement = document.createElement("button");
    outElement.className = zoomOutClassName;
    outElement.setAttribute("type", "button");
    outElement.title = zoomOutTipLabel;
    outElement.appendChild(
      typeof zoomOutLabel === "string" ? document.createTextNode(zoomOutLabel) : zoomOutLabel
    );
    outElement.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this, -delta),
      false
    );
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(inElement);
    element.appendChild(outElement);
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(delta, event) {
    event.preventDefault();
    this.zoomByDelta_(delta);
  }
  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  zoomByDelta_(delta) {
    const map = this.getMap();
    const view = map.getView();
    if (!view) {
      return;
    }
    const currentZoom = view.getZoom();
    if (currentZoom !== void 0) {
      const newZoom = view.getConstrainedZoom(currentZoom + delta);
      if (this.duration_ > 0) {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.animate({
          zoom: newZoom,
          duration: this.duration_,
          easing: easeOut
        });
      } else {
        view.setZoom(newZoom);
      }
    }
  }
};
var Zoom_default = Zoom;

// node_modules/ol/control/defaults.js
function defaults(options) {
  options = options ? options : {};
  const controls = new Collection_default();
  const zoomControl = options.zoom !== void 0 ? options.zoom : true;
  if (zoomControl) {
    controls.push(new Zoom_default(options.zoomOptions));
  }
  const rotateControl = options.rotate !== void 0 ? options.rotate : true;
  if (rotateControl) {
    controls.push(new Rotate_default(options.rotateOptions));
  }
  const attributionControl = options.attribution !== void 0 ? options.attribution : true;
  if (attributionControl) {
    controls.push(new Attribution_default(options.attributionOptions));
  }
  return controls;
}

// node_modules/ol/Kinetic.js
var Kinetic = class {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  constructor(decay, minVelocity, delay) {
    this.decay_ = decay;
    this.minVelocity_ = minVelocity;
    this.delay_ = delay;
    this.points_ = [];
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  }
  /**
   * FIXME empty description for jsdoc
   */
  begin() {
    this.points_.length = 0;
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   */
  update(x, y) {
    this.points_.push(x, y, Date.now());
  }
  /**
   * @return {boolean} Whether we should do kinetic animation.
   */
  end() {
    if (this.points_.length < 6) {
      return false;
    }
    const delay = Date.now() - this.delay_;
    const lastIndex = this.points_.length - 3;
    if (this.points_[lastIndex + 2] < delay) {
      return false;
    }
    let firstIndex = lastIndex - 3;
    while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
      firstIndex -= 3;
    }
    const duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
    if (duration < 1e3 / 60) {
      return false;
    }
    const dx = this.points_[lastIndex] - this.points_[firstIndex];
    const dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
    this.angle_ = Math.atan2(dy, dx);
    this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
    return this.initialVelocity_ > this.minVelocity_;
  }
  /**
   * @return {number} Total distance travelled (pixels).
   */
  getDistance() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }
  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */
  getAngle() {
    return this.angle_;
  }
};
var Kinetic_default = Kinetic;

// node_modules/ol/interaction/Property.js
var Property_default = {
  ACTIVE: "active"
};

// node_modules/ol/interaction/Interaction.js
var Interaction = class extends Object_default {
  /**
   * @param {InteractionOptions} [options] Options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    if (options && options.handleEvent) {
      this.handleEvent = options.handleEvent;
    }
    this.map_ = null;
    this.setActive(true);
  }
  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  getActive() {
    return (
      /** @type {boolean} */
      this.get(Property_default.ACTIVE)
    );
  }
  /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(mapBrowserEvent) {
    return true;
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(active) {
    this.set(Property_default.ACTIVE, active);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(map) {
    this.map_ = map;
  }
};
function pan(view, delta, duration) {
  const currentCenter = view.getCenterInternal();
  if (currentCenter) {
    const center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
    view.animateInternal({
      duration: duration !== void 0 ? duration : 250,
      easing: linear,
      center: view.getConstrainedCenter(center)
    });
  }
}
function zoomByDelta(view, delta, anchor, duration) {
  const currentZoom = view.getZoom();
  if (currentZoom === void 0) {
    return;
  }
  const newZoom = view.getConstrainedZoom(currentZoom + delta);
  const newResolution = view.getResolutionForZoom(newZoom);
  if (view.getAnimating()) {
    view.cancelAnimations();
  }
  view.animate({
    resolution: newResolution,
    anchor,
    duration: duration !== void 0 ? duration : 250,
    easing: easeOut
  });
}
var Interaction_default = Interaction;

// node_modules/ol/interaction/DoubleClickZoom.js
var DoubleClickZoom = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    options = options ? options : {};
    this.delta_ = options.delta ? options.delta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == MapBrowserEventType_default.DBLCLICK) {
      const browserEvent = (
        /** @type {MouseEvent} */
        mapBrowserEvent.originalEvent
      );
      const map = mapBrowserEvent.map;
      const anchor = mapBrowserEvent.coordinate;
      const delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
      const view = map.getView();
      zoomByDelta(view, delta, anchor, this.duration_);
      browserEvent.preventDefault();
      stopEvent = true;
    }
    return !stopEvent;
  }
};
var DoubleClickZoom_default = DoubleClickZoom;

// node_modules/ol/events/condition.js
function all(var_args) {
  const conditions = arguments;
  return function(event) {
    let pass = true;
    for (let i = 0, ii = conditions.length; i < ii; ++i) {
      pass = pass && conditions[i](event);
      if (!pass) {
        break;
      }
    }
    return pass;
  };
}
var altShiftKeysOnly = function(mapBrowserEvent) {
  const originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
var focus = function(event) {
  const targetElement = event.map.getTargetElement();
  const rootNode = targetElement.getRootNode();
  const activeElement = event.map.getOwnerDocument().activeElement;
  return rootNode instanceof ShadowRoot ? rootNode.host.contains(activeElement) : targetElement.contains(activeElement);
};
var focusWithTabindex = function(event) {
  const targetElement = event.map.getTargetElement();
  const rootNode = targetElement.getRootNode();
  const tabIndexCandidate = rootNode instanceof ShadowRoot ? rootNode.host : targetElement;
  return tabIndexCandidate.hasAttribute("tabindex") ? focus(event) : true;
};
var always = TRUE;
var mouseActionButton = function(mapBrowserEvent) {
  const originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent instanceof PointerEvent && originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);
};
var noModifierKeys = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
var platformModifierKey = function(mapBrowserEvent) {
  const originalEvent = mapBrowserEvent.originalEvent;
  return MAC ? originalEvent.metaKey : originalEvent.ctrlKey;
};
var shiftKeyOnly = function(mapBrowserEvent) {
  const originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
var targetNotEditable = function(mapBrowserEvent) {
  const originalEvent = mapBrowserEvent.originalEvent;
  const tagName = (
    /** @type {Element} */
    originalEvent.target.tagName
  );
  return tagName !== "INPUT" && tagName !== "SELECT" && tagName !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
  // different type like `SVGElement`.
  // @ts-ignore
  !originalEvent.target.isContentEditable;
};
var mouseOnly = function(mapBrowserEvent) {
  const pointerEvent = mapBrowserEvent.originalEvent;
  return pointerEvent instanceof PointerEvent && pointerEvent.pointerType == "mouse";
};
var primaryAction = function(mapBrowserEvent) {
  const pointerEvent = mapBrowserEvent.originalEvent;
  return pointerEvent instanceof PointerEvent && pointerEvent.isPrimary && pointerEvent.button === 0;
};

// node_modules/ol/interaction/Pointer.js
var PointerInteraction = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      options
    );
    if (options.handleDownEvent) {
      this.handleDownEvent = options.handleDownEvent;
    }
    if (options.handleDragEvent) {
      this.handleDragEvent = options.handleDragEvent;
    }
    if (options.handleMoveEvent) {
      this.handleMoveEvent = options.handleMoveEvent;
    }
    if (options.handleUpEvent) {
      this.handleUpEvent = options.handleUpEvent;
    }
    if (options.stopDown) {
      this.stopDown = options.stopDown;
    }
    this.handlingDownUpSequence = false;
    this.targetPointers = [];
  }
  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */
  getPointerCount() {
    return this.targetPointers.length;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleDownEvent(mapBrowserEvent) {
    return false;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleDragEvent(mapBrowserEvent) {
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   * @override
   */
  handleEvent(mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent) {
      return true;
    }
    let stopEvent = false;
    this.updateTrackedPointers_(mapBrowserEvent);
    if (this.handlingDownUpSequence) {
      if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERDRAG) {
        this.handleDragEvent(mapBrowserEvent);
        mapBrowserEvent.originalEvent.preventDefault();
      } else if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERUP) {
        const handledUp = this.handleUpEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
      }
    } else {
      if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERDOWN) {
        const handled = this.handleDownEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handled;
        stopEvent = this.stopDown(handled);
      } else if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERMOVE) {
        this.handleMoveEvent(mapBrowserEvent);
      }
    }
    return !stopEvent;
  }
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleMoveEvent(mapBrowserEvent) {
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleUpEvent(mapBrowserEvent) {
    return false;
  }
  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  stopDown(handled) {
    return handled;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  updateTrackedPointers_(mapBrowserEvent) {
    if (mapBrowserEvent.activePointers) {
      this.targetPointers = mapBrowserEvent.activePointers;
    }
  }
};
function centroid(pointerEvents) {
  const length = pointerEvents.length;
  let clientX = 0;
  let clientY = 0;
  for (let i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }
  return { clientX: clientX / length, clientY: clientY / length };
}
var Pointer_default = PointerInteraction;

// node_modules/ol/interaction/DragPan.js
var DragPan = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super({
      stopDown: FALSE
    });
    options = options ? options : {};
    this.kinetic_ = options.kinetic;
    this.lastCentroid = null;
    this.lastPointersCount_;
    this.panning_ = false;
    const condition = options.condition ? options.condition : all(noModifierKeys, primaryAction);
    this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;
    this.noKinetic_ = false;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(mapBrowserEvent) {
    const map = mapBrowserEvent.map;
    if (!this.panning_) {
      this.panning_ = true;
      map.getView().beginInteraction();
    }
    const targetPointers = this.targetPointers;
    const centroid2 = map.getEventPixel(centroid(targetPointers));
    if (targetPointers.length == this.lastPointersCount_) {
      if (this.kinetic_) {
        this.kinetic_.update(centroid2[0], centroid2[1]);
      }
      if (this.lastCentroid) {
        const delta = [
          this.lastCentroid[0] - centroid2[0],
          centroid2[1] - this.lastCentroid[1]
        ];
        const map2 = mapBrowserEvent.map;
        const view = map2.getView();
        scale(delta, view.getResolution());
        rotate(delta, view.getRotation());
        view.adjustCenterInternal(delta);
      }
    } else if (this.kinetic_) {
      this.kinetic_.begin();
    }
    this.lastCentroid = centroid2;
    this.lastPointersCount_ = targetPointers.length;
    mapBrowserEvent.originalEvent.preventDefault();
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(mapBrowserEvent) {
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        const distance = this.kinetic_.getDistance();
        const angle = this.kinetic_.getAngle();
        const center = view.getCenterInternal();
        const centerpx = map.getPixelFromCoordinateInternal(center);
        const dest = map.getCoordinateFromPixelInternal([
          centerpx[0] - distance * Math.cos(angle),
          centerpx[1] - distance * Math.sin(angle)
        ]);
        view.animateInternal({
          center: view.getConstrainedCenter(dest),
          duration: 500,
          easing: easeOut
        });
      }
      if (this.panning_) {
        this.panning_ = false;
        view.endInteraction();
      }
      return false;
    }
    if (this.kinetic_) {
      this.kinetic_.begin();
    }
    this.lastCentroid = null;
    return true;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      this.lastCentroid = null;
      if (view.getAnimating()) {
        view.cancelAnimations();
      }
      if (this.kinetic_) {
        this.kinetic_.begin();
      }
      this.noKinetic_ = this.targetPointers.length > 1;
      return true;
    }
    return false;
  }
};
var DragPan_default = DragPan;

// node_modules/ol/interaction/DragRotate.js
var DragRotate = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      stopDown: FALSE
    });
    this.condition_ = options.condition ? options.condition : altShiftKeysOnly;
    this.lastAngle_ = void 0;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return;
    }
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (view.getConstraints().rotation === disable) {
      return;
    }
    const size = map.getSize();
    const offset = mapBrowserEvent.pixel;
    const theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
    if (this.lastAngle_ !== void 0) {
      const delta = theta - this.lastAngle_;
      view.adjustRotationInternal(-delta);
    }
    this.lastAngle_ = theta;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return true;
    }
    const map = mapBrowserEvent.map;
    const view = map.getView();
    view.endInteraction(this.duration_);
    return false;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return false;
    }
    if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
      const map = mapBrowserEvent.map;
      map.getView().beginInteraction();
      this.lastAngle_ = void 0;
      return true;
    }
    return false;
  }
};
var DragRotate_default = DragRotate;

// node_modules/ol/render/Box.js
var RenderBox = class extends Disposable_default {
  /**
   * @param {string} className CSS class name.
   */
  constructor(className) {
    super();
    this.geometry_ = null;
    this.element_ = document.createElement("div");
    this.element_.style.position = "absolute";
    this.element_.style.pointerEvents = "auto";
    this.element_.className = "ol-box " + className;
    this.map_ = null;
    this.startPixel_ = null;
    this.endPixel_ = null;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.setMap(null);
  }
  /**
   * @private
   */
  render_() {
    const startPixel = this.startPixel_;
    const endPixel = this.endPixel_;
    const px = "px";
    const style = this.element_.style;
    style.left = Math.min(startPixel[0], endPixel[0]) + px;
    style.top = Math.min(startPixel[1], endPixel[1]) + px;
    style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
    style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(map) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      const style = this.element_.style;
      style.left = "inherit";
      style.top = "inherit";
      style.width = "inherit";
      style.height = "inherit";
    }
    this.map_ = map;
    if (this.map_) {
      this.map_.getOverlayContainer().appendChild(this.element_);
    }
  }
  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */
  setPixels(startPixel, endPixel) {
    this.startPixel_ = startPixel;
    this.endPixel_ = endPixel;
    this.createOrUpdateGeometry();
    this.render_();
  }
  /**
   * Creates or updates the cached geometry.
   */
  createOrUpdateGeometry() {
    if (!this.map_) {
      return;
    }
    const startPixel = this.startPixel_;
    const endPixel = this.endPixel_;
    const pixels = [
      startPixel,
      [startPixel[0], endPixel[1]],
      endPixel,
      [endPixel[0], startPixel[1]]
    ];
    const coordinates2 = pixels.map(
      this.map_.getCoordinateFromPixelInternal,
      this.map_
    );
    coordinates2[4] = coordinates2[0].slice();
    if (!this.geometry_) {
      this.geometry_ = new Polygon_default([coordinates2]);
    } else {
      this.geometry_.setCoordinates([coordinates2]);
    }
  }
  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */
  getGeometry() {
    return this.geometry_;
  }
};
var Box_default = RenderBox;

// node_modules/ol/interaction/DragBox.js
var DragBoxEventType = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: "boxstart",
  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: "boxdrag",
  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: "boxend",
  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: "boxcancel"
};
var DragBoxEvent = class extends Event_default {
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */
  constructor(type, coordinate, mapBrowserEvent) {
    super(type);
    this.coordinate = coordinate;
    this.mapBrowserEvent = mapBrowserEvent;
  }
};
var DragBox = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    options = options ?? {};
    this.box_ = new Box_default(options.className || "ol-dragbox");
    this.minArea_ = options.minArea ?? 64;
    if (options.onBoxEnd) {
      this.onBoxEnd = options.onBoxEnd;
    }
    this.startPixel_ = null;
    this.condition_ = options.condition ?? mouseActionButton;
    this.boxEndCondition_ = options.boxEndCondition ?? this.defaultBoxEndCondition;
  }
  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {
    const width = endPixel[0] - startPixel[0];
    const height = endPixel[1] - startPixel[1];
    return width * width + height * height >= this.minArea_;
  }
  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */
  getGeometry() {
    return this.box_.getGeometry();
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(mapBrowserEvent) {
    if (!this.startPixel_) {
      return;
    }
    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
    this.dispatchEvent(
      new DragBoxEvent(
        DragBoxEventType.BOXDRAG,
        mapBrowserEvent.coordinate,
        mapBrowserEvent
      )
    );
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(mapBrowserEvent) {
    if (!this.startPixel_) {
      return false;
    }
    const completeBox = this.boxEndCondition_(
      mapBrowserEvent,
      this.startPixel_,
      mapBrowserEvent.pixel
    );
    if (completeBox) {
      this.onBoxEnd(mapBrowserEvent);
    }
    this.dispatchEvent(
      new DragBoxEvent(
        completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL,
        mapBrowserEvent.coordinate,
        mapBrowserEvent
      )
    );
    this.box_.setMap(null);
    this.startPixel_ = null;
    return false;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.condition_(mapBrowserEvent)) {
      this.startPixel_ = mapBrowserEvent.pixel;
      this.box_.setMap(mapBrowserEvent.map);
      this.box_.setPixels(this.startPixel_, this.startPixel_);
      this.dispatchEvent(
        new DragBoxEvent(
          DragBoxEventType.BOXSTART,
          mapBrowserEvent.coordinate,
          mapBrowserEvent
        )
      );
      return true;
    }
    return false;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(event) {
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   * @override
   */
  setActive(active) {
    if (!active) {
      this.box_.setMap(null);
      if (this.startPixel_) {
        this.dispatchEvent(
          new DragBoxEvent(DragBoxEventType.BOXCANCEL, this.startPixel_, null)
        );
        this.startPixel_ = null;
      }
    }
    super.setActive(active);
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   * @override
   */
  setMap(map) {
    const oldMap = this.getMap();
    if (oldMap) {
      this.box_.setMap(null);
      if (this.startPixel_) {
        this.dispatchEvent(
          new DragBoxEvent(DragBoxEventType.BOXCANCEL, this.startPixel_, null)
        );
        this.startPixel_ = null;
      }
    }
    super.setMap(map);
  }
};
var DragBox_default = DragBox;

// node_modules/ol/interaction/DragZoom.js
var DragZoom = class extends DragBox_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    const condition = options.condition ? options.condition : shiftKeyOnly;
    super({
      condition,
      className: options.className || "ol-dragzoom",
      minArea: options.minArea
    });
    this.duration_ = options.duration !== void 0 ? options.duration : 200;
    this.out_ = options.out !== void 0 ? options.out : false;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @override
   */
  onBoxEnd(event) {
    const map = this.getMap();
    const view = (
      /** @type {!import("../View.js").default} */
      map.getView()
    );
    let geometry = this.getGeometry();
    if (this.out_) {
      const rotatedExtent = view.rotatedExtentForGeometry(geometry);
      const resolution = view.getResolutionForExtentInternal(rotatedExtent);
      const factor = view.getResolution() / resolution;
      geometry = geometry.clone();
      geometry.scale(factor * factor);
    }
    view.fitInternal(geometry, {
      duration: this.duration_,
      easing: easeOut
    });
  }
};
var DragZoom_default = DragZoom;

// node_modules/ol/events/Key.js
var Key_default = {
  LEFT: "ArrowLeft",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  DOWN: "ArrowDown"
};

// node_modules/ol/interaction/KeyboardPan.js
var KeyboardPan = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    options = options || {};
    this.defaultCondition_ = function(mapBrowserEvent) {
      return noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
    };
    this.condition_ = options.condition !== void 0 ? options.condition : this.defaultCondition_;
    this.duration_ = options.duration !== void 0 ? options.duration : 100;
    this.pixelDelta_ = options.pixelDelta !== void 0 ? options.pixelDelta : 128;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == EventType_default.KEYDOWN) {
      const keyEvent = (
        /** @type {KeyboardEvent} */
        mapBrowserEvent.originalEvent
      );
      const key = keyEvent.key;
      if (this.condition_(mapBrowserEvent) && (key == Key_default.DOWN || key == Key_default.LEFT || key == Key_default.RIGHT || key == Key_default.UP)) {
        const map = mapBrowserEvent.map;
        const view = map.getView();
        const mapUnitsDelta = view.getResolution() * this.pixelDelta_;
        let deltaX = 0, deltaY = 0;
        if (key == Key_default.DOWN) {
          deltaY = -mapUnitsDelta;
        } else if (key == Key_default.LEFT) {
          deltaX = -mapUnitsDelta;
        } else if (key == Key_default.RIGHT) {
          deltaX = mapUnitsDelta;
        } else {
          deltaY = mapUnitsDelta;
        }
        const delta = [deltaX, deltaY];
        rotate(delta, view.getRotation());
        pan(view, delta, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  }
};
var KeyboardPan_default = KeyboardPan;

// node_modules/ol/interaction/KeyboardZoom.js
var KeyboardZoom = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    options = options ? options : {};
    this.condition_ = options.condition ? options.condition : function(mapBrowserEvent) {
      return !platformModifierKey(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
    };
    this.delta_ = options.delta ? options.delta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 100;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == EventType_default.KEYDOWN || mapBrowserEvent.type == EventType_default.KEYPRESS) {
      const keyEvent = (
        /** @type {KeyboardEvent} */
        mapBrowserEvent.originalEvent
      );
      const key = keyEvent.key;
      if (this.condition_(mapBrowserEvent) && (key === "+" || key === "-")) {
        const map = mapBrowserEvent.map;
        const delta = key === "+" ? this.delta_ : -this.delta_;
        const view = map.getView();
        zoomByDelta(view, delta, void 0, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  }
};
var KeyboardZoom_default = KeyboardZoom;

// node_modules/ol/interaction/MouseWheelZoom.js
var MouseWheelZoom = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      options
    );
    this.totalDelta_ = 0;
    this.lastDelta_ = 0;
    this.maxDelta_ = options.maxDelta !== void 0 ? options.maxDelta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
    this.timeout_ = options.timeout !== void 0 ? options.timeout : 80;
    this.useAnchor_ = options.useAnchor !== void 0 ? options.useAnchor : true;
    this.constrainResolution_ = options.constrainResolution !== void 0 ? options.constrainResolution : false;
    const condition = options.condition ? options.condition : always;
    this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;
    this.lastAnchor_ = null;
    this.startTime_ = void 0;
    this.timeoutId_;
    this.mode_ = void 0;
    this.trackpadEventGap_ = 400;
    this.trackpadTimeoutId_;
    this.deltaPerZoom_ = 300;
  }
  /**
   * @private
   */
  endInteraction_() {
    this.trackpadTimeoutId_ = void 0;
    const map = this.getMap();
    if (!map) {
      return;
    }
    const view = map.getView();
    view.endInteraction(
      void 0,
      this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
      this.lastAnchor_ ? map.getCoordinateFromPixel(this.lastAnchor_) : null
    );
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }
    const type = mapBrowserEvent.type;
    if (type !== EventType_default.WHEEL) {
      return true;
    }
    const map = mapBrowserEvent.map;
    const wheelEvent = (
      /** @type {WheelEvent} */
      mapBrowserEvent.originalEvent
    );
    wheelEvent.preventDefault();
    if (this.useAnchor_) {
      this.lastAnchor_ = mapBrowserEvent.pixel;
    }
    let delta;
    if (mapBrowserEvent.type == EventType_default.WHEEL) {
      delta = wheelEvent.deltaY;
      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
        delta *= 40;
      }
    }
    if (delta === 0) {
      return false;
    }
    this.lastDelta_ = delta;
    const now = Date.now();
    if (this.startTime_ === void 0) {
      this.startTime_ = now;
    }
    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
      this.mode_ = Math.abs(delta) < 4 ? "trackpad" : "wheel";
    }
    const view = map.getView();
    if (this.mode_ === "trackpad" && !(view.getConstrainResolution() || this.constrainResolution_)) {
      if (this.trackpadTimeoutId_) {
        clearTimeout(this.trackpadTimeoutId_);
      } else {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.beginInteraction();
      }
      this.trackpadTimeoutId_ = setTimeout(
        this.endInteraction_.bind(this),
        this.timeout_
      );
      view.adjustZoom(
        -delta / this.deltaPerZoom_,
        this.lastAnchor_ ? map.getCoordinateFromPixel(this.lastAnchor_) : null
      );
      this.startTime_ = now;
      return false;
    }
    this.totalDelta_ += delta;
    const timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
    clearTimeout(this.timeoutId_);
    this.timeoutId_ = setTimeout(
      this.handleWheelZoom_.bind(this, map),
      timeLeft
    );
    return false;
  }
  /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */
  handleWheelZoom_(map) {
    const view = map.getView();
    if (view.getAnimating()) {
      view.cancelAnimations();
    }
    let delta = -clamp(
      this.totalDelta_,
      -this.maxDelta_ * this.deltaPerZoom_,
      this.maxDelta_ * this.deltaPerZoom_
    ) / this.deltaPerZoom_;
    if (view.getConstrainResolution() || this.constrainResolution_) {
      delta = delta ? delta > 0 ? 1 : -1 : 0;
    }
    zoomByDelta(
      view,
      delta,
      this.lastAnchor_ ? map.getCoordinateFromPixel(this.lastAnchor_) : null,
      this.duration_
    );
    this.mode_ = void 0;
    this.totalDelta_ = 0;
    this.lastAnchor_ = null;
    this.startTime_ = void 0;
    this.timeoutId_ = void 0;
  }
  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  setMouseAnchor(useAnchor) {
    this.useAnchor_ = useAnchor;
    if (!useAnchor) {
      this.lastAnchor_ = null;
    }
  }
};
var MouseWheelZoom_default = MouseWheelZoom;

// node_modules/ol/interaction/PinchRotate.js
var PinchRotate = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    const pointerOptions = (
      /** @type {import("./Pointer.js").Options} */
      options
    );
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    super(pointerOptions);
    this.anchor_ = null;
    this.lastAngle_ = void 0;
    this.rotating_ = false;
    this.rotationDelta_ = 0;
    this.threshold_ = options.threshold !== void 0 ? options.threshold : 0.3;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(mapBrowserEvent) {
    let rotationDelta = 0;
    const touch0 = this.targetPointers[0];
    const touch1 = this.targetPointers[1];
    const angle = Math.atan2(
      touch1.clientY - touch0.clientY,
      touch1.clientX - touch0.clientX
    );
    if (this.lastAngle_ !== void 0) {
      const delta = angle - this.lastAngle_;
      this.rotationDelta_ += delta;
      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
        this.rotating_ = true;
      }
      rotationDelta = delta;
    }
    this.lastAngle_ = angle;
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (view.getConstraints().rotation === disable) {
      return;
    }
    this.anchor_ = map.getCoordinateFromPixelInternal(
      map.getEventPixel(centroid(this.targetPointers))
    );
    if (this.rotating_) {
      map.render();
      view.adjustRotationInternal(rotationDelta, this.anchor_);
    }
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      view.endInteraction(this.duration_);
      return false;
    }
    return true;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      const map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastAngle_ = void 0;
      this.rotating_ = false;
      this.rotationDelta_ = 0;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    }
    return false;
  }
};
var PinchRotate_default = PinchRotate;

// node_modules/ol/interaction/PinchZoom.js
var PinchZoom = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    const pointerOptions = (
      /** @type {import("./Pointer.js").Options} */
      options
    );
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    super(pointerOptions);
    this.anchor_ = null;
    this.duration_ = options.duration !== void 0 ? options.duration : 400;
    this.lastDistance_ = void 0;
    this.lastScaleDelta_ = 1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(mapBrowserEvent) {
    let scaleDelta = 1;
    const touch0 = this.targetPointers[0];
    const touch1 = this.targetPointers[1];
    const dx = touch0.clientX - touch1.clientX;
    const dy = touch0.clientY - touch1.clientY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    if (this.lastDistance_ !== void 0) {
      scaleDelta = this.lastDistance_ / distance;
    }
    this.lastDistance_ = distance;
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (scaleDelta != 1) {
      this.lastScaleDelta_ = scaleDelta;
    }
    this.anchor_ = map.getCoordinateFromPixelInternal(
      map.getEventPixel(centroid(this.targetPointers))
    );
    map.render();
    view.adjustResolutionInternal(scaleDelta, this.anchor_);
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      const direction = this.lastScaleDelta_ > 1 ? 1 : -1;
      view.endInteraction(this.duration_, direction);
      return false;
    }
    return true;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      const map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastDistance_ = void 0;
      this.lastScaleDelta_ = 1;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    }
    return false;
  }
};
var PinchZoom_default = PinchZoom;

// node_modules/ol/interaction/defaults.js
function defaults2(options) {
  options = options ? options : {};
  const interactions = new Collection_default();
  const kinetic = new Kinetic_default(-5e-3, 0.05, 100);
  const altShiftDragRotate = options.altShiftDragRotate !== void 0 ? options.altShiftDragRotate : true;
  if (altShiftDragRotate) {
    interactions.push(new DragRotate_default());
  }
  const doubleClickZoom = options.doubleClickZoom !== void 0 ? options.doubleClickZoom : true;
  if (doubleClickZoom) {
    interactions.push(
      new DoubleClickZoom_default({
        delta: options.zoomDelta,
        duration: options.zoomDuration
      })
    );
  }
  const dragPan = options.dragPan !== void 0 ? options.dragPan : true;
  if (dragPan) {
    interactions.push(
      new DragPan_default({
        onFocusOnly: options.onFocusOnly,
        kinetic
      })
    );
  }
  const pinchRotate = options.pinchRotate !== void 0 ? options.pinchRotate : true;
  if (pinchRotate) {
    interactions.push(new PinchRotate_default());
  }
  const pinchZoom = options.pinchZoom !== void 0 ? options.pinchZoom : true;
  if (pinchZoom) {
    interactions.push(
      new PinchZoom_default({
        duration: options.zoomDuration
      })
    );
  }
  const keyboard = options.keyboard !== void 0 ? options.keyboard : true;
  if (keyboard) {
    interactions.push(new KeyboardPan_default());
    interactions.push(
      new KeyboardZoom_default({
        delta: options.zoomDelta,
        duration: options.zoomDuration
      })
    );
  }
  const mouseWheelZoom = options.mouseWheelZoom !== void 0 ? options.mouseWheelZoom : true;
  if (mouseWheelZoom) {
    interactions.push(
      new MouseWheelZoom_default({
        onFocusOnly: options.onFocusOnly,
        duration: options.zoomDuration
      })
    );
  }
  const shiftDragZoom = options.shiftDragZoom !== void 0 ? options.shiftDragZoom : true;
  if (shiftDragZoom) {
    interactions.push(
      new DragZoom_default({
        duration: options.zoomDuration
      })
    );
  }
  return interactions;
}

// node_modules/ol/layer/Property.js
var Property_default2 = {
  OPACITY: "opacity",
  VISIBLE: "visible",
  EXTENT: "extent",
  Z_INDEX: "zIndex",
  MAX_RESOLUTION: "maxResolution",
  MIN_RESOLUTION: "minResolution",
  MAX_ZOOM: "maxZoom",
  MIN_ZOOM: "minZoom",
  SOURCE: "source",
  MAP: "map"
};

// node_modules/ol/layer/Base.js
var BaseLayer = class extends Object_default {
  /**
   * @param {Options} options Layer options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    this.background_ = options.background;
    const properties = Object.assign({}, options);
    if (typeof options.properties === "object") {
      delete properties.properties;
      Object.assign(properties, options.properties);
    }
    properties[Property_default2.OPACITY] = options.opacity !== void 0 ? options.opacity : 1;
    assert(
      typeof properties[Property_default2.OPACITY] === "number",
      "Layer opacity must be a number"
    );
    properties[Property_default2.VISIBLE] = options.visible !== void 0 ? options.visible : true;
    properties[Property_default2.Z_INDEX] = options.zIndex;
    properties[Property_default2.MAX_RESOLUTION] = options.maxResolution !== void 0 ? options.maxResolution : Infinity;
    properties[Property_default2.MIN_RESOLUTION] = options.minResolution !== void 0 ? options.minResolution : 0;
    properties[Property_default2.MIN_ZOOM] = options.minZoom !== void 0 ? options.minZoom : -Infinity;
    properties[Property_default2.MAX_ZOOM] = options.maxZoom !== void 0 ? options.maxZoom : Infinity;
    this.className_ = properties.className !== void 0 ? properties.className : "ol-layer";
    delete properties.className;
    this.setProperties(properties);
    this.state_ = null;
  }
  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */
  getBackground() {
    return this.background_;
  }
  /**
   * @return {string} CSS class name.
   */
  getClassName() {
    return this.className_;
  }
  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */
  getLayerState(managed) {
    const state = this.state_ || /** @type {?} */
    {
      layer: this,
      managed: managed === void 0 ? true : managed
    };
    const zIndex = this.getZIndex();
    state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
    state.visible = this.getVisible();
    state.extent = this.getExtent();
    state.zIndex = zIndex === void 0 && !state.managed ? Infinity : zIndex;
    state.maxResolution = this.getMaxResolution();
    state.minResolution = Math.max(this.getMinResolution(), 0);
    state.minZoom = this.getMinZoom();
    state.maxZoom = this.getMaxZoom();
    this.state_ = state;
    return state;
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(array) {
    return abstract();
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(states) {
    return abstract();
  }
  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  getExtent() {
    return (
      /** @type {import("../extent.js").Extent|undefined} */
      this.get(Property_default2.EXTENT)
    );
  }
  /**
   * Return the maximum resolution of the layer. Returns Infinity if
   * the layer has no maximum resolution set.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  getMaxResolution() {
    return (
      /** @type {number} */
      this.get(Property_default2.MAX_RESOLUTION)
    );
  }
  /**
   * Return the minimum resolution of the layer. Returns 0 if
   * the layer has no minimum resolution set.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  getMinResolution() {
    return (
      /** @type {number} */
      this.get(Property_default2.MIN_RESOLUTION)
    );
  }
  /**
   * Return the minimum zoom level of the layer. Returns -Infinity if
   * the layer has no minimum zoom set.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.get(Property_default2.MIN_ZOOM)
    );
  }
  /**
   * Return the maximum zoom level of the layer. Returns Infinity if
   * the layer has no maximum zoom set.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.get(Property_default2.MAX_ZOOM)
    );
  }
  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  getOpacity() {
    return (
      /** @type {number} */
      this.get(Property_default2.OPACITY)
    );
  }
  /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return abstract();
  }
  /**
   * Return the value of this layer's `visible` property. To find out whether the layer
   * is visible on a map, use `isVisible()` instead.
   * @return {boolean} The value of the `visible` property of the layer.
   * @observable
   * @api
   */
  getVisible() {
    return (
      /** @type {boolean} */
      this.get(Property_default2.VISIBLE)
    );
  }
  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. Returns undefined if the layer is unmanaged.
   * @return {number|undefined} The Z-index of the layer.
   * @observable
   * @api
   */
  getZIndex() {
    return (
      /** @type {number|undefined} */
      this.get(Property_default2.Z_INDEX)
    );
  }
  /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */
  setBackground(background) {
    this.background_ = background;
    this.changed();
  }
  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  setExtent(extent) {
    this.set(Property_default2.EXTENT, extent);
  }
  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  setMaxResolution(maxResolution) {
    this.set(Property_default2.MAX_RESOLUTION, maxResolution);
  }
  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  setMinResolution(minResolution) {
    this.set(Property_default2.MIN_RESOLUTION, minResolution);
  }
  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */
  setMaxZoom(maxZoom) {
    this.set(Property_default2.MAX_ZOOM, maxZoom);
  }
  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */
  setMinZoom(minZoom) {
    this.set(Property_default2.MIN_ZOOM, minZoom);
  }
  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  setOpacity(opacity) {
    assert(typeof opacity === "number", "Layer opacity must be a number");
    this.set(Property_default2.OPACITY, opacity);
  }
  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  setVisible(visible) {
    this.set(Property_default2.VISIBLE, visible);
  }
  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  setZIndex(zindex) {
    this.set(Property_default2.Z_INDEX, zindex);
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    if (this.state_) {
      this.state_.layer = null;
      this.state_ = null;
    }
    super.disposeInternal();
  }
};
var Base_default = BaseLayer;

// node_modules/ol/layer/Group.js
var GroupEvent = class extends Event_default {
  /**
   * @param {GroupEventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */
  constructor(type, layer) {
    super(type);
    this.layer = layer;
  }
};
var Property2 = {
  LAYERS: "layers"
};
var LayerGroup = class _LayerGroup extends Base_default {
  /**
   * @param {Options} [options] Layer options.
   */
  constructor(options) {
    options = options || {};
    const baseOptions = (
      /** @type {Options} */
      Object.assign({}, options)
    );
    delete baseOptions.layers;
    let layers = options.layers;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.layersListenerKeys_ = [];
    this.listenerKeys_ = {};
    this.addChangeListener(Property2.LAYERS, this.handleLayersChanged_);
    if (layers) {
      if (Array.isArray(layers)) {
        layers = new Collection_default(layers.slice(), { unique: true });
      } else {
        assert(
          typeof /** @type {?} */
          layers.getArray === "function",
          "Expected `layers` to be an array or a `Collection`"
        );
      }
    } else {
      layers = new Collection_default(void 0, { unique: true });
    }
    this.setLayers(layers);
  }
  /**
   * @private
   */
  handleLayerChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleLayersChanged_() {
    this.layersListenerKeys_.forEach(unlistenByKey);
    this.layersListenerKeys_.length = 0;
    const layers = this.getLayers();
    this.layersListenerKeys_.push(
      listen(layers, CollectionEventType_default.ADD, this.handleLayersAdd_, this),
      listen(
        layers,
        CollectionEventType_default.REMOVE,
        this.handleLayersRemove_,
        this
      )
    );
    for (const id in this.listenerKeys_) {
      this.listenerKeys_[id].forEach(unlistenByKey);
    }
    clear(this.listenerKeys_);
    const layersArray = layers.getArray();
    for (let i = 0, ii = layersArray.length; i < ii; i++) {
      const layer = layersArray[i];
      this.registerLayerListeners_(layer);
      this.dispatchEvent(new GroupEvent("addlayer", layer));
    }
    this.changed();
  }
  /**
   * @param {BaseLayer} layer The layer.
   */
  registerLayerListeners_(layer) {
    const listenerKeys = [
      listen(
        layer,
        ObjectEventType_default.PROPERTYCHANGE,
        this.handleLayerChange_,
        this
      ),
      listen(layer, EventType_default.CHANGE, this.handleLayerChange_, this)
    ];
    if (layer instanceof _LayerGroup) {
      listenerKeys.push(
        listen(layer, "addlayer", this.handleLayerGroupAdd_, this),
        listen(layer, "removelayer", this.handleLayerGroupRemove_, this)
      );
    }
    this.listenerKeys_[getUid(layer)] = listenerKeys;
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupAdd_(event) {
    this.dispatchEvent(new GroupEvent("addlayer", event.layer));
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupRemove_(event) {
    this.dispatchEvent(new GroupEvent("removelayer", event.layer));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersAdd_(collectionEvent) {
    const layer = collectionEvent.element;
    this.registerLayerListeners_(layer);
    this.dispatchEvent(new GroupEvent("addlayer", layer));
    this.changed();
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersRemove_(collectionEvent) {
    const layer = collectionEvent.element;
    const key = getUid(layer);
    this.listenerKeys_[key].forEach(unlistenByKey);
    delete this.listenerKeys_[key];
    this.dispatchEvent(new GroupEvent("removelayer", layer));
    this.changed();
  }
  /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  getLayers() {
    return (
      /** @type {!Collection<import("./Base.js").default>} */
      this.get(Property2.LAYERS)
    );
  }
  /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  setLayers(layers) {
    const collection = this.getLayers();
    if (collection) {
      const currentLayers = collection.getArray();
      for (let i = 0, ii = currentLayers.length; i < ii; ++i) {
        this.dispatchEvent(new GroupEvent("removelayer", currentLayers[i]));
      }
    }
    this.set(Property2.LAYERS, layers);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   * @override
   */
  getLayersArray(array) {
    array = array !== void 0 ? array : [];
    this.getLayers().forEach(function(layer) {
      layer.getLayersArray(array);
    });
    return array;
  }
  /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   * @override
   */
  getLayerStatesArray(dest) {
    const states = dest !== void 0 ? dest : [];
    const pos = states.length;
    this.getLayers().forEach(function(layer) {
      layer.getLayerStatesArray(states);
    });
    const ownLayerState = this.getLayerState();
    let defaultZIndex = ownLayerState.zIndex;
    if (!dest && ownLayerState.zIndex === void 0) {
      defaultZIndex = 0;
    }
    for (let i = pos, ii = states.length; i < ii; i++) {
      const layerState = states[i];
      layerState.opacity *= ownLayerState.opacity;
      layerState.visible = layerState.visible && ownLayerState.visible;
      layerState.maxResolution = Math.min(
        layerState.maxResolution,
        ownLayerState.maxResolution
      );
      layerState.minResolution = Math.max(
        layerState.minResolution,
        ownLayerState.minResolution
      );
      layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
      layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
      if (ownLayerState.extent !== void 0) {
        if (layerState.extent !== void 0) {
          layerState.extent = getIntersection(
            layerState.extent,
            ownLayerState.extent
          );
        } else {
          layerState.extent = ownLayerState.extent;
        }
      }
      if (layerState.zIndex === void 0) {
        layerState.zIndex = defaultZIndex;
      }
    }
    return states;
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   * @override
   */
  getSourceState() {
    return "ready";
  }
};
var Group_default = LayerGroup;

// node_modules/ol/render/EventType.js
var EventType_default3 = {
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: "prerender",
  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: "precompose",
  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: "postcompose",
  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: "rendercomplete"
};

// node_modules/ol/layer/Layer.js
var Layer = class extends Base_default {
  /**
   * @param {Options<SourceType>} options Layer options.
   */
  constructor(options) {
    const baseOptions = Object.assign({}, options);
    delete baseOptions.source;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.mapPrecomposeKey_ = null;
    this.mapRenderKey_ = null;
    this.sourceChangeKey_ = null;
    this.renderer_ = null;
    this.sourceReady_ = false;
    this.rendered = false;
    if (options.render) {
      this.render = options.render;
    }
    if (options.map) {
      this.setMap(options.map);
    }
    this.addChangeListener(
      Property_default2.SOURCE,
      this.handleSourcePropertyChange_
    );
    const source = options.source ? (
      /** @type {SourceType} */
      options.source
    ) : null;
    this.setSource(source);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   * @override
   */
  getLayersArray(array) {
    array = array ? array : [];
    array.push(this);
    return array;
  }
  /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   * @override
   */
  getLayerStatesArray(states) {
    states = states ? states : [];
    states.push(this.getLayerState());
    return states;
  }
  /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  getSource() {
    return (
      /** @type {SourceType} */
      this.get(Property_default2.SOURCE) || null
    );
  }
  /**
   * @return {SourceType|null} The source being rendered.
   */
  getRenderSource() {
    return this.getSource();
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   * @override
   */
  getSourceState() {
    const source = this.getSource();
    return !source ? "undefined" : source.getState();
  }
  /**
   * @private
   */
  handleSourceChange_() {
    this.changed();
    if (this.sourceReady_ || this.getSource().getState() !== "ready") {
      return;
    }
    this.sourceReady_ = true;
    this.dispatchEvent("sourceready");
  }
  /**
   * @private
   */
  handleSourcePropertyChange_() {
    if (this.sourceChangeKey_) {
      unlistenByKey(this.sourceChangeKey_);
      this.sourceChangeKey_ = null;
    }
    this.sourceReady_ = false;
    const source = this.getSource();
    if (source) {
      this.sourceChangeKey_ = listen(
        source,
        EventType_default.CHANGE,
        this.handleSourceChange_,
        this
      );
      if (source.getState() === "ready") {
        this.sourceReady_ = true;
        setTimeout(() => {
          this.dispatchEvent("sourceready");
        }, 0);
      }
      this.clearRenderer();
    }
    this.changed();
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(pixel) {
    if (!this.renderer_) {
      return Promise.resolve([]);
    }
    return this.renderer_.getFeatures(pixel);
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(pixel) {
    if (!this.renderer_ || !this.rendered) {
      return null;
    }
    return this.renderer_.getData(pixel);
  }
  /**
   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
   * extent, not set to `visible: false`, and not inside a layer group that is set
   * to `visible: false`.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {boolean} The layer is visible in the map view.
   * @api
   */
  isVisible(view) {
    let frameState;
    const map = this.getMapInternal();
    if (!view && map) {
      view = map.getView();
    }
    if (view instanceof View_default) {
      frameState = {
        viewState: view.getState(),
        extent: view.calculateExtent()
      };
    } else {
      frameState = view;
    }
    if (!frameState.layerStatesArray && map) {
      frameState.layerStatesArray = map.getLayerGroup().getLayerStatesArray();
    }
    let layerState;
    if (frameState.layerStatesArray) {
      layerState = frameState.layerStatesArray.find(
        (layerState2) => layerState2.layer === this
      );
      if (!layerState) {
        return false;
      }
    } else {
      layerState = this.getLayerState();
    }
    const layerExtent = this.getExtent();
    return inView(layerState, frameState.viewState) && (!layerExtent || intersects(layerExtent, frameState.extent));
  }
  /**
   * Get the attributions of the source of this layer for the given view.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {Array<string>} Attributions for this layer at the given view.
   * @api
   */
  getAttributions(view) {
    if (!this.isVisible(view)) {
      return [];
    }
    const getAttributions = this.getSource()?.getAttributions();
    if (!getAttributions) {
      return [];
    }
    const frameState = view instanceof View_default ? view.getViewStateAndExtent() : view;
    let attributions = getAttributions(frameState);
    if (!Array.isArray(attributions)) {
      attributions = [attributions];
    }
    return attributions;
  }
  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement|null} The rendered element.
   */
  render(frameState, target) {
    const layerRenderer = this.getRenderer();
    if (layerRenderer.prepareFrame(frameState)) {
      this.rendered = true;
      return layerRenderer.renderFrame(frameState, target);
    }
    return null;
  }
  /**
   * Called when a layer is not visible during a map render.
   */
  unrender() {
    this.rendered = false;
  }
  /** @return {string} Declutter */
  getDeclutter() {
    return void 0;
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(frameState, layerState) {
  }
  /**
   * When the renderer follows a layout -> render approach, do the final rendering here.
   * @param {import('../Map.js').FrameState} frameState Frame state
   */
  renderDeferred(frameState) {
    const layerRenderer = this.getRenderer();
    if (!layerRenderer) {
      return;
    }
    layerRenderer.renderDeferred(frameState);
  }
  /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMapInternal(map) {
    if (!map) {
      this.unrender();
    }
    this.set(Property_default2.MAP, map);
  }
  /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */
  getMapInternal() {
    return this.get(Property_default2.MAP);
  }
  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(map) {
    if (this.mapPrecomposeKey_) {
      unlistenByKey(this.mapPrecomposeKey_);
      this.mapPrecomposeKey_ = null;
    }
    if (!map) {
      this.changed();
    }
    if (this.mapRenderKey_) {
      unlistenByKey(this.mapRenderKey_);
      this.mapRenderKey_ = null;
    }
    if (map) {
      this.mapPrecomposeKey_ = listen(
        map,
        EventType_default3.PRECOMPOSE,
        this.handlePrecompose_,
        this
      );
      this.mapRenderKey_ = listen(this, EventType_default.CHANGE, map.render, map);
      this.changed();
    }
  }
  /**
   * @param {import("../events/Event.js").default} renderEvent Render event
   * @private
   */
  handlePrecompose_(renderEvent) {
    const layerStatesArray = (
      /** @type {import("../render/Event.js").default} */
      renderEvent.frameState.layerStatesArray
    );
    const layerState = this.getLayerState(false);
    assert(
      !layerStatesArray.some(
        (arrayLayerState) => arrayLayerState.layer === layerState.layer
      ),
      "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
    );
    layerStatesArray.push(layerState);
  }
  /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */
  setSource(source) {
    this.set(Property_default2.SOURCE, source);
  }
  /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */
  getRenderer() {
    if (!this.renderer_) {
      this.renderer_ = this.createRenderer();
    }
    return this.renderer_;
  }
  /**
   * @return {boolean} The layer has a renderer.
   */
  hasRenderer() {
    return !!this.renderer_;
  }
  /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */
  createRenderer() {
    return null;
  }
  /**
   * This will clear the renderer so that a new one can be created next time it is needed
   */
  clearRenderer() {
    if (this.renderer_) {
      this.renderer_.dispose();
      delete this.renderer_;
    }
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.clearRenderer();
    this.setSource(null);
    super.disposeInternal();
  }
};
function inView(layerState, viewState) {
  if (!layerState.visible) {
    return false;
  }
  const resolution = viewState.resolution;
  if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
    return false;
  }
  const zoom = viewState.zoom;
  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
var Layer_default = Layer;

// node_modules/quickselect/index.js
function quickselect(arr, k, left = 0, right = arr.length - 1, compare = defaultCompare) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(arr, k, newLeft, newRight, compare);
    }
    const t = arr[k];
    let i = left;
    let j = right;
    swap(arr, left, k);
    if (compare(arr[right], t) > 0) swap(arr, left, right);
    while (i < j) {
      swap(arr, i, j);
      i++;
      j--;
      while (compare(arr[i], t) < 0) i++;
      while (compare(arr[j], t) > 0) j--;
    }
    if (compare(arr[left], t) === 0) swap(arr, left, j);
    else {
      j++;
      swap(arr, j, right);
    }
    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }
}
function swap(arr, i, j) {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultCompare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}

// node_modules/rbush/index.js
var RBush = class {
  constructor(maxEntries = 9) {
    this._maxEntries = Math.max(4, maxEntries);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
    this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(bbox) {
    let node = this.data;
    const result = [];
    if (!intersects2(bbox, node)) return result;
    const toBBox = this.toBBox;
    const nodesToSearch = [];
    while (node) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childBBox = node.leaf ? toBBox(child) : child;
        if (intersects2(bbox, childBBox)) {
          if (node.leaf) result.push(child);
          else if (contains(bbox, childBBox)) this._all(child, result);
          else nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return result;
  }
  collides(bbox) {
    let node = this.data;
    if (!intersects2(bbox, node)) return false;
    const nodesToSearch = [];
    while (node) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childBBox = node.leaf ? this.toBBox(child) : child;
        if (intersects2(bbox, childBBox)) {
          if (node.leaf || contains(bbox, childBBox)) return true;
          nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return false;
  }
  load(data) {
    if (!(data && data.length)) return this;
    if (data.length < this._minEntries) {
      for (let i = 0; i < data.length; i++) {
        this.insert(data[i]);
      }
      return this;
    }
    let node = this._build(data.slice(), 0, data.length - 1, 0);
    if (!this.data.children.length) {
      this.data = node;
    } else if (this.data.height === node.height) {
      this._splitRoot(this.data, node);
    } else {
      if (this.data.height < node.height) {
        const tmpNode = this.data;
        this.data = node;
        node = tmpNode;
      }
      this._insert(node, this.data.height - node.height - 1, true);
    }
    return this;
  }
  insert(item) {
    if (item) this._insert(item, this.data.height - 1);
    return this;
  }
  clear() {
    this.data = createNode([]);
    return this;
  }
  remove(item, equalsFn) {
    if (!item) return this;
    let node = this.data;
    const bbox = this.toBBox(item);
    const path = [];
    const indexes = [];
    let i, parent, goingUp;
    while (node || path.length) {
      if (!node) {
        node = path.pop();
        parent = path[path.length - 1];
        i = indexes.pop();
        goingUp = true;
      }
      if (node.leaf) {
        const index = findItem(item, node.children, equalsFn);
        if (index !== -1) {
          node.children.splice(index, 1);
          path.push(node);
          this._condense(path);
          return this;
        }
      }
      if (!goingUp && !node.leaf && contains(node, bbox)) {
        path.push(node);
        indexes.push(i);
        i = 0;
        parent = node;
        node = node.children[0];
      } else if (parent) {
        i++;
        node = parent.children[i];
        goingUp = false;
      } else node = null;
    }
    return this;
  }
  toBBox(item) {
    return item;
  }
  compareMinX(a, b) {
    return a.minX - b.minX;
  }
  compareMinY(a, b) {
    return a.minY - b.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(data) {
    this.data = data;
    return this;
  }
  _all(node, result) {
    const nodesToSearch = [];
    while (node) {
      if (node.leaf) result.push(...node.children);
      else nodesToSearch.push(...node.children);
      node = nodesToSearch.pop();
    }
    return result;
  }
  _build(items, left, right, height) {
    const N = right - left + 1;
    let M = this._maxEntries;
    let node;
    if (N <= M) {
      node = createNode(items.slice(left, right + 1));
      calcBBox(node, this.toBBox);
      return node;
    }
    if (!height) {
      height = Math.ceil(Math.log(N) / Math.log(M));
      M = Math.ceil(N / Math.pow(M, height - 1));
    }
    node = createNode([]);
    node.leaf = false;
    node.height = height;
    const N2 = Math.ceil(N / M);
    const N1 = N2 * Math.ceil(Math.sqrt(M));
    multiSelect(items, left, right, N1, this.compareMinX);
    for (let i = left; i <= right; i += N1) {
      const right2 = Math.min(i + N1 - 1, right);
      multiSelect(items, i, right2, N2, this.compareMinY);
      for (let j = i; j <= right2; j += N2) {
        const right3 = Math.min(j + N2 - 1, right2);
        node.children.push(this._build(items, j, right3, height - 1));
      }
    }
    calcBBox(node, this.toBBox);
    return node;
  }
  _chooseSubtree(bbox, node, level2, path) {
    while (true) {
      path.push(node);
      if (node.leaf || path.length - 1 === level2) break;
      let minArea = Infinity;
      let minEnlargement = Infinity;
      let targetNode;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const area = bboxArea(child);
        const enlargement = enlargedArea(bbox, child) - area;
        if (enlargement < minEnlargement) {
          minEnlargement = enlargement;
          minArea = area < minArea ? area : minArea;
          targetNode = child;
        } else if (enlargement === minEnlargement) {
          if (area < minArea) {
            minArea = area;
            targetNode = child;
          }
        }
      }
      node = targetNode || node.children[0];
    }
    return node;
  }
  _insert(item, level2, isNode) {
    const bbox = isNode ? item : this.toBBox(item);
    const insertPath = [];
    const node = this._chooseSubtree(bbox, this.data, level2, insertPath);
    node.children.push(item);
    extend3(node, bbox);
    while (level2 >= 0) {
      if (insertPath[level2].children.length > this._maxEntries) {
        this._split(insertPath, level2);
        level2--;
      } else break;
    }
    this._adjustParentBBoxes(bbox, insertPath, level2);
  }
  // split overflowed node into two
  _split(insertPath, level2) {
    const node = insertPath[level2];
    const M = node.children.length;
    const m = this._minEntries;
    this._chooseSplitAxis(node, m, M);
    const splitIndex = this._chooseSplitIndex(node, m, M);
    const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
    newNode.height = node.height;
    newNode.leaf = node.leaf;
    calcBBox(node, this.toBBox);
    calcBBox(newNode, this.toBBox);
    if (level2) insertPath[level2 - 1].children.push(newNode);
    else this._splitRoot(node, newNode);
  }
  _splitRoot(node, newNode) {
    this.data = createNode([node, newNode]);
    this.data.height = node.height + 1;
    this.data.leaf = false;
    calcBBox(this.data, this.toBBox);
  }
  _chooseSplitIndex(node, m, M) {
    let index;
    let minOverlap = Infinity;
    let minArea = Infinity;
    for (let i = m; i <= M - m; i++) {
      const bbox1 = distBBox(node, 0, i, this.toBBox);
      const bbox2 = distBBox(node, i, M, this.toBBox);
      const overlap = intersectionArea(bbox1, bbox2);
      const area = bboxArea(bbox1) + bboxArea(bbox2);
      if (overlap < minOverlap) {
        minOverlap = overlap;
        index = i;
        minArea = area < minArea ? area : minArea;
      } else if (overlap === minOverlap) {
        if (area < minArea) {
          minArea = area;
          index = i;
        }
      }
    }
    return index || M - m;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(node, m, M) {
    const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
    const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
    const xMargin = this._allDistMargin(node, m, M, compareMinX);
    const yMargin = this._allDistMargin(node, m, M, compareMinY);
    if (xMargin < yMargin) node.children.sort(compareMinX);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(node, m, M, compare) {
    node.children.sort(compare);
    const toBBox = this.toBBox;
    const leftBBox = distBBox(node, 0, m, toBBox);
    const rightBBox = distBBox(node, M - m, M, toBBox);
    let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
    for (let i = m; i < M - m; i++) {
      const child = node.children[i];
      extend3(leftBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(leftBBox);
    }
    for (let i = M - m - 1; i >= m; i--) {
      const child = node.children[i];
      extend3(rightBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(rightBBox);
    }
    return margin;
  }
  _adjustParentBBoxes(bbox, path, level2) {
    for (let i = level2; i >= 0; i--) {
      extend3(path[i], bbox);
    }
  }
  _condense(path) {
    for (let i = path.length - 1, siblings; i >= 0; i--) {
      if (path[i].children.length === 0) {
        if (i > 0) {
          siblings = path[i - 1].children;
          siblings.splice(siblings.indexOf(path[i]), 1);
        } else this.clear();
      } else calcBBox(path[i], this.toBBox);
    }
  }
};
function findItem(item, items, equalsFn) {
  if (!equalsFn) return items.indexOf(item);
  for (let i = 0; i < items.length; i++) {
    if (equalsFn(item, items[i])) return i;
  }
  return -1;
}
function calcBBox(node, toBBox) {
  distBBox(node, 0, node.children.length, toBBox, node);
}
function distBBox(node, k, p, toBBox, destNode) {
  if (!destNode) destNode = createNode(null);
  destNode.minX = Infinity;
  destNode.minY = Infinity;
  destNode.maxX = -Infinity;
  destNode.maxY = -Infinity;
  for (let i = k; i < p; i++) {
    const child = node.children[i];
    extend3(destNode, node.leaf ? toBBox(child) : child);
  }
  return destNode;
}
function extend3(a, b) {
  a.minX = Math.min(a.minX, b.minX);
  a.minY = Math.min(a.minY, b.minY);
  a.maxX = Math.max(a.maxX, b.maxX);
  a.maxY = Math.max(a.maxY, b.maxY);
  return a;
}
function compareNodeMinX(a, b) {
  return a.minX - b.minX;
}
function compareNodeMinY(a, b) {
  return a.minY - b.minY;
}
function bboxArea(a) {
  return (a.maxX - a.minX) * (a.maxY - a.minY);
}
function bboxMargin(a) {
  return a.maxX - a.minX + (a.maxY - a.minY);
}
function enlargedArea(a, b) {
  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}
function intersectionArea(a, b) {
  const minX = Math.max(a.minX, b.minX);
  const minY = Math.max(a.minY, b.minY);
  const maxX = Math.min(a.maxX, b.maxX);
  const maxY = Math.min(a.maxY, b.maxY);
  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}
function contains(a, b) {
  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
}
function intersects2(a, b) {
  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
}
function createNode(children) {
  return {
    children,
    height: 1,
    leaf: true,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
}
function multiSelect(arr, left, right, n, compare) {
  const stack = [left, right];
  while (stack.length) {
    right = stack.pop();
    left = stack.pop();
    if (right - left <= n) continue;
    const mid = left + Math.ceil((right - left) / n / 2) * n;
    quickselect(arr, mid, left, right, compare);
    stack.push(left, mid, mid, right);
  }
}

// node_modules/ol/color.js
var NO_COLOR = [NaN, NaN, NaN, 0];
var colorParseContext;
function getColorParseContext() {
  if (!colorParseContext) {
    colorParseContext = createCanvasContext2D(1, 1, void 0, {
      willReadFrequently: true,
      desynchronized: true
    });
  }
  return colorParseContext;
}
var rgbModernRegEx = /^rgba?\(\s*(\d+%?)\s+(\d+%?)\s+(\d+%?)(?:\s*\/\s*(\d+%|\d*\.\d+|[01]))?\s*\)$/i;
var rgbLegacyAbsoluteRegEx = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*(\d+%|\d*\.\d+|[01]))?\s*\)$/i;
var rgbLegacyPercentageRegEx = /^rgba?\(\s*(\d+%)\s*,\s*(\d+%)\s*,\s*(\d+%)(?:\s*,\s*(\d+%|\d*\.\d+|[01]))?\s*\)$/i;
var hexRegEx = /^#([\da-f]{3,4}|[\da-f]{6}|[\da-f]{8})$/i;
function toColorComponent(s, divider) {
  return s.endsWith("%") ? Number(s.substring(0, s.length - 1)) / divider : Number(s);
}
function throwInvalidColor(color) {
  throw new Error('failed to parse "' + color + '" as color');
}
function parseRgba(color) {
  if (color.toLowerCase().startsWith("rgb")) {
    const rgb = color.match(rgbLegacyAbsoluteRegEx) || color.match(rgbModernRegEx) || color.match(rgbLegacyPercentageRegEx);
    if (rgb) {
      const alpha = rgb[4];
      const rgbDivider = 100 / 255;
      return [
        clamp(toColorComponent(rgb[1], rgbDivider) + 0.5 | 0, 0, 255),
        clamp(toColorComponent(rgb[2], rgbDivider) + 0.5 | 0, 0, 255),
        clamp(toColorComponent(rgb[3], rgbDivider) + 0.5 | 0, 0, 255),
        alpha !== void 0 ? clamp(toColorComponent(alpha, 100), 0, 1) : 1
      ];
    }
    throwInvalidColor(color);
  }
  if (color.startsWith("#")) {
    if (hexRegEx.test(color)) {
      const hex = color.substring(1);
      const step = hex.length <= 4 ? 1 : 2;
      const colorFromHex = [0, 0, 0, 255];
      for (let i = 0, ii = hex.length; i < ii; i += step) {
        let colorComponent = parseInt(hex.substring(i, i + step), 16);
        if (step === 1) {
          colorComponent += colorComponent << 4;
        }
        colorFromHex[i / step] = colorComponent;
      }
      colorFromHex[3] = colorFromHex[3] / 255;
      return colorFromHex;
    }
    throwInvalidColor(color);
  }
  const context = getColorParseContext();
  context.fillStyle = "#abcdef";
  let invalidCheckFillStyle = context.fillStyle;
  context.fillStyle = color;
  if (context.fillStyle === invalidCheckFillStyle) {
    context.fillStyle = "#fedcba";
    invalidCheckFillStyle = context.fillStyle;
    context.fillStyle = color;
    if (context.fillStyle === invalidCheckFillStyle) {
      throwInvalidColor(color);
    }
  }
  const colorString = context.fillStyle;
  if (colorString.startsWith("#") || colorString.startsWith("rgba")) {
    return parseRgba(colorString);
  }
  context.clearRect(0, 0, 1, 1);
  context.fillRect(0, 0, 1, 1);
  const colorFromImage = Array.from(context.getImageData(0, 0, 1, 1).data);
  colorFromImage[3] = toFixed(colorFromImage[3] / 255, 3);
  return colorFromImage;
}
function asString(color) {
  if (typeof color === "string") {
    return color;
  }
  return toString2(color);
}
var MAX_CACHE_SIZE = 1024;
var cache2 = {};
var cacheSize = 0;
function withAlpha(color) {
  if (color.length === 4) {
    return color;
  }
  const output = color.slice();
  output[3] = 1;
  return output;
}
function b1(v) {
  return v > 31308e-7 ? Math.pow(v, 1 / 2.4) * 269.025 - 14.025 : v * 3294.6;
}
function b2(v) {
  return v > 0.2068965 ? Math.pow(v, 3) : (v - 4 / 29) * (108 / 841);
}
function a1(v) {
  return v > 10.314724 ? Math.pow((v + 14.025) / 269.025, 2.4) : v / 3294.6;
}
function a2(v) {
  return v > 88564e-7 ? Math.pow(v, 1 / 3) : v / (108 / 841) + 4 / 29;
}
function rgbaToLcha(color) {
  const r = a1(color[0]);
  const g = a1(color[1]);
  const b = a1(color[2]);
  const y = a2(r * 0.222488403 + g * 0.716873169 + b * 0.06060791);
  const l = 500 * (a2(r * 0.452247074 + g * 0.399439023 + b * 0.148375274) - y);
  const q = 200 * (y - a2(r * 0.016863605 + g * 0.117638439 + b * 0.865350722));
  const h = Math.atan2(q, l) * (180 / Math.PI);
  return [
    116 * y - 16,
    Math.sqrt(l * l + q * q),
    h < 0 ? h + 360 : h,
    color[3]
  ];
}
function lchaToRgba(color) {
  const l = (color[0] + 16) / 116;
  const c = color[1];
  const h = color[2] * Math.PI / 180;
  const y = b2(l);
  const x = b2(l + c / 500 * Math.cos(h));
  const z = b2(l - c / 200 * Math.sin(h));
  const r = b1(x * 3.021973625 - y * 1.617392459 - z * 0.404875592);
  const g = b1(x * -0.943766287 + y * 1.916279586 + z * 0.027607165);
  const b = b1(x * 0.069407491 - y * 0.22898585 + z * 1.159737864);
  return [
    clamp(r + 0.5 | 0, 0, 255),
    clamp(g + 0.5 | 0, 0, 255),
    clamp(b + 0.5 | 0, 0, 255),
    color[3]
  ];
}
function fromString2(s) {
  if (s === "none") {
    return NO_COLOR;
  }
  if (cache2.hasOwnProperty(s)) {
    return cache2[s];
  }
  if (cacheSize >= MAX_CACHE_SIZE) {
    let i = 0;
    for (const key in cache2) {
      if ((i++ & 3) === 0) {
        delete cache2[key];
        --cacheSize;
      }
    }
  }
  const color = parseRgba(s);
  if (color.length !== 4) {
    throwInvalidColor(s);
  }
  for (const c of color) {
    if (isNaN(c)) {
      throwInvalidColor(s);
    }
  }
  cache2[s] = color;
  ++cacheSize;
  return color;
}
function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  }
  return fromString2(color);
}
function toString2(color) {
  let r = color[0];
  if (r != (r | 0)) {
    r = r + 0.5 | 0;
  }
  let g = color[1];
  if (g != (g | 0)) {
    g = g + 0.5 | 0;
  }
  let b = color[2];
  if (b != (b | 0)) {
    b = b + 0.5 | 0;
  }
  const a = color[3] === void 0 ? 1 : Math.round(color[3] * 1e3) / 1e3;
  return "rgba(" + r + "," + g + "," + b + "," + a + ")";
}

// node_modules/ol/size.js
function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}
function scale3(size, ratio, dest) {
  if (dest === void 0) {
    dest = [0, 0];
  }
  dest[0] = size[0] * ratio + 0.5 | 0;
  dest[1] = size[1] * ratio + 0.5 | 0;
  return dest;
}
function toSize(size, dest) {
  if (Array.isArray(size)) {
    return size;
  }
  if (dest === void 0) {
    dest = [size, size];
  } else {
    dest[0] = size;
    dest[1] = size;
  }
  return dest;
}

// node_modules/ol/expr/expression.js
var numTypes = 0;
var BooleanType = 1 << numTypes++;
var NumberType = 1 << numTypes++;
var StringType = 1 << numTypes++;
var ColorType = 1 << numTypes++;
var NumberArrayType = 1 << numTypes++;
var SizeType = 1 << numTypes++;
var AnyType = Math.pow(2, numTypes) - 1;
var typeNames = {
  [BooleanType]: "boolean",
  [NumberType]: "number",
  [StringType]: "string",
  [ColorType]: "color",
  [NumberArrayType]: "number[]",
  [SizeType]: "size"
};
var namedTypes = Object.keys(typeNames).map(Number).sort(ascending);
function isSpecific(type) {
  return type in typeNames;
}
function typeName(type) {
  const names = [];
  for (const namedType of namedTypes) {
    if (includesType(type, namedType)) {
      names.push(typeNames[namedType]);
    }
  }
  if (names.length === 0) {
    return "untyped";
  }
  if (names.length < 3) {
    return names.join(" or ");
  }
  return names.slice(0, -1).join(", ") + ", or " + names[names.length - 1];
}
function includesType(broad, specific) {
  return (broad & specific) === specific;
}
function isType(type, expected) {
  return type === expected;
}
var LiteralExpression = class {
  /**
   * @param {number} type The value type.
   * @param {LiteralValue} value The literal value.
   */
  constructor(type, value) {
    if (!isSpecific(type)) {
      throw new Error(
        `literal expressions must have a specific type, got ${typeName(type)}`
      );
    }
    this.type = type;
    this.value = value;
  }
};
var CallExpression = class {
  /**
   * @param {number} type The return type.
   * @param {string} operator The operator.
   * @param {...Expression} args The arguments.
   */
  constructor(type, operator, ...args) {
    this.type = type;
    this.operator = operator;
    this.args = args;
  }
};
function newParsingContext() {
  return {
    variables: /* @__PURE__ */ new Set(),
    properties: /* @__PURE__ */ new Set(),
    featureId: false,
    geometryType: false,
    mapState: false
  };
}
function parse(encoded, expectedType, context) {
  switch (typeof encoded) {
    case "boolean": {
      if (isType(expectedType, StringType)) {
        return new LiteralExpression(StringType, encoded ? "true" : "false");
      }
      if (!includesType(expectedType, BooleanType)) {
        throw new Error(
          `got a boolean, but expected ${typeName(expectedType)}`
        );
      }
      return new LiteralExpression(BooleanType, encoded);
    }
    case "number": {
      if (isType(expectedType, SizeType)) {
        return new LiteralExpression(SizeType, toSize(encoded));
      }
      if (isType(expectedType, BooleanType)) {
        return new LiteralExpression(BooleanType, !!encoded);
      }
      if (isType(expectedType, StringType)) {
        return new LiteralExpression(StringType, encoded.toString());
      }
      if (!includesType(expectedType, NumberType)) {
        throw new Error(`got a number, but expected ${typeName(expectedType)}`);
      }
      return new LiteralExpression(NumberType, encoded);
    }
    case "string": {
      if (isType(expectedType, ColorType)) {
        return new LiteralExpression(ColorType, fromString2(encoded));
      }
      if (isType(expectedType, BooleanType)) {
        return new LiteralExpression(BooleanType, !!encoded);
      }
      if (!includesType(expectedType, StringType)) {
        throw new Error(`got a string, but expected ${typeName(expectedType)}`);
      }
      return new LiteralExpression(StringType, encoded);
    }
    default: {
    }
  }
  if (!Array.isArray(encoded)) {
    throw new Error("expression must be an array or a primitive value");
  }
  if (encoded.length === 0) {
    throw new Error("empty expression");
  }
  if (typeof encoded[0] === "string") {
    return parseCallExpression(encoded, expectedType, context);
  }
  for (const item of encoded) {
    if (typeof item !== "number") {
      throw new Error("expected an array of numbers");
    }
  }
  if (isType(expectedType, SizeType)) {
    if (encoded.length !== 2) {
      throw new Error(
        `expected an array of two values for a size, got ${encoded.length}`
      );
    }
    return new LiteralExpression(SizeType, encoded);
  }
  if (isType(expectedType, ColorType)) {
    if (encoded.length === 3) {
      return new LiteralExpression(ColorType, [...encoded, 1]);
    }
    if (encoded.length === 4) {
      return new LiteralExpression(ColorType, encoded);
    }
    throw new Error(
      `expected an array of 3 or 4 values for a color, got ${encoded.length}`
    );
  }
  if (!includesType(expectedType, NumberArrayType)) {
    throw new Error(
      `got an array of numbers, but expected ${typeName(expectedType)}`
    );
  }
  return new LiteralExpression(NumberArrayType, encoded);
}
var Ops = {
  Get: "get",
  Var: "var",
  Concat: "concat",
  GeometryType: "geometry-type",
  LineMetric: "line-metric",
  Any: "any",
  All: "all",
  Not: "!",
  Resolution: "resolution",
  Zoom: "zoom",
  Time: "time",
  Equal: "==",
  NotEqual: "!=",
  GreaterThan: ">",
  GreaterThanOrEqualTo: ">=",
  LessThan: "<",
  LessThanOrEqualTo: "<=",
  Multiply: "*",
  Divide: "/",
  Add: "+",
  Subtract: "-",
  Clamp: "clamp",
  Mod: "%",
  Pow: "^",
  Abs: "abs",
  Floor: "floor",
  Ceil: "ceil",
  Round: "round",
  Sin: "sin",
  Cos: "cos",
  Atan: "atan",
  Sqrt: "sqrt",
  Match: "match",
  Between: "between",
  Interpolate: "interpolate",
  Coalesce: "coalesce",
  Case: "case",
  In: "in",
  Number: "number",
  String: "string",
  Array: "array",
  Color: "color",
  Id: "id",
  Band: "band",
  Palette: "palette",
  ToString: "to-string",
  Has: "has"
};
var parsers = {
  [Ops.Get]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),
  [Ops.Var]: createCallExpressionParser(hasArgsCount(1, 1), withVarArgs),
  [Ops.Has]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),
  [Ops.Id]: createCallExpressionParser(usesFeatureId, withNoArgs),
  [Ops.Concat]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfType(StringType)
  ),
  [Ops.GeometryType]: createCallExpressionParser(usesGeometryType, withNoArgs),
  [Ops.LineMetric]: createCallExpressionParser(withNoArgs),
  [Ops.Resolution]: createCallExpressionParser(usesMapState, withNoArgs),
  [Ops.Zoom]: createCallExpressionParser(usesMapState, withNoArgs),
  [Ops.Time]: createCallExpressionParser(usesMapState, withNoArgs),
  [Ops.Any]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfType(BooleanType)
  ),
  [Ops.All]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfType(BooleanType)
  ),
  [Ops.Not]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(BooleanType)
  ),
  [Ops.Equal]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(AnyType)
  ),
  [Ops.NotEqual]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(AnyType)
  ),
  [Ops.GreaterThan]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.GreaterThanOrEqualTo]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.LessThan]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.LessThanOrEqualTo]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.Multiply]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfReturnType
  ),
  [Ops.Coalesce]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfReturnType
  ),
  [Ops.Divide]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.Add]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfType(NumberType)
  ),
  [Ops.Subtract]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.Clamp]: createCallExpressionParser(
    hasArgsCount(3, 3),
    withArgsOfType(NumberType)
  ),
  [Ops.Mod]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.Pow]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.Abs]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType)
  ),
  [Ops.Floor]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType)
  ),
  [Ops.Ceil]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType)
  ),
  [Ops.Round]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType)
  ),
  [Ops.Sin]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType)
  ),
  [Ops.Cos]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType)
  ),
  [Ops.Atan]: createCallExpressionParser(
    hasArgsCount(1, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.Sqrt]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType)
  ),
  [Ops.Match]: createCallExpressionParser(
    hasArgsCount(4, Infinity),
    hasEvenArgs,
    withMatchArgs
  ),
  [Ops.Between]: createCallExpressionParser(
    hasArgsCount(3, 3),
    withArgsOfType(NumberType)
  ),
  [Ops.Interpolate]: createCallExpressionParser(
    hasArgsCount(6, Infinity),
    hasEvenArgs,
    withInterpolateArgs
  ),
  [Ops.Case]: createCallExpressionParser(
    hasArgsCount(3, Infinity),
    hasOddArgs,
    withCaseArgs
  ),
  [Ops.In]: createCallExpressionParser(hasArgsCount(2, 2), withInArgs),
  [Ops.Number]: createCallExpressionParser(
    hasArgsCount(1, Infinity),
    withArgsOfType(AnyType)
  ),
  [Ops.String]: createCallExpressionParser(
    hasArgsCount(1, Infinity),
    withArgsOfType(AnyType)
  ),
  [Ops.Array]: createCallExpressionParser(
    hasArgsCount(1, Infinity),
    withArgsOfType(NumberType)
  ),
  [Ops.Color]: createCallExpressionParser(
    hasArgsCount(1, 4),
    withArgsOfType(NumberType)
  ),
  [Ops.Band]: createCallExpressionParser(
    hasArgsCount(1, 3),
    withArgsOfType(NumberType)
  ),
  [Ops.Palette]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withPaletteArgs
  ),
  [Ops.ToString]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(BooleanType | NumberType | StringType | ColorType)
  )
};
function withGetArgs(encoded, returnType, context) {
  const argsCount = encoded.length - 1;
  const args = new Array(argsCount);
  for (let i = 0; i < argsCount; ++i) {
    const key = encoded[i + 1];
    switch (typeof key) {
      case "number": {
        args[i] = new LiteralExpression(NumberType, key);
        break;
      }
      case "string": {
        args[i] = new LiteralExpression(StringType, key);
        break;
      }
      default: {
        throw new Error(
          `expected a string key or numeric array index for a get operation, got ${key}`
        );
      }
    }
    if (i === 0) {
      context.properties.add(String(key));
    }
  }
  return args;
}
function withVarArgs(encoded, returnType, context) {
  const name = encoded[1];
  if (typeof name !== "string") {
    throw new Error("expected a string argument for var operation");
  }
  context.variables.add(name);
  return [new LiteralExpression(StringType, name)];
}
function usesFeatureId(encoded, returnType, context) {
  context.featureId = true;
}
function usesGeometryType(encoded, returnType, context) {
  context.geometryType = true;
}
function usesMapState(encoded, returnType, context) {
  context.mapState = true;
}
function withNoArgs(encoded, returnType, context) {
  const operation = encoded[0];
  if (encoded.length !== 1) {
    throw new Error(`expected no arguments for ${operation} operation`);
  }
  return [];
}
function hasArgsCount(minArgs, maxArgs) {
  return function(encoded, returnType, context) {
    const operation = encoded[0];
    const argCount = encoded.length - 1;
    if (minArgs === maxArgs) {
      if (argCount !== minArgs) {
        const plural = minArgs === 1 ? "" : "s";
        throw new Error(
          `expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`
        );
      }
    } else if (argCount < minArgs || argCount > maxArgs) {
      const range = maxArgs === Infinity ? `${minArgs} or more` : `${minArgs} to ${maxArgs}`;
      throw new Error(
        `expected ${range} arguments for ${operation}, got ${argCount}`
      );
    }
  };
}
function withArgsOfReturnType(encoded, returnType, context) {
  const argCount = encoded.length - 1;
  const args = new Array(argCount);
  for (let i = 0; i < argCount; ++i) {
    const expression = parse(encoded[i + 1], returnType, context);
    args[i] = expression;
  }
  return args;
}
function withArgsOfType(argType) {
  return function(encoded, returnType, context) {
    const argCount = encoded.length - 1;
    const args = new Array(argCount);
    for (let i = 0; i < argCount; ++i) {
      const expression = parse(encoded[i + 1], argType, context);
      args[i] = expression;
    }
    return args;
  };
}
function hasOddArgs(encoded, returnType, context) {
  const operation = encoded[0];
  const argCount = encoded.length - 1;
  if (argCount % 2 === 0) {
    throw new Error(
      `expected an odd number of arguments for ${operation}, got ${argCount} instead`
    );
  }
}
function hasEvenArgs(encoded, returnType, context) {
  const operation = encoded[0];
  const argCount = encoded.length - 1;
  if (argCount % 2 === 1) {
    throw new Error(
      `expected an even number of arguments for operation ${operation}, got ${argCount} instead`
    );
  }
}
function withMatchArgs(encoded, returnType, context) {
  const argsCount = encoded.length - 1;
  const inputType = StringType | NumberType | BooleanType;
  const input = parse(encoded[1], inputType, context);
  const fallback = parse(encoded[encoded.length - 1], returnType, context);
  const args = new Array(argsCount - 2);
  for (let i = 0; i < argsCount - 2; i += 2) {
    try {
      const match = parse(encoded[i + 2], input.type, context);
      args[i] = match;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i + 1} of match expression: ${err.message}`
      );
    }
    try {
      const output = parse(encoded[i + 3], fallback.type, context);
      args[i + 1] = output;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i + 2} of match expression: ${err.message}`
      );
    }
  }
  return [input, ...args, fallback];
}
function withInterpolateArgs(encoded, returnType, context) {
  const interpolationType = encoded[1];
  let base;
  switch (interpolationType[0]) {
    case "linear":
      base = 1;
      break;
    case "exponential":
      const b = interpolationType[1];
      if (typeof b !== "number" || b <= 0) {
        throw new Error(
          `expected a number base for exponential interpolation, got ${JSON.stringify(b)} instead`
        );
      }
      base = b;
      break;
    default:
      throw new Error(
        `invalid interpolation type: ${JSON.stringify(interpolationType)}`
      );
  }
  const interpolation = new LiteralExpression(NumberType, base);
  let input;
  try {
    input = parse(encoded[2], NumberType, context);
  } catch (err) {
    throw new Error(
      `failed to parse argument 1 in interpolate expression: ${err.message}`
    );
  }
  const args = new Array(encoded.length - 3);
  for (let i = 0; i < args.length; i += 2) {
    try {
      const stop = parse(encoded[i + 3], NumberType, context);
      args[i] = stop;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i + 2} for interpolate expression: ${err.message}`
      );
    }
    try {
      const output = parse(encoded[i + 4], returnType, context);
      args[i + 1] = output;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i + 3} for interpolate expression: ${err.message}`
      );
    }
  }
  return [interpolation, input, ...args];
}
function withCaseArgs(encoded, returnType, context) {
  const fallback = parse(encoded[encoded.length - 1], returnType, context);
  const args = new Array(encoded.length - 1);
  for (let i = 0; i < args.length - 1; i += 2) {
    try {
      const condition = parse(encoded[i + 1], BooleanType, context);
      args[i] = condition;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i} of case expression: ${err.message}`
      );
    }
    try {
      const output = parse(encoded[i + 2], fallback.type, context);
      args[i + 1] = output;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i + 1} of case expression: ${err.message}`
      );
    }
  }
  args[args.length - 1] = fallback;
  return args;
}
function withInArgs(encoded, returnType, context) {
  let haystack = encoded[2];
  if (!Array.isArray(haystack)) {
    throw new Error(
      `the second argument for the "in" operator must be an array`
    );
  }
  let needleType;
  if (typeof haystack[0] === "string") {
    if (haystack[0] !== "literal") {
      throw new Error(
        `for the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions`
      );
    }
    if (!Array.isArray(haystack[1])) {
      throw new Error(
        `failed to parse "in" expression: the literal operator must be followed by an array`
      );
    }
    haystack = haystack[1];
    needleType = StringType;
  } else {
    needleType = NumberType;
  }
  const args = new Array(haystack.length);
  for (let i = 0; i < args.length; i++) {
    try {
      const arg = parse(haystack[i], needleType, context);
      args[i] = arg;
    } catch (err) {
      throw new Error(
        `failed to parse haystack item ${i} for "in" expression: ${err.message}`
      );
    }
  }
  const needle = parse(encoded[1], needleType, context);
  return [needle, ...args];
}
function withPaletteArgs(encoded, returnType, context) {
  let index;
  try {
    index = parse(encoded[1], NumberType, context);
  } catch (err) {
    throw new Error(
      `failed to parse first argument in palette expression: ${err.message}`
    );
  }
  const colors = encoded[2];
  if (!Array.isArray(colors)) {
    throw new Error("the second argument of palette must be an array");
  }
  const parsedColors = new Array(colors.length);
  for (let i = 0; i < parsedColors.length; i++) {
    let color;
    try {
      color = parse(colors[i], ColorType, context);
    } catch (err) {
      throw new Error(
        `failed to parse color at index ${i} in palette expression: ${err.message}`
      );
    }
    if (!(color instanceof LiteralExpression)) {
      throw new Error(
        `the palette color at index ${i} must be a literal value`
      );
    }
    parsedColors[i] = color;
  }
  return [index, ...parsedColors];
}
function createCallExpressionParser(...validators) {
  return function(encoded, returnType, context) {
    const operator = encoded[0];
    let args;
    for (let i = 0; i < validators.length; i++) {
      const parsed = validators[i](encoded, returnType, context);
      if (i == validators.length - 1) {
        if (!parsed) {
          throw new Error(
            "expected last argument validator to return the parsed args"
          );
        }
        args = parsed;
      }
    }
    return new CallExpression(returnType, operator, ...args);
  };
}
function parseCallExpression(encoded, returnType, context) {
  const operator = encoded[0];
  const parser = parsers[operator];
  if (!parser) {
    throw new Error(`unknown operator: ${operator}`);
  }
  return parser(encoded, returnType, context);
}
function computeGeometryType(geometry) {
  if (!geometry) {
    return "";
  }
  const type = geometry.getType();
  switch (type) {
    case "Point":
    case "LineString":
    case "Polygon":
      return type;
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
      return (
        /** @type {'Point'|'LineString'|'Polygon'} */
        type.substring(5)
      );
    case "Circle":
      return "Polygon";
    case "GeometryCollection":
      return computeGeometryType(
        /** @type {import("../geom/GeometryCollection.js").default} */
        geometry.getGeometries()[0]
      );
    default:
      return "";
  }
}

// node_modules/ol/expr/cpu.js
function newEvaluationContext() {
  return {
    variables: {},
    properties: {},
    resolution: NaN,
    featureId: null,
    geometryType: ""
  };
}
function buildExpression(encoded, type, context) {
  const expression = parse(encoded, type, context);
  return compileExpression(expression, context);
}
function compileExpression(expression, context) {
  if (expression instanceof LiteralExpression) {
    if (expression.type === ColorType && typeof expression.value === "string") {
      const colorValue = fromString2(expression.value);
      return function() {
        return colorValue;
      };
    }
    return function() {
      return expression.value;
    };
  }
  const operator = expression.operator;
  switch (operator) {
    case Ops.Number:
    case Ops.String:
    case Ops.Coalesce: {
      return compileAssertionExpression(expression, context);
    }
    case Ops.Get:
    case Ops.Var:
    case Ops.Has: {
      return compileAccessorExpression(expression, context);
    }
    case Ops.Id: {
      return (context2) => context2.featureId;
    }
    case Ops.GeometryType: {
      return (context2) => context2.geometryType;
    }
    case Ops.Concat: {
      const args = expression.args.map((e) => compileExpression(e, context));
      return (context2) => "".concat(...args.map((arg) => arg(context2).toString()));
    }
    case Ops.Resolution: {
      return (context2) => context2.resolution;
    }
    case Ops.Any:
    case Ops.All:
    case Ops.Between:
    case Ops.In:
    case Ops.Not: {
      return compileLogicalExpression(expression, context);
    }
    case Ops.Equal:
    case Ops.NotEqual:
    case Ops.LessThan:
    case Ops.LessThanOrEqualTo:
    case Ops.GreaterThan:
    case Ops.GreaterThanOrEqualTo: {
      return compileComparisonExpression(expression, context);
    }
    case Ops.Multiply:
    case Ops.Divide:
    case Ops.Add:
    case Ops.Subtract:
    case Ops.Clamp:
    case Ops.Mod:
    case Ops.Pow:
    case Ops.Abs:
    case Ops.Floor:
    case Ops.Ceil:
    case Ops.Round:
    case Ops.Sin:
    case Ops.Cos:
    case Ops.Atan:
    case Ops.Sqrt: {
      return compileNumericExpression(expression, context);
    }
    case Ops.Case: {
      return compileCaseExpression(expression, context);
    }
    case Ops.Match: {
      return compileMatchExpression(expression, context);
    }
    case Ops.Interpolate: {
      return compileInterpolateExpression(expression, context);
    }
    case Ops.ToString: {
      return compileConvertExpression(expression, context);
    }
    default: {
      throw new Error(`Unsupported operator ${operator}`);
    }
  }
}
function compileAssertionExpression(expression, context) {
  const type = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (type) {
    case Ops.Coalesce: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          const value = args[i](context2);
          if (typeof value !== "undefined" && value !== null) {
            return value;
          }
        }
        throw new Error("Expected one of the values to be non-null");
      };
    }
    case Ops.Number:
    case Ops.String: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          const value = args[i](context2);
          if (typeof value === type) {
            return value;
          }
        }
        throw new Error(`Expected one of the values to be a ${type}`);
      };
    }
    default: {
      throw new Error(`Unsupported assertion operator ${type}`);
    }
  }
}
function compileAccessorExpression(expression, context) {
  const nameExpression = (
    /** @type {LiteralExpression} */
    expression.args[0]
  );
  const name = (
    /** @type {string} */
    nameExpression.value
  );
  switch (expression.operator) {
    case Ops.Get: {
      return (context2) => {
        const args = expression.args;
        let value = context2.properties[name];
        for (let i = 1, ii = args.length; i < ii; ++i) {
          const keyExpression = (
            /** @type {LiteralExpression} */
            args[i]
          );
          const key = (
            /** @type {string|number} */
            keyExpression.value
          );
          value = value[key];
        }
        return value;
      };
    }
    case Ops.Var: {
      return (context2) => context2.variables[name];
    }
    case Ops.Has: {
      return (context2) => {
        const args = expression.args;
        if (!(name in context2.properties)) {
          return false;
        }
        let value = context2.properties[name];
        for (let i = 1, ii = args.length; i < ii; ++i) {
          const keyExpression = (
            /** @type {LiteralExpression} */
            args[i]
          );
          const key = (
            /** @type {string|number} */
            keyExpression.value
          );
          if (!value || !Object.hasOwn(value, key)) {
            return false;
          }
          value = value[key];
        }
        return true;
      };
    }
    default: {
      throw new Error(`Unsupported accessor operator ${expression.operator}`);
    }
  }
}
function compileComparisonExpression(expression, context) {
  const op = expression.operator;
  const left = compileExpression(expression.args[0], context);
  const right = compileExpression(expression.args[1], context);
  switch (op) {
    case Ops.Equal: {
      return (context2) => left(context2) === right(context2);
    }
    case Ops.NotEqual: {
      return (context2) => left(context2) !== right(context2);
    }
    case Ops.LessThan: {
      return (context2) => left(context2) < right(context2);
    }
    case Ops.LessThanOrEqualTo: {
      return (context2) => left(context2) <= right(context2);
    }
    case Ops.GreaterThan: {
      return (context2) => left(context2) > right(context2);
    }
    case Ops.GreaterThanOrEqualTo: {
      return (context2) => left(context2) >= right(context2);
    }
    default: {
      throw new Error(`Unsupported comparison operator ${op}`);
    }
  }
}
function compileLogicalExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (op) {
    case Ops.Any: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          if (args[i](context2)) {
            return true;
          }
        }
        return false;
      };
    }
    case Ops.All: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          if (!args[i](context2)) {
            return false;
          }
        }
        return true;
      };
    }
    case Ops.Between: {
      return (context2) => {
        const value = args[0](context2);
        const min = args[1](context2);
        const max = args[2](context2);
        return value >= min && value <= max;
      };
    }
    case Ops.In: {
      return (context2) => {
        const value = args[0](context2);
        for (let i = 1; i < length; ++i) {
          if (value === args[i](context2)) {
            return true;
          }
        }
        return false;
      };
    }
    case Ops.Not: {
      return (context2) => !args[0](context2);
    }
    default: {
      throw new Error(`Unsupported logical operator ${op}`);
    }
  }
}
function compileNumericExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (op) {
    case Ops.Multiply: {
      return (context2) => {
        let value = 1;
        for (let i = 0; i < length; ++i) {
          value *= args[i](context2);
        }
        return value;
      };
    }
    case Ops.Divide: {
      return (context2) => args[0](context2) / args[1](context2);
    }
    case Ops.Add: {
      return (context2) => {
        let value = 0;
        for (let i = 0; i < length; ++i) {
          value += args[i](context2);
        }
        return value;
      };
    }
    case Ops.Subtract: {
      return (context2) => args[0](context2) - args[1](context2);
    }
    case Ops.Clamp: {
      return (context2) => {
        const value = args[0](context2);
        const min = args[1](context2);
        if (value < min) {
          return min;
        }
        const max = args[2](context2);
        if (value > max) {
          return max;
        }
        return value;
      };
    }
    case Ops.Mod: {
      return (context2) => args[0](context2) % args[1](context2);
    }
    case Ops.Pow: {
      return (context2) => Math.pow(args[0](context2), args[1](context2));
    }
    case Ops.Abs: {
      return (context2) => Math.abs(args[0](context2));
    }
    case Ops.Floor: {
      return (context2) => Math.floor(args[0](context2));
    }
    case Ops.Ceil: {
      return (context2) => Math.ceil(args[0](context2));
    }
    case Ops.Round: {
      return (context2) => Math.round(args[0](context2));
    }
    case Ops.Sin: {
      return (context2) => Math.sin(args[0](context2));
    }
    case Ops.Cos: {
      return (context2) => Math.cos(args[0](context2));
    }
    case Ops.Atan: {
      if (length === 2) {
        return (context2) => Math.atan2(args[0](context2), args[1](context2));
      }
      return (context2) => Math.atan(args[0](context2));
    }
    case Ops.Sqrt: {
      return (context2) => Math.sqrt(args[0](context2));
    }
    default: {
      throw new Error(`Unsupported numeric operator ${op}`);
    }
  }
}
function compileCaseExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  return (context2) => {
    for (let i = 0; i < length - 1; i += 2) {
      const condition = args[i](context2);
      if (condition) {
        return args[i + 1](context2);
      }
    }
    return args[length - 1](context2);
  };
}
function compileMatchExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  return (context2) => {
    const value = args[0](context2);
    for (let i = 1; i < length - 1; i += 2) {
      if (value === args[i](context2)) {
        return args[i + 1](context2);
      }
    }
    return args[length - 1](context2);
  };
}
function compileInterpolateExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  return (context2) => {
    const base = args[0](context2);
    const value = args[1](context2);
    let previousInput;
    let previousOutput;
    for (let i = 2; i < length; i += 2) {
      const input = args[i](context2);
      let output = args[i + 1](context2);
      const isColor = Array.isArray(output);
      if (isColor) {
        output = withAlpha(output);
      }
      if (input >= value) {
        if (i === 2) {
          return output;
        }
        if (isColor) {
          return interpolateColor(
            base,
            value,
            previousInput,
            previousOutput,
            input,
            output
          );
        }
        return interpolateNumber(
          base,
          value,
          previousInput,
          previousOutput,
          input,
          output
        );
      }
      previousInput = input;
      previousOutput = output;
    }
    return previousOutput;
  };
}
function compileConvertExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (op) {
    case Ops.ToString: {
      return (context2) => {
        const value = args[0](context2);
        if (expression.args[0].type === ColorType) {
          return toString2(value);
        }
        return value.toString();
      };
    }
    default: {
      throw new Error(`Unsupported convert operator ${op}`);
    }
  }
}
function interpolateNumber(base, value, input1, output1, input2, output2) {
  const delta = input2 - input1;
  if (delta === 0) {
    return output1;
  }
  const along = value - input1;
  const factor = base === 1 ? along / delta : (Math.pow(base, along) - 1) / (Math.pow(base, delta) - 1);
  return output1 + factor * (output2 - output1);
}
function interpolateColor(base, value, input1, rgba1, input2, rgba2) {
  const delta = input2 - input1;
  if (delta === 0) {
    return rgba1;
  }
  const lcha1 = rgbaToLcha(rgba1);
  const lcha2 = rgbaToLcha(rgba2);
  let deltaHue = lcha2[2] - lcha1[2];
  if (deltaHue > 180) {
    deltaHue -= 360;
  } else if (deltaHue < -180) {
    deltaHue += 360;
  }
  const lcha = [
    interpolateNumber(base, value, input1, lcha1[0], input2, lcha2[0]),
    interpolateNumber(base, value, input1, lcha1[1], input2, lcha2[1]),
    lcha1[2] + interpolateNumber(base, value, input1, 0, input2, deltaHue),
    interpolateNumber(base, value, input1, rgba1[3], input2, rgba2[3])
  ];
  return lchaToRgba(lcha);
}

// node_modules/ol/ImageState.js
var ImageState_default = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};

// node_modules/ol/Image.js
function listenImage(image, loadHandler, errorHandler) {
  const img = (
    /** @type {HTMLImageElement} */
    image
  );
  let listening = true;
  let decoding = false;
  let loaded = false;
  const listenerKeys = [
    listenOnce(img, EventType_default.LOAD, function() {
      loaded = true;
      if (!decoding) {
        loadHandler();
      }
    })
  ];
  if (img.src && IMAGE_DECODE) {
    decoding = true;
    img.decode().then(function() {
      if (listening) {
        loadHandler();
      }
    }).catch(function(error) {
      if (listening) {
        if (loaded) {
          loadHandler();
        } else {
          errorHandler();
        }
      }
    });
  } else {
    listenerKeys.push(listenOnce(img, EventType_default.ERROR, errorHandler));
  }
  return function unlisten() {
    listening = false;
    listenerKeys.forEach(unlistenByKey);
  };
}
function load(image, src) {
  return new Promise((resolve, reject) => {
    function handleLoad() {
      unlisten();
      resolve(image);
    }
    function handleError() {
      unlisten();
      reject(new Error("Image load error"));
    }
    function unlisten() {
      image.removeEventListener("load", handleLoad);
      image.removeEventListener("error", handleError);
    }
    image.addEventListener("load", handleLoad);
    image.addEventListener("error", handleError);
    if (src) {
      image.src = src;
    }
  });
}
function decodeFallback(image, src) {
  if (src) {
    image.src = src;
  }
  return image.src && IMAGE_DECODE ? new Promise(
    (resolve, reject) => image.decode().then(() => resolve(image)).catch(
      (e) => image.complete && image.width ? resolve(image) : reject(e)
    )
  ) : load(image);
}

// node_modules/ol/style/IconImageCache.js
var IconImageCache = class {
  constructor() {
    this.cache_ = {};
    this.patternCache_ = {};
    this.cacheSize_ = 0;
    this.maxCacheSize_ = 1024;
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.cache_ = {};
    this.patternCache_ = {};
    this.cacheSize_ = 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.cacheSize_ > this.maxCacheSize_;
  }
  /**
   * FIXME empty description for jsdoc
   */
  expire() {
    if (this.canExpireCache()) {
      let i = 0;
      for (const key in this.cache_) {
        const iconImage = this.cache_[key];
        if ((i++ & 3) === 0 && !iconImage.hasListener()) {
          delete this.cache_[key];
          delete this.patternCache_[key];
          --this.cacheSize_;
        }
      }
    }
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */
  get(src, crossOrigin, color) {
    const key = getCacheKey(src, crossOrigin, color);
    return key in this.cache_ ? this.cache_[key] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {CanvasPattern} Icon image.
   */
  getPattern(src, crossOrigin, color) {
    const key = getCacheKey(src, crossOrigin, color);
    return key in this.patternCache_ ? this.patternCache_[key] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @param {import("./IconImage.js").default|null} iconImage Icon image.
   * @param {boolean} [pattern] Also cache a `'repeat'` pattern with this `iconImage`.
   */
  set(src, crossOrigin, color, iconImage, pattern) {
    const key = getCacheKey(src, crossOrigin, color);
    const update = key in this.cache_;
    this.cache_[key] = iconImage;
    if (pattern) {
      if (iconImage.getImageState() === ImageState_default.IDLE) {
        iconImage.load();
      }
      if (iconImage.getImageState() === ImageState_default.LOADING) {
        iconImage.ready().then(() => {
          this.patternCache_[key] = getSharedCanvasContext2D().createPattern(
            iconImage.getImage(1),
            "repeat"
          );
        });
      } else {
        this.patternCache_[key] = getSharedCanvasContext2D().createPattern(
          iconImage.getImage(1),
          "repeat"
        );
      }
    }
    if (!update) {
      ++this.cacheSize_;
    }
  }
  /**
   * Set the cache size of the icon cache. Default is `1024`. Change this value when
   * your map uses more than 1024 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */
  setSize(maxCacheSize) {
    this.maxCacheSize_ = maxCacheSize;
    this.expire();
  }
};
function getCacheKey(src, crossOrigin, color) {
  const colorString = color ? asArray(color) : "null";
  return crossOrigin + ":" + src + ":" + colorString;
}
var shared = new IconImageCache();

// node_modules/ol/style/IconImage.js
var taintedTestContext = null;
var IconImage = class extends Target_default {
  /**
   * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null} image Image.
   * @param {string|undefined} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default|undefined} imageState Image state.
   * @param {import("../color.js").Color|string|null} color Color.
   */
  constructor(image, src, crossOrigin, imageState, color) {
    super();
    this.hitDetectionImage_ = null;
    this.image_ = image;
    this.crossOrigin_ = crossOrigin;
    this.canvas_ = {};
    this.color_ = color;
    this.imageState_ = imageState === void 0 ? ImageState_default.IDLE : imageState;
    this.size_ = image && image.width && image.height ? [image.width, image.height] : null;
    this.src_ = src;
    this.tainted_;
    this.ready_ = null;
  }
  /**
   * @private
   */
  initializeImage_() {
    this.image_ = new Image();
    if (this.crossOrigin_ !== null) {
      this.image_.crossOrigin = this.crossOrigin_;
    }
  }
  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */
  isTainted_() {
    if (this.tainted_ === void 0 && this.imageState_ === ImageState_default.LOADED) {
      if (!taintedTestContext) {
        taintedTestContext = createCanvasContext2D(1, 1, void 0, {
          willReadFrequently: true
        });
      }
      taintedTestContext.drawImage(this.image_, 0, 0);
      try {
        taintedTestContext.getImageData(0, 0, 1, 1);
        this.tainted_ = false;
      } catch {
        taintedTestContext = null;
        this.tainted_ = true;
      }
    }
    return this.tainted_ === true;
  }
  /**
   * @private
   */
  dispatchChangeEvent_() {
    this.dispatchEvent(EventType_default.CHANGE);
  }
  /**
   * @private
   */
  handleImageError_() {
    this.imageState_ = ImageState_default.ERROR;
    this.dispatchChangeEvent_();
  }
  /**
   * @private
   */
  handleImageLoad_() {
    this.imageState_ = ImageState_default.LOADED;
    this.size_ = [this.image_.width, this.image_.height];
    this.dispatchChangeEvent_();
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
   */
  getImage(pixelRatio) {
    if (!this.image_) {
      this.initializeImage_();
    }
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */
  getPixelRatio(pixelRatio) {
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? pixelRatio : 1;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */
  getHitDetectionImage() {
    if (!this.image_) {
      this.initializeImage_();
    }
    if (!this.hitDetectionImage_) {
      if (this.isTainted_()) {
        const width = this.size_[0];
        const height = this.size_[1];
        const context = createCanvasContext2D(width, height);
        context.fillRect(0, 0, width, height);
        this.hitDetectionImage_ = context.canvas;
      } else {
        this.hitDetectionImage_ = this.image_;
      }
    }
    return this.hitDetectionImage_;
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */
  getSize() {
    return this.size_;
  }
  /**
   * @return {string|undefined} Image src.
   */
  getSrc() {
    return this.src_;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.imageState_ !== ImageState_default.IDLE) {
      return;
    }
    if (!this.image_) {
      this.initializeImage_();
    }
    this.imageState_ = ImageState_default.LOADING;
    try {
      if (this.src_ !== void 0) {
        this.image_.src = this.src_;
      }
    } catch {
      this.handleImageError_();
    }
    if (this.image_ instanceof HTMLImageElement) {
      decodeFallback(this.image_, this.src_).then((image) => {
        this.image_ = image;
        this.handleImageLoad_();
      }).catch(this.handleImageError_.bind(this));
    }
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */
  replaceColor_(pixelRatio) {
    if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== ImageState_default.LOADED) {
      return;
    }
    const image = this.image_;
    const ctx = createCanvasContext2D(
      Math.ceil(image.width * pixelRatio),
      Math.ceil(image.height * pixelRatio)
    );
    const canvas = ctx.canvas;
    ctx.scale(pixelRatio, pixelRatio);
    ctx.drawImage(image, 0, 0);
    ctx.globalCompositeOperation = "multiply";
    ctx.fillStyle = asString(this.color_);
    ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
    ctx.globalCompositeOperation = "destination-in";
    ctx.drawImage(image, 0, 0);
    this.canvas_[pixelRatio] = canvas;
  }
  /**
   * @return {Promise<void>} Promise that resolves when the image is loaded.
   */
  ready() {
    if (!this.ready_) {
      this.ready_ = new Promise((resolve) => {
        if (this.imageState_ === ImageState_default.LOADED || this.imageState_ === ImageState_default.ERROR) {
          resolve();
        } else {
          const onChange = () => {
            if (this.imageState_ === ImageState_default.LOADED || this.imageState_ === ImageState_default.ERROR) {
              this.removeEventListener(EventType_default.CHANGE, onChange);
              resolve();
            }
          };
          this.addEventListener(EventType_default.CHANGE, onChange);
        }
      });
    }
    return this.ready_;
  }
};
function get4(image, cacheKey, crossOrigin, imageState, color, pattern) {
  let iconImage = cacheKey === void 0 ? void 0 : shared.get(cacheKey, crossOrigin, color);
  if (!iconImage) {
    iconImage = new IconImage(
      image,
      image && "src" in image ? image.src || void 0 : cacheKey,
      crossOrigin,
      imageState,
      color
    );
    shared.set(cacheKey, crossOrigin, color, iconImage, pattern);
  }
  if (pattern && iconImage && !shared.getPattern(cacheKey, crossOrigin, color)) {
    shared.set(cacheKey, crossOrigin, color, iconImage, pattern);
  }
  return iconImage;
}
var IconImage_default = IconImage;

// node_modules/ol/colorlike.js
function asColorLike(color) {
  if (!color) {
    return null;
  }
  if (Array.isArray(color)) {
    return toString2(color);
  }
  if (typeof color === "object" && "src" in color) {
    return asCanvasPattern(color);
  }
  return color;
}
function asCanvasPattern(pattern) {
  if (!pattern.offset || !pattern.size) {
    return shared.getPattern(pattern.src, "anonymous", pattern.color);
  }
  const cacheKey = pattern.src + ":" + pattern.offset;
  const canvasPattern = shared.getPattern(
    cacheKey,
    void 0,
    pattern.color
  );
  if (canvasPattern) {
    return canvasPattern;
  }
  const iconImage = shared.get(pattern.src, "anonymous", null);
  if (iconImage.getImageState() !== ImageState_default.LOADED) {
    return null;
  }
  const patternCanvasContext = createCanvasContext2D(
    pattern.size[0],
    pattern.size[1]
  );
  patternCanvasContext.drawImage(
    iconImage.getImage(1),
    pattern.offset[0],
    pattern.offset[1],
    pattern.size[0],
    pattern.size[1],
    0,
    0,
    pattern.size[0],
    pattern.size[1]
  );
  get4(
    patternCanvasContext.canvas,
    cacheKey,
    void 0,
    ImageState_default.LOADED,
    pattern.color,
    true
  );
  return shared.getPattern(cacheKey, void 0, pattern.color);
}

// node_modules/ol/render/canvas.js
var defaultFont = "10px sans-serif";
var defaultFillStyle = "#000";
var defaultLineCap = "round";
var defaultLineDash = [];
var defaultLineDashOffset = 0;
var defaultLineJoin = "round";
var defaultMiterLimit = 10;
var defaultStrokeStyle = "#000";
var defaultTextAlign = "center";
var defaultTextBaseline = "middle";
var defaultPadding = [0, 0, 0, 0];
var defaultLineWidth = 1;
var checkedFonts = new Object_default();
var measureContext = null;
var measureFont;
var textHeights = {};
var registerFont = function() {
  const retries = 100;
  const size = "32px ";
  const referenceFonts = ["monospace", "serif"];
  const len = referenceFonts.length;
  const text = "wmytzilWMYTZIL@#/&?$%10\uF013";
  let interval, referenceWidth;
  function isAvailable(fontStyle, fontWeight, fontFamily) {
    let available = true;
    for (let i = 0; i < len; ++i) {
      const referenceFont = referenceFonts[i];
      referenceWidth = measureTextWidth(
        fontStyle + " " + fontWeight + " " + size + referenceFont,
        text
      );
      if (fontFamily != referenceFont) {
        const width = measureTextWidth(
          fontStyle + " " + fontWeight + " " + size + fontFamily + "," + referenceFont,
          text
        );
        available = available && width != referenceWidth;
      }
    }
    if (available) {
      return true;
    }
    return false;
  }
  function check() {
    let done = true;
    const fonts = checkedFonts.getKeys();
    for (let i = 0, ii = fonts.length; i < ii; ++i) {
      const font = fonts[i];
      if (checkedFonts.get(font) < retries) {
        const [style, weight, family] = font.split("\n");
        if (isAvailable(style, weight, family)) {
          clear(textHeights);
          measureContext = null;
          measureFont = void 0;
          checkedFonts.set(font, retries);
        } else {
          checkedFonts.set(font, checkedFonts.get(font) + 1, true);
          done = false;
        }
      }
    }
    if (done) {
      clearInterval(interval);
      interval = void 0;
    }
  }
  return function(fontSpec) {
    const font = getFontParameters(fontSpec);
    if (!font) {
      return;
    }
    const families = font.families;
    for (let i = 0, ii = families.length; i < ii; ++i) {
      const family = families[i];
      const key = font.style + "\n" + font.weight + "\n" + family;
      if (checkedFonts.get(key) === void 0) {
        checkedFonts.set(key, retries, true);
        if (!isAvailable(font.style, font.weight, family)) {
          checkedFonts.set(key, 0, true);
          if (interval === void 0) {
            interval = setInterval(check, 32);
          }
        }
      }
    }
  };
}();
var measureTextHeight = /* @__PURE__ */ function() {
  let measureElement;
  return function(fontSpec) {
    let height = textHeights[fontSpec];
    if (height == void 0) {
      if (WORKER_OFFSCREEN_CANVAS) {
        const font = getFontParameters(fontSpec);
        const metrics = measureText(fontSpec, "\u017Dg");
        const lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
        height = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
      } else {
        if (!measureElement) {
          measureElement = document.createElement("div");
          measureElement.innerHTML = "M";
          measureElement.style.minHeight = "0";
          measureElement.style.maxHeight = "none";
          measureElement.style.height = "auto";
          measureElement.style.padding = "0";
          measureElement.style.border = "none";
          measureElement.style.position = "absolute";
          measureElement.style.display = "block";
          measureElement.style.left = "-99999px";
        }
        measureElement.style.font = fontSpec;
        document.body.appendChild(measureElement);
        height = measureElement.offsetHeight;
        document.body.removeChild(measureElement);
      }
      textHeights[fontSpec] = height;
    }
    return height;
  };
}();
function measureText(font, text) {
  if (!measureContext) {
    measureContext = createCanvasContext2D(1, 1);
  }
  if (font != measureFont) {
    measureContext.font = font;
    measureFont = measureContext.font;
  }
  return measureContext.measureText(text);
}
function measureTextWidth(font, text) {
  return measureText(font, text).width;
}
function measureAndCacheTextWidth(font, text, cache3) {
  if (text in cache3) {
    return cache3[text];
  }
  const width = text.split("\n").reduce((prev, curr) => Math.max(prev, measureTextWidth(font, curr)), 0);
  cache3[text] = width;
  return width;
}
function getTextDimensions(baseStyle, chunks) {
  const widths = [];
  const heights = [];
  const lineWidths = [];
  let width = 0;
  let lineWidth = 0;
  let height = 0;
  let lineHeight = 0;
  for (let i = 0, ii = chunks.length; i <= ii; i += 2) {
    const text = chunks[i];
    if (text === "\n" || i === ii) {
      width = Math.max(width, lineWidth);
      lineWidths.push(lineWidth);
      lineWidth = 0;
      height += lineHeight;
      lineHeight = 0;
      continue;
    }
    const font = chunks[i + 1] || baseStyle.font;
    const currentWidth = measureTextWidth(font, text);
    widths.push(currentWidth);
    lineWidth += currentWidth;
    const currentHeight = measureTextHeight(font);
    heights.push(currentHeight);
    lineHeight = Math.max(lineHeight, currentHeight);
  }
  return { width, height, widths, heights, lineWidths };
}
function drawImageOrLabel(context, transform2, opacity, labelOrImage, originX, originY, w, h, x, y, scale4) {
  context.save();
  if (opacity !== 1) {
    if (context.globalAlpha === void 0) {
      context.globalAlpha = (context2) => context2.globalAlpha *= opacity;
    } else {
      context.globalAlpha *= opacity;
    }
  }
  if (transform2) {
    context.transform.apply(context, transform2);
  }
  if (
    /** @type {*} */
    labelOrImage.contextInstructions
  ) {
    context.translate(x, y);
    context.scale(scale4[0], scale4[1]);
    executeLabelInstructions(
      /** @type {Label} */
      labelOrImage,
      context
    );
  } else if (scale4[0] < 0 || scale4[1] < 0) {
    context.translate(x, y);
    context.scale(scale4[0], scale4[1]);
    context.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
      labelOrImage,
      originX,
      originY,
      w,
      h,
      0,
      0,
      w,
      h
    );
  } else {
    context.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
      labelOrImage,
      originX,
      originY,
      w,
      h,
      x,
      y,
      w * scale4[0],
      h * scale4[1]
    );
  }
  context.restore();
}
function executeLabelInstructions(label, context) {
  const contextInstructions = label.contextInstructions;
  for (let i = 0, ii = contextInstructions.length; i < ii; i += 2) {
    if (Array.isArray(contextInstructions[i + 1])) {
      context[contextInstructions[i]].apply(
        context,
        contextInstructions[i + 1]
      );
    } else {
      context[contextInstructions[i]] = contextInstructions[i + 1];
    }
  }
}

// node_modules/ol/style/Image.js
var ImageStyle = class _ImageStyle {
  /**
   * @param {Options} options Options.
   */
  constructor(options) {
    this.opacity_ = options.opacity;
    this.rotateWithView_ = options.rotateWithView;
    this.rotation_ = options.rotation;
    this.scale_ = options.scale;
    this.scaleArray_ = toSize(options.scale);
    this.displacement_ = options.displacement;
    this.declutterMode_ = options.declutterMode;
  }
  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */
  clone() {
    const scale4 = this.getScale();
    return new _ImageStyle({
      opacity: this.getOpacity(),
      scale: Array.isArray(scale4) ? scale4.slice() : scale4,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */
  getOpacity() {
    return this.opacity_;
  }
  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */
  getDisplacement() {
    return this.displacement_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */
  getAnchor() {
    return abstract();
  }
  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getImage(pixelRatio) {
    return abstract();
  }
  /**
   * @abstract
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getHitDetectionImage() {
    return abstract();
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(pixelRatio) {
    return 1;
  }
  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return abstract();
  }
  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return abstract();
  }
  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */
  getOrigin() {
    return abstract();
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */
  getSize() {
    return abstract();
  }
  /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */
  setDisplacement(displacement) {
    this.displacement_ = displacement;
  }
  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */
  setOpacity(opacity) {
    this.opacity_ = opacity;
  }
  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  }
  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */
  setRotation(rotation) {
    this.rotation_ = rotation;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(scale4) {
    this.scale_ = scale4;
    this.scaleArray_ = toSize(scale4);
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(listener) {
    abstract();
  }
  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    abstract();
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(listener) {
    abstract();
  }
  /**
   * @return {Promise<void>} `false` or Promise that resolves when the style is ready to use.
   */
  ready() {
    return Promise.resolve();
  }
};
var Image_default = ImageStyle;

// node_modules/ol/style/RegularShape.js
var RegularShape = class _RegularShape extends Image_default {
  /**
   * @param {Options} options Options.
   */
  constructor(options) {
    super({
      opacity: 1,
      rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
      rotation: options.rotation !== void 0 ? options.rotation : 0,
      scale: options.scale !== void 0 ? options.scale : 1,
      displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
      declutterMode: options.declutterMode
    });
    this.hitDetectionCanvas_ = null;
    this.fill_ = options.fill !== void 0 ? options.fill : null;
    this.origin_ = [0, 0];
    this.points_ = options.points;
    this.radius = options.radius;
    this.radius2_ = options.radius2;
    this.angle_ = options.angle !== void 0 ? options.angle : 0;
    this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
    this.size_;
    this.renderOptions_;
    this.imageState_ = this.fill_ && this.fill_.loading() ? ImageState_default.LOADING : ImageState_default.LOADED;
    if (this.imageState_ === ImageState_default.LOADING) {
      this.ready().then(() => this.imageState_ = ImageState_default.LOADED);
    }
    this.render();
  }
  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   * @override
   */
  clone() {
    const scale4 = this.getScale();
    const style = new _RegularShape({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(scale4) ? scale4.slice() : scale4,
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    style.setOpacity(this.getOpacity());
    return style;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   * @override
   */
  getAnchor() {
    const size = this.size_;
    const displacement = this.getDisplacement();
    const scale4 = this.getScaleArray();
    return [
      size[0] / 2 - displacement[0] / scale4[0],
      size[1] / 2 + displacement[1] / scale4[1]
    ];
  }
  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  getAngle() {
    return this.angle_;
  }
  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(fill) {
    this.fill_ = fill;
    this.render();
  }
  /**
   * @return {HTMLCanvasElement} Image element.
   * @override
   */
  getHitDetectionImage() {
    if (!this.hitDetectionCanvas_) {
      this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
        this.renderOptions_
      );
    }
    return this.hitDetectionCanvas_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   * @override
   */
  getImage(pixelRatio) {
    const fillKey = this.fill_?.getKey();
    const cacheKey = `${pixelRatio},${this.angle_},${this.radius},${this.radius2_},${this.points_},${fillKey}` + Object.values(this.renderOptions_).join(",");
    let image = (
      /** @type {HTMLCanvasElement} */
      shared.get(cacheKey, null, null)?.getImage(1)
    );
    if (!image) {
      const renderOptions = this.renderOptions_;
      const size = Math.ceil(renderOptions.size * pixelRatio);
      const context = createCanvasContext2D(size, size);
      this.draw_(renderOptions, context, pixelRatio);
      image = context.canvas;
      shared.set(
        cacheKey,
        null,
        null,
        new IconImage_default(image, void 0, null, ImageState_default.LOADED, null)
      );
    }
    return image;
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   * @override
   */
  getPixelRatio(pixelRatio) {
    return pixelRatio;
  }
  /**
   * @return {import("../size.js").Size} Image size.
   * @override
   */
  getImageSize() {
    return this.size_;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   * @override
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   * @override
   */
  getOrigin() {
    return this.origin_;
  }
  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  getPoints() {
    return this.points_;
  }
  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return this.radius;
  }
  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  getRadius2() {
    return this.radius2_;
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   * @override
   */
  getSize() {
    return this.size_;
  }
  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(stroke) {
    this.stroke_ = stroke;
    this.render();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  listenImageChange(listener) {
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  unlistenImageChange(listener) {
  }
  /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */
  calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {
    if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== "bevel" && lineJoin !== "miter") {
      return strokeWidth;
    }
    let r1 = this.radius;
    let r2 = this.radius2_ === void 0 ? r1 : this.radius2_;
    if (r1 < r2) {
      const tmp = r1;
      r1 = r2;
      r2 = tmp;
    }
    const points = this.radius2_ === void 0 ? this.points_ : this.points_ * 2;
    const alpha = 2 * Math.PI / points;
    const a = r2 * Math.sin(alpha);
    const b = Math.sqrt(r2 * r2 - a * a);
    const d = r1 - b;
    const e = Math.sqrt(a * a + d * d);
    const miterRatio = e / a;
    if (lineJoin === "miter" && miterRatio <= miterLimit) {
      return miterRatio * strokeWidth;
    }
    const k = strokeWidth / 2 / miterRatio;
    const l = strokeWidth / 2 * (d / e);
    const maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
    const bevelAdd = maxr - r1;
    if (this.radius2_ === void 0 || lineJoin === "bevel") {
      return bevelAdd * 2;
    }
    const aa = r1 * Math.sin(alpha);
    const bb = Math.sqrt(r1 * r1 - aa * aa);
    const dd = r2 - bb;
    const ee = Math.sqrt(aa * aa + dd * dd);
    const innerMiterRatio = ee / aa;
    if (innerMiterRatio <= miterLimit) {
      const innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;
      return 2 * Math.max(bevelAdd, innerLength);
    }
    return bevelAdd * 2;
  }
  /**
   * @return {RenderOptions}  The render options
   * @protected
   */
  createRenderOptions() {
    let lineCap = defaultLineCap;
    let lineJoin = defaultLineJoin;
    let miterLimit = 0;
    let lineDash = null;
    let lineDashOffset = 0;
    let strokeStyle;
    let strokeWidth = 0;
    if (this.stroke_) {
      strokeStyle = asColorLike(this.stroke_.getColor() ?? defaultStrokeStyle);
      strokeWidth = this.stroke_.getWidth() ?? defaultLineWidth;
      lineDash = this.stroke_.getLineDash();
      lineDashOffset = this.stroke_.getLineDashOffset() ?? 0;
      lineJoin = this.stroke_.getLineJoin() ?? defaultLineJoin;
      lineCap = this.stroke_.getLineCap() ?? defaultLineCap;
      miterLimit = this.stroke_.getMiterLimit() ?? defaultMiterLimit;
    }
    const add4 = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
    const maxRadius = Math.max(this.radius, this.radius2_ || 0);
    const size = Math.ceil(2 * maxRadius + add4);
    return {
      strokeStyle,
      strokeWidth,
      size,
      lineCap,
      lineDash,
      lineDashOffset,
      lineJoin,
      miterLimit
    };
  }
  /**
   * @protected
   */
  render() {
    this.renderOptions_ = this.createRenderOptions();
    const size = this.renderOptions_.size;
    this.hitDetectionCanvas_ = null;
    this.size_ = [size, size];
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */
  draw_(renderOptions, context, pixelRatio) {
    context.scale(pixelRatio, pixelRatio);
    context.translate(renderOptions.size / 2, renderOptions.size / 2);
    this.createPath_(context);
    if (this.fill_) {
      let color = this.fill_.getColor();
      if (color === null) {
        color = defaultFillStyle;
      }
      context.fillStyle = asColorLike(color);
      context.fill();
    }
    if (renderOptions.strokeStyle) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.lineCap = renderOptions.lineCap;
      context.lineJoin = renderOptions.lineJoin;
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @return {HTMLCanvasElement} Canvas containing the icon
   */
  createHitDetectionCanvas_(renderOptions) {
    let context;
    if (this.fill_) {
      let color = this.fill_.getColor();
      let opacity = 0;
      if (typeof color === "string") {
        color = asArray(color);
      }
      if (color === null) {
        opacity = 1;
      } else if (Array.isArray(color)) {
        opacity = color.length === 4 ? color[3] : 1;
      }
      if (opacity === 0) {
        context = createCanvasContext2D(renderOptions.size, renderOptions.size);
        this.drawHitDetectionCanvas_(renderOptions, context);
      }
    }
    return context ? context.canvas : this.getImage(1);
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context The context to draw in.
   */
  createPath_(context) {
    let points = this.points_;
    const radius = this.radius;
    if (points === Infinity) {
      context.arc(0, 0, radius, 0, 2 * Math.PI);
    } else {
      const radius2 = this.radius2_ === void 0 ? radius : this.radius2_;
      if (this.radius2_ !== void 0) {
        points *= 2;
      }
      const startAngle = this.angle_ - Math.PI / 2;
      const step = 2 * Math.PI / points;
      for (let i = 0; i < points; i++) {
        const angle0 = startAngle + i * step;
        const radiusC = i % 2 === 0 ? radius : radius2;
        context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
      }
      context.closePath();
    }
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   */
  drawHitDetectionCanvas_(renderOptions, context) {
    context.translate(renderOptions.size / 2, renderOptions.size / 2);
    this.createPath_(context);
    context.fillStyle = defaultFillStyle;
    context.fill();
    if (renderOptions.strokeStyle) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.lineJoin = renderOptions.lineJoin;
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
  }
  /**
   * @override
   */
  ready() {
    return this.fill_ ? this.fill_.ready() : Promise.resolve();
  }
};
var RegularShape_default = RegularShape;

// node_modules/ol/style/Circle.js
var CircleStyle = class _CircleStyle extends RegularShape_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : { radius: 5 };
    super({
      points: Infinity,
      fill: options.fill,
      radius: options.radius,
      stroke: options.stroke,
      scale: options.scale !== void 0 ? options.scale : 1,
      rotation: options.rotation !== void 0 ? options.rotation : 0,
      rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
      displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
      declutterMode: options.declutterMode
    });
  }
  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   * @override
   */
  clone() {
    const scale4 = this.getScale();
    const style = new _CircleStyle({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      radius: this.getRadius(),
      scale: Array.isArray(scale4) ? scale4.slice() : scale4,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    style.setOpacity(this.getOpacity());
    return style;
  }
  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */
  setRadius(radius) {
    this.radius = radius;
    this.render();
  }
};
var Circle_default = CircleStyle;

// node_modules/ol/style/Fill.js
var Fill = class _Fill {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};
    this.patternImage_ = null;
    this.color_ = null;
    if (options.color !== void 0) {
      this.setColor(options.color);
    }
  }
  /**
   * Clones the style. The color is not cloned if it is a {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */
  clone() {
    const color = this.getColor();
    return new _Fill({
      color: Array.isArray(color) ? color.slice() : color || void 0
    });
  }
  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} color Color.
   * @api
   */
  setColor(color) {
    if (color !== null && typeof color === "object" && "src" in color) {
      const patternImage = get4(
        null,
        color.src,
        "anonymous",
        void 0,
        color.offset ? null : color.color ? color.color : null,
        !(color.offset && color.size)
      );
      patternImage.ready().then(() => {
        this.patternImage_ = null;
      });
      if (patternImage.getImageState() === ImageState_default.IDLE) {
        patternImage.load();
      }
      if (patternImage.getImageState() === ImageState_default.LOADING) {
        this.patternImage_ = patternImage;
      }
    }
    this.color_ = color;
  }
  /**
   * @return {string} Key of the fill for cache lookup.
   */
  getKey() {
    const fill = this.getColor();
    if (!fill) {
      return "";
    }
    return fill instanceof CanvasPattern || fill instanceof CanvasGradient ? getUid(fill) : typeof fill === "object" && "src" in fill ? fill.src + ":" + fill.offset : asArray(fill).toString();
  }
  /**
   * @return {boolean} The fill style is loading an image pattern.
   */
  loading() {
    return !!this.patternImage_;
  }
  /**
   * @return {Promise<void>} `false` or a promise that resolves when the style is ready to use.
   */
  ready() {
    return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
  }
};
var Fill_default = Fill;

// node_modules/ol/style/Icon.js
function calculateScale(width, height, wantedWidth, wantedHeight) {
  if (wantedWidth !== void 0 && wantedHeight !== void 0) {
    return [wantedWidth / width, wantedHeight / height];
  }
  if (wantedWidth !== void 0) {
    return wantedWidth / width;
  }
  if (wantedHeight !== void 0) {
    return wantedHeight / height;
  }
  return 1;
}
var Icon = class _Icon extends Image_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};
    const opacity = options.opacity !== void 0 ? options.opacity : 1;
    const rotation = options.rotation !== void 0 ? options.rotation : 0;
    const scale4 = options.scale !== void 0 ? options.scale : 1;
    const rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
    super({
      opacity,
      rotation,
      scale: scale4,
      displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
      rotateWithView,
      declutterMode: options.declutterMode
    });
    this.anchor_ = options.anchor !== void 0 ? options.anchor : [0.5, 0.5];
    this.normalizedAnchor_ = null;
    this.anchorOrigin_ = options.anchorOrigin !== void 0 ? options.anchorOrigin : "top-left";
    this.anchorXUnits_ = options.anchorXUnits !== void 0 ? options.anchorXUnits : "fraction";
    this.anchorYUnits_ = options.anchorYUnits !== void 0 ? options.anchorYUnits : "fraction";
    this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    const image = options.img !== void 0 ? options.img : null;
    let cacheKey = options.src;
    assert(
      !(cacheKey !== void 0 && image),
      "`image` and `src` cannot be provided at the same time"
    );
    if ((cacheKey === void 0 || cacheKey.length === 0) && image) {
      cacheKey = /** @type {HTMLImageElement} */
      image.src || getUid(image);
    }
    assert(
      cacheKey !== void 0 && cacheKey.length > 0,
      "A defined and non-empty `src` or `image` must be provided"
    );
    assert(
      !((options.width !== void 0 || options.height !== void 0) && options.scale !== void 0),
      "`width` or `height` cannot be provided together with `scale`"
    );
    let imageState;
    if (options.src !== void 0) {
      imageState = ImageState_default.IDLE;
    } else if (image !== void 0) {
      if ("complete" in image) {
        if (image.complete) {
          imageState = image.src ? ImageState_default.LOADED : ImageState_default.IDLE;
        } else {
          imageState = ImageState_default.LOADING;
        }
      } else {
        imageState = ImageState_default.LOADED;
      }
    }
    this.color_ = options.color !== void 0 ? asArray(options.color) : null;
    this.iconImage_ = get4(
      image,
      /** @type {string} */
      cacheKey,
      this.crossOrigin_,
      imageState,
      this.color_
    );
    this.offset_ = options.offset !== void 0 ? options.offset : [0, 0];
    this.offsetOrigin_ = options.offsetOrigin !== void 0 ? options.offsetOrigin : "top-left";
    this.origin_ = null;
    this.size_ = options.size !== void 0 ? options.size : null;
    this.initialOptions_;
    if (options.width !== void 0 || options.height !== void 0) {
      let width, height;
      if (options.size) {
        [width, height] = options.size;
      } else {
        const image2 = this.getImage(1);
        if (image2.width && image2.height) {
          width = image2.width;
          height = image2.height;
        } else if (image2 instanceof HTMLImageElement) {
          this.initialOptions_ = options;
          const onload = () => {
            this.unlistenImageChange(onload);
            if (!this.initialOptions_) {
              return;
            }
            const imageSize = this.iconImage_.getSize();
            this.setScale(
              calculateScale(
                imageSize[0],
                imageSize[1],
                options.width,
                options.height
              )
            );
          };
          this.listenImageChange(onload);
          return;
        }
      }
      if (width !== void 0) {
        this.setScale(
          calculateScale(width, height, options.width, options.height)
        );
      }
    }
  }
  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   * @override
   */
  clone() {
    let scale4, width, height;
    if (this.initialOptions_) {
      width = this.initialOptions_.width;
      height = this.initialOptions_.height;
    } else {
      scale4 = this.getScale();
      scale4 = Array.isArray(scale4) ? scale4.slice() : scale4;
    }
    return new _Icon({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
      crossOrigin: this.crossOrigin_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale: scale4,
      width,
      height,
      size: this.size_ !== null ? this.size_.slice() : void 0,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   * @override
   */
  getAnchor() {
    let anchor = this.normalizedAnchor_;
    if (!anchor) {
      anchor = this.anchor_;
      const size = this.getSize();
      if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
        if (!size) {
          return null;
        }
        anchor = this.anchor_.slice();
        if (this.anchorXUnits_ == "fraction") {
          anchor[0] *= size[0];
        }
        if (this.anchorYUnits_ == "fraction") {
          anchor[1] *= size[1];
        }
      }
      if (this.anchorOrigin_ != "top-left") {
        if (!size) {
          return null;
        }
        if (anchor === this.anchor_) {
          anchor = this.anchor_.slice();
        }
        if (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") {
          anchor[0] = -anchor[0] + size[0];
        }
        if (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") {
          anchor[1] = -anchor[1] + size[1];
        }
      }
      this.normalizedAnchor_ = anchor;
    }
    const displacement = this.getDisplacement();
    const scale4 = this.getScaleArray();
    return [
      anchor[0] - displacement[0] / scale4[0],
      anchor[1] + displacement[1] / scale4[1]
    ];
  }
  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */
  setAnchor(anchor) {
    this.anchor_ = anchor;
    this.normalizedAnchor_ = null;
  }
  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
   * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
   * @api
   * @override
   */
  getImage(pixelRatio) {
    return this.iconImage_.getImage(pixelRatio);
  }
  /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   * @override
   */
  getPixelRatio(pixelRatio) {
    return this.iconImage_.getPixelRatio(pixelRatio);
  }
  /**
   * @return {import("../size.js").Size} Image size.
   * @override
   */
  getImageSize() {
    return this.iconImage_.getSize();
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   * @override
   */
  getImageState() {
    return this.iconImage_.getImageState();
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   * @override
   */
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   * @override
   */
  getOrigin() {
    if (this.origin_) {
      return this.origin_;
    }
    let offset = this.offset_;
    if (this.offsetOrigin_ != "top-left") {
      const size = this.getSize();
      const iconImageSize = this.iconImage_.getSize();
      if (!size || !iconImageSize) {
        return null;
      }
      offset = offset.slice();
      if (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") {
        offset[0] = iconImageSize[0] - size[0] - offset[0];
      }
      if (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") {
        offset[1] = iconImageSize[1] - size[1] - offset[1];
      }
    }
    this.origin_ = offset;
    return this.origin_;
  }
  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */
  getSrc() {
    return this.iconImage_.getSrc();
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   * @override
   */
  getSize() {
    return !this.size_ ? this.iconImage_.getSize() : this.size_;
  }
  /**
   * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon width (in pixels).
   * @api
   */
  getWidth() {
    const scale4 = this.getScaleArray();
    if (this.size_) {
      return this.size_[0] * scale4[0];
    }
    if (this.iconImage_.getImageState() == ImageState_default.LOADED) {
      return this.iconImage_.getSize()[0] * scale4[0];
    }
    return void 0;
  }
  /**
   * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon height (in pixels).
   * @api
   */
  getHeight() {
    const scale4 = this.getScaleArray();
    if (this.size_) {
      return this.size_[1] * scale4[1];
    }
    if (this.iconImage_.getImageState() == ImageState_default.LOADED) {
      return this.iconImage_.getSize()[1] * scale4[1];
    }
    return void 0;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   * @override
   */
  setScale(scale4) {
    delete this.initialOptions_;
    super.setScale(scale4);
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  listenImageChange(listener) {
    this.iconImage_.addEventListener(EventType_default.CHANGE, listener);
  }
  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   * @override
   */
  load() {
    this.iconImage_.load();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  unlistenImageChange(listener) {
    this.iconImage_.removeEventListener(EventType_default.CHANGE, listener);
  }
  /**
   * @override
   */
  ready() {
    return this.iconImage_.ready();
  }
};
var Icon_default = Icon;

// node_modules/ol/style/Stroke.js
var Stroke = class _Stroke {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};
    this.color_ = options.color !== void 0 ? options.color : null;
    this.lineCap_ = options.lineCap;
    this.lineDash_ = options.lineDash !== void 0 ? options.lineDash : null;
    this.lineDashOffset_ = options.lineDashOffset;
    this.lineJoin_ = options.lineJoin;
    this.miterLimit_ = options.miterLimit;
    this.width_ = options.width;
  }
  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */
  clone() {
    const color = this.getColor();
    return new _Stroke({
      color: Array.isArray(color) ? color.slice() : color || void 0,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  }
  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */
  getLineCap() {
    return this.lineCap_;
  }
  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */
  getLineDash() {
    return this.lineDash_;
  }
  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */
  getLineDashOffset() {
    return this.lineDashOffset_;
  }
  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */
  getLineJoin() {
    return this.lineJoin_;
  }
  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */
  getMiterLimit() {
    return this.miterLimit_;
  }
  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */
  getWidth() {
    return this.width_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */
  setColor(color) {
    this.color_ = color;
  }
  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */
  setLineCap(lineCap) {
    this.lineCap_ = lineCap;
  }
  /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */
  setLineDash(lineDash) {
    this.lineDash_ = lineDash;
  }
  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */
  setLineDashOffset(lineDashOffset) {
    this.lineDashOffset_ = lineDashOffset;
  }
  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */
  setLineJoin(lineJoin) {
    this.lineJoin_ = lineJoin;
  }
  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */
  setMiterLimit(miterLimit) {
    this.miterLimit_ = miterLimit;
  }
  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */
  setWidth(width) {
    this.width_ = width;
  }
};
var Stroke_default = Stroke;

// node_modules/ol/style/Style.js
var Style = class _Style {
  /**
   * @param {Options} [options] Style options.
   */
  constructor(options) {
    options = options || {};
    this.geometry_ = null;
    this.geometryFunction_ = defaultGeometryFunction;
    if (options.geometry !== void 0) {
      this.setGeometry(options.geometry);
    }
    this.fill_ = options.fill !== void 0 ? options.fill : null;
    this.image_ = options.image !== void 0 ? options.image : null;
    this.renderer_ = options.renderer !== void 0 ? options.renderer : null;
    this.hitDetectionRenderer_ = options.hitDetectionRenderer !== void 0 ? options.hitDetectionRenderer : null;
    this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
    this.text_ = options.text !== void 0 ? options.text : null;
    this.zIndex_ = options.zIndex;
  }
  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */
  clone() {
    let geometry = this.getGeometry();
    if (geometry && typeof geometry === "object") {
      geometry = /** @type {import("../geom/Geometry.js").default} */
      geometry.clone();
    }
    return new _Style({
      geometry: geometry ?? void 0,
      fill: this.getFill() ? this.getFill().clone() : void 0,
      image: this.getImage() ? this.getImage().clone() : void 0,
      renderer: this.getRenderer() ?? void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      text: this.getText() ? this.getText().clone() : void 0,
      zIndex: this.getZIndex()
    });
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setRenderer(renderer) {
    this.renderer_ = renderer;
  }
  /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setHitDetectionRenderer(renderer) {
    this.hitDetectionRenderer_ = renderer;
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }
  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */
  getGeometry() {
    return this.geometry_;
  }
  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */
  getGeometryFunction() {
    return this.geometryFunction_;
  }
  /**
   * Get the fill style.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(fill) {
    this.fill_ = fill;
  }
  /**
   * Get the image style.
   * @return {import("./Image.js").default|null} Image style.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */
  setImage(image) {
    this.image_ = image;
  }
  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(stroke) {
    this.stroke_ = stroke;
  }
  /**
   * Get the text style.
   * @return {import("./Text.js").default|null} Text style.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */
  setText(text) {
    this.text_ = text;
  }
  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */
  getZIndex() {
    return this.zIndex_;
  }
  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction|null} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */
  setGeometry(geometry) {
    if (typeof geometry === "function") {
      this.geometryFunction_ = geometry;
    } else if (typeof geometry === "string") {
      this.geometryFunction_ = function(feature) {
        return (
          /** @type {import("../geom/Geometry.js").default} */
          feature.get(geometry)
        );
      };
    } else if (!geometry) {
      this.geometryFunction_ = defaultGeometryFunction;
    } else if (geometry !== void 0) {
      this.geometryFunction_ = function() {
        return (
          /** @type {import("../geom/Geometry.js").default} */
          geometry
        );
      };
    }
    this.geometry_ = geometry;
  }
  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */
  setZIndex(zIndex) {
    this.zIndex_ = zIndex;
  }
};
function toFunction(obj) {
  let styleFunction;
  if (typeof obj === "function") {
    styleFunction = obj;
  } else {
    let styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      assert(
        typeof /** @type {?} */
        obj.getZIndex === "function",
        "Expected an `Style` or an array of `Style`"
      );
      const style = (
        /** @type {Style} */
        obj
      );
      styles = [style];
    }
    styleFunction = function() {
      return styles;
    };
  }
  return styleFunction;
}
var defaultStyles = null;
function createDefaultStyle(feature, resolution) {
  if (!defaultStyles) {
    const fill = new Fill_default({
      color: "rgba(255,255,255,0.4)"
    });
    const stroke = new Stroke_default({
      color: "#3399CC",
      width: 1.25
    });
    defaultStyles = [
      new Style({
        image: new Circle_default({
          fill,
          stroke,
          radius: 5
        }),
        fill,
        stroke
      })
    ];
  }
  return defaultStyles;
}
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}
var Style_default = Style;

// node_modules/ol/style/Text.js
var DEFAULT_FILL_COLOR = "#333";
var Text = class _Text {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};
    this.font_ = options.font;
    this.rotation_ = options.rotation;
    this.rotateWithView_ = options.rotateWithView;
    this.keepUpright_ = options.keepUpright;
    this.scale_ = options.scale;
    this.scaleArray_ = toSize(options.scale !== void 0 ? options.scale : 1);
    this.text_ = options.text;
    this.textAlign_ = options.textAlign;
    this.justify_ = options.justify;
    this.repeat_ = options.repeat;
    this.textBaseline_ = options.textBaseline;
    this.fill_ = options.fill !== void 0 ? options.fill : new Fill_default({ color: DEFAULT_FILL_COLOR });
    this.maxAngle_ = options.maxAngle !== void 0 ? options.maxAngle : Math.PI / 4;
    this.placement_ = options.placement !== void 0 ? options.placement : "point";
    this.overflow_ = !!options.overflow;
    this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
    this.offsetX_ = options.offsetX !== void 0 ? options.offsetX : 0;
    this.offsetY_ = options.offsetY !== void 0 ? options.offsetY : 0;
    this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
    this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
    this.padding_ = options.padding === void 0 ? null : options.padding;
    this.declutterMode_ = options.declutterMode;
  }
  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */
  clone() {
    const scale4 = this.getScale();
    return new _Text({
      font: this.getFont(),
      placement: this.getPlacement(),
      repeat: this.getRepeat(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      keepUpright: this.getKeepUpright(),
      scale: Array.isArray(scale4) ? scale4.slice() : scale4,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
      padding: this.getPadding() || void 0,
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */
  getOverflow() {
    return this.overflow_;
  }
  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */
  getFont() {
    return this.font_;
  }
  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */
  getMaxAngle() {
    return this.maxAngle_;
  }
  /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */
  getPlacement() {
    return this.placement_;
  }
  /**
   * Get the repeat interval of the text.
   * @return {number|undefined} Repeat interval in pixels.
   * @api
   */
  getRepeat() {
    return this.repeat_;
  }
  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */
  getOffsetX() {
    return this.offsetX_;
  }
  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */
  getOffsetY() {
    return this.offsetY_;
  }
  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Determine whether the text can be rendered upside down.
   * @return {boolean|undefined} Keep text upright.
   * @api
   */
  getKeepUpright() {
    return this.keepUpright_;
  }
  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */
  getTextAlign() {
    return this.textAlign_;
  }
  /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */
  getJustify() {
    return this.justify_;
  }
  /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */
  getTextBaseline() {
    return this.textBaseline_;
  }
  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getBackgroundFill() {
    return this.backgroundFill_;
  }
  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }
  /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */
  getPadding() {
    return this.padding_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */
  setOverflow(overflow) {
    this.overflow_ = overflow;
  }
  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */
  setFont(font) {
    this.font_ = font;
  }
  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */
  setMaxAngle(maxAngle) {
    this.maxAngle_ = maxAngle;
  }
  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */
  setOffsetX(offsetX) {
    this.offsetX_ = offsetX;
  }
  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */
  setOffsetY(offsetY) {
    this.offsetY_ = offsetY;
  }
  /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */
  setPlacement(placement) {
    this.placement_ = placement;
  }
  /**
   * Set the repeat interval of the text.
   * @param {number|undefined} [repeat] Repeat interval in pixels.
   * @api
   */
  setRepeat(repeat) {
    this.repeat_ = repeat;
  }
  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  }
  /**
   * Set whether the text can be rendered upside down.
   *
   * @param {boolean} keepUpright Keep text upright.
   * @api
   */
  setKeepUpright(keepUpright) {
    this.keepUpright_ = keepUpright;
  }
  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(fill) {
    this.fill_ = fill;
  }
  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */
  setRotation(rotation) {
    this.rotation_ = rotation;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */
  setScale(scale4) {
    this.scale_ = scale4;
    this.scaleArray_ = toSize(scale4 !== void 0 ? scale4 : 1);
  }
  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(stroke) {
    this.stroke_ = stroke;
  }
  /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */
  setText(text) {
    this.text_ = text;
  }
  /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */
  setTextAlign(textAlign) {
    this.textAlign_ = textAlign;
  }
  /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */
  setJustify(justify) {
    this.justify_ = justify;
  }
  /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */
  setTextBaseline(textBaseline) {
    this.textBaseline_ = textBaseline;
  }
  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setBackgroundFill(fill) {
    this.backgroundFill_ = fill;
  }
  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setBackgroundStroke(stroke) {
    this.backgroundStroke_ = stroke;
  }
  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */
  setPadding(padding) {
    this.padding_ = padding;
  }
};
var Text_default = Text;

// node_modules/ol/render/canvas/style.js
function always2(context) {
  return true;
}
function rulesToStyleFunction(rules) {
  const parsingContext = newParsingContext();
  const evaluator = buildRuleSet(rules, parsingContext);
  const evaluationContext = newEvaluationContext();
  return function(feature, resolution) {
    evaluationContext.properties = feature.getPropertiesInternal();
    evaluationContext.resolution = resolution;
    if (parsingContext.featureId) {
      const id = feature.getId();
      if (id !== void 0) {
        evaluationContext.featureId = id;
      } else {
        evaluationContext.featureId = null;
      }
    }
    if (parsingContext.geometryType) {
      evaluationContext.geometryType = computeGeometryType(
        feature.getGeometry()
      );
    }
    return evaluator(evaluationContext);
  };
}
function flatStylesToStyleFunction(flatStyles) {
  const parsingContext = newParsingContext();
  const length = flatStyles.length;
  const evaluators = new Array(length);
  for (let i = 0; i < length; ++i) {
    evaluators[i] = buildStyle(flatStyles[i], parsingContext);
  }
  const evaluationContext = newEvaluationContext();
  const styles = new Array(length);
  return function(feature, resolution) {
    evaluationContext.properties = feature.getPropertiesInternal();
    evaluationContext.resolution = resolution;
    if (parsingContext.featureId) {
      const id = feature.getId();
      if (id !== void 0) {
        evaluationContext.featureId = id;
      } else {
        evaluationContext.featureId = null;
      }
    }
    let nonNullCount = 0;
    for (let i = 0; i < length; ++i) {
      const style = evaluators[i](evaluationContext);
      if (style) {
        styles[nonNullCount] = style;
        nonNullCount += 1;
      }
    }
    styles.length = nonNullCount;
    return styles;
  };
}
function buildRuleSet(rules, context) {
  const length = rules.length;
  const compiledRules = new Array(length);
  for (let i = 0; i < length; ++i) {
    const rule = rules[i];
    const filter = "filter" in rule ? buildExpression(rule.filter, BooleanType, context) : always2;
    let styles;
    if (Array.isArray(rule.style)) {
      const styleLength = rule.style.length;
      styles = new Array(styleLength);
      for (let j = 0; j < styleLength; ++j) {
        styles[j] = buildStyle(rule.style[j], context);
      }
    } else {
      styles = [buildStyle(rule.style, context)];
    }
    compiledRules[i] = { filter, styles };
  }
  return function(context2) {
    const styles = [];
    let someMatched = false;
    for (let i = 0; i < length; ++i) {
      const filterEvaluator = compiledRules[i].filter;
      if (!filterEvaluator(context2)) {
        continue;
      }
      if (rules[i].else && someMatched) {
        continue;
      }
      someMatched = true;
      for (const styleEvaluator of compiledRules[i].styles) {
        const style = styleEvaluator(context2);
        if (!style) {
          continue;
        }
        styles.push(style);
      }
    }
    return styles;
  };
}
function buildStyle(flatStyle, context) {
  const evaluateFill = buildFill(flatStyle, "", context);
  const evaluateStroke = buildStroke(flatStyle, "", context);
  const evaluateText = buildText(flatStyle, context);
  const evaluateImage = buildImage(flatStyle, context);
  const evaluateZIndex = numberEvaluator(flatStyle, "z-index", context);
  if (!evaluateFill && !evaluateStroke && !evaluateText && !evaluateImage && !isEmpty(flatStyle)) {
    throw new Error(
      "No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(flatStyle)
    );
  }
  const style = new Style_default();
  return function(context2) {
    let empty = true;
    if (evaluateFill) {
      const fill = evaluateFill(context2);
      if (fill) {
        empty = false;
      }
      style.setFill(fill);
    }
    if (evaluateStroke) {
      const stroke = evaluateStroke(context2);
      if (stroke) {
        empty = false;
      }
      style.setStroke(stroke);
    }
    if (evaluateText) {
      const text = evaluateText(context2);
      if (text) {
        empty = false;
      }
      style.setText(text);
    }
    if (evaluateImage) {
      const image = evaluateImage(context2);
      if (image) {
        empty = false;
      }
      style.setImage(image);
    }
    if (evaluateZIndex) {
      style.setZIndex(evaluateZIndex(context2));
    }
    if (empty) {
      return null;
    }
    return style;
  };
}
function buildFill(flatStyle, prefix, context) {
  let evaluateColor;
  if (prefix + "fill-pattern-src" in flatStyle) {
    evaluateColor = patternEvaluator(flatStyle, prefix + "fill-", context);
  } else {
    if (flatStyle[prefix + "fill-color"] === "none") {
      return (context2) => null;
    }
    evaluateColor = colorLikeEvaluator(
      flatStyle,
      prefix + "fill-color",
      context
    );
  }
  if (!evaluateColor) {
    return null;
  }
  const fill = new Fill_default();
  return function(context2) {
    const color = evaluateColor(context2);
    if (color === NO_COLOR) {
      return null;
    }
    fill.setColor(color);
    return fill;
  };
}
function buildStroke(flatStyle, prefix, context) {
  const evaluateWidth = numberEvaluator(
    flatStyle,
    prefix + "stroke-width",
    context
  );
  const evaluateColor = colorLikeEvaluator(
    flatStyle,
    prefix + "stroke-color",
    context
  );
  if (!evaluateWidth && !evaluateColor) {
    return null;
  }
  const evaluateLineCap = stringEvaluator(
    flatStyle,
    prefix + "stroke-line-cap",
    context
  );
  const evaluateLineJoin = stringEvaluator(
    flatStyle,
    prefix + "stroke-line-join",
    context
  );
  const evaluateLineDash = numberArrayEvaluator(
    flatStyle,
    prefix + "stroke-line-dash",
    context
  );
  const evaluateLineDashOffset = numberEvaluator(
    flatStyle,
    prefix + "stroke-line-dash-offset",
    context
  );
  const evaluateMiterLimit = numberEvaluator(
    flatStyle,
    prefix + "stroke-miter-limit",
    context
  );
  const stroke = new Stroke_default();
  return function(context2) {
    if (evaluateColor) {
      const color = evaluateColor(context2);
      if (color === NO_COLOR) {
        return null;
      }
      stroke.setColor(color);
    }
    if (evaluateWidth) {
      stroke.setWidth(evaluateWidth(context2));
    }
    if (evaluateLineCap) {
      const lineCap = evaluateLineCap(context2);
      if (lineCap !== "butt" && lineCap !== "round" && lineCap !== "square") {
        throw new Error("Expected butt, round, or square line cap");
      }
      stroke.setLineCap(lineCap);
    }
    if (evaluateLineJoin) {
      const lineJoin = evaluateLineJoin(context2);
      if (lineJoin !== "bevel" && lineJoin !== "round" && lineJoin !== "miter") {
        throw new Error("Expected bevel, round, or miter line join");
      }
      stroke.setLineJoin(lineJoin);
    }
    if (evaluateLineDash) {
      stroke.setLineDash(evaluateLineDash(context2));
    }
    if (evaluateLineDashOffset) {
      stroke.setLineDashOffset(evaluateLineDashOffset(context2));
    }
    if (evaluateMiterLimit) {
      stroke.setMiterLimit(evaluateMiterLimit(context2));
    }
    return stroke;
  };
}
function buildText(flatStyle, context) {
  const prefix = "text-";
  const evaluateValue = stringEvaluator(flatStyle, prefix + "value", context);
  if (!evaluateValue) {
    return null;
  }
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateBackgroundFill = buildFill(
    flatStyle,
    prefix + "background-",
    context
  );
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateBackgroundStroke = buildStroke(
    flatStyle,
    prefix + "background-",
    context
  );
  const evaluateFont = stringEvaluator(flatStyle, prefix + "font", context);
  const evaluateMaxAngle = numberEvaluator(
    flatStyle,
    prefix + "max-angle",
    context
  );
  const evaluateOffsetX = numberEvaluator(
    flatStyle,
    prefix + "offset-x",
    context
  );
  const evaluateOffsetY = numberEvaluator(
    flatStyle,
    prefix + "offset-y",
    context
  );
  const evaluateOverflow = booleanEvaluator(
    flatStyle,
    prefix + "overflow",
    context
  );
  const evaluatePlacement = stringEvaluator(
    flatStyle,
    prefix + "placement",
    context
  );
  const evaluateRepeat = numberEvaluator(flatStyle, prefix + "repeat", context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateAlign = stringEvaluator(flatStyle, prefix + "align", context);
  const evaluateJustify = stringEvaluator(
    flatStyle,
    prefix + "justify",
    context
  );
  const evaluateBaseline = stringEvaluator(
    flatStyle,
    prefix + "baseline",
    context
  );
  const evaluateKeepUpright = booleanEvaluator(
    flatStyle,
    prefix + "keep-upright",
    context
  );
  const evaluatePadding = numberArrayEvaluator(
    flatStyle,
    prefix + "padding",
    context
  );
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const text = new Text_default({ declutterMode });
  return function(context2) {
    text.setText(evaluateValue(context2));
    if (evaluateFill) {
      text.setFill(evaluateFill(context2));
    }
    if (evaluateBackgroundFill) {
      text.setBackgroundFill(evaluateBackgroundFill(context2));
    }
    if (evaluateStroke) {
      text.setStroke(evaluateStroke(context2));
    }
    if (evaluateBackgroundStroke) {
      text.setBackgroundStroke(evaluateBackgroundStroke(context2));
    }
    if (evaluateFont) {
      text.setFont(evaluateFont(context2));
    }
    if (evaluateMaxAngle) {
      text.setMaxAngle(evaluateMaxAngle(context2));
    }
    if (evaluateOffsetX) {
      text.setOffsetX(evaluateOffsetX(context2));
    }
    if (evaluateOffsetY) {
      text.setOffsetY(evaluateOffsetY(context2));
    }
    if (evaluateOverflow) {
      text.setOverflow(evaluateOverflow(context2));
    }
    if (evaluatePlacement) {
      const placement = evaluatePlacement(context2);
      if (placement !== "point" && placement !== "line") {
        throw new Error("Expected point or line for text-placement");
      }
      text.setPlacement(placement);
    }
    if (evaluateRepeat) {
      text.setRepeat(evaluateRepeat(context2));
    }
    if (evaluateScale) {
      text.setScale(evaluateScale(context2));
    }
    if (evaluateRotateWithView) {
      text.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateRotation) {
      text.setRotation(evaluateRotation(context2));
    }
    if (evaluateAlign) {
      const textAlign = evaluateAlign(context2);
      if (textAlign !== "left" && textAlign !== "center" && textAlign !== "right" && textAlign !== "end" && textAlign !== "start") {
        throw new Error(
          "Expected left, right, center, start, or end for text-align"
        );
      }
      text.setTextAlign(textAlign);
    }
    if (evaluateJustify) {
      const justify = evaluateJustify(context2);
      if (justify !== "left" && justify !== "right" && justify !== "center") {
        throw new Error("Expected left, right, or center for text-justify");
      }
      text.setJustify(justify);
    }
    if (evaluateBaseline) {
      const textBaseline = evaluateBaseline(context2);
      if (textBaseline !== "bottom" && textBaseline !== "top" && textBaseline !== "middle" && textBaseline !== "alphabetic" && textBaseline !== "hanging") {
        throw new Error(
          "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
        );
      }
      text.setTextBaseline(textBaseline);
    }
    if (evaluatePadding) {
      text.setPadding(evaluatePadding(context2));
    }
    if (evaluateKeepUpright) {
      text.setKeepUpright(evaluateKeepUpright(context2));
    }
    return text;
  };
}
function buildImage(flatStyle, context) {
  if ("icon-src" in flatStyle) {
    return buildIcon(flatStyle, context);
  }
  if ("shape-points" in flatStyle) {
    return buildShape(flatStyle, context);
  }
  if ("circle-radius" in flatStyle) {
    return buildCircle(flatStyle, context);
  }
  return null;
}
function buildIcon(flatStyle, context) {
  const prefix = "icon-";
  const srcName = prefix + "src";
  const src = requireString(flatStyle[srcName], srcName);
  const evaluateAnchor = coordinateEvaluator(
    flatStyle,
    prefix + "anchor",
    context
  );
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateOpacity = numberEvaluator(
    flatStyle,
    prefix + "opacity",
    context
  );
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + "displacement",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const anchorOrigin = optionalIconOrigin(flatStyle, prefix + "anchor-origin");
  const anchorXUnits = optionalIconAnchorUnits(
    flatStyle,
    prefix + "anchor-x-units"
  );
  const anchorYUnits = optionalIconAnchorUnits(
    flatStyle,
    prefix + "anchor-y-units"
  );
  const color = optionalColorLike(flatStyle, prefix + "color");
  const crossOrigin = optionalString(flatStyle, prefix + "cross-origin");
  const offset = optionalNumberArray(flatStyle, prefix + "offset");
  const offsetOrigin = optionalIconOrigin(flatStyle, prefix + "offset-origin");
  const width = optionalNumber(flatStyle, prefix + "width");
  const height = optionalNumber(flatStyle, prefix + "height");
  const size = optionalSize(flatStyle, prefix + "size");
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const icon = new Icon_default({
    src,
    anchorOrigin,
    anchorXUnits,
    anchorYUnits,
    color,
    crossOrigin,
    offset,
    offsetOrigin,
    height,
    width,
    size,
    declutterMode
  });
  return function(context2) {
    if (evaluateOpacity) {
      icon.setOpacity(evaluateOpacity(context2));
    }
    if (evaluateDisplacement) {
      icon.setDisplacement(evaluateDisplacement(context2));
    }
    if (evaluateRotation) {
      icon.setRotation(evaluateRotation(context2));
    }
    if (evaluateRotateWithView) {
      icon.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateScale) {
      icon.setScale(evaluateScale(context2));
    }
    if (evaluateAnchor) {
      icon.setAnchor(evaluateAnchor(context2));
    }
    return icon;
  };
}
function buildShape(flatStyle, context) {
  const prefix = "shape-";
  const pointsName = prefix + "points";
  const radiusName = prefix + "radius";
  const points = requireNumber(flatStyle[pointsName], pointsName);
  const radius = requireNumber(flatStyle[radiusName], radiusName);
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + "displacement",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const radius2 = optionalNumber(flatStyle, prefix + "radius2");
  const angle = optionalNumber(flatStyle, prefix + "angle");
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const shape = new RegularShape_default({
    points,
    radius,
    radius2,
    angle,
    declutterMode
  });
  return function(context2) {
    if (evaluateFill) {
      shape.setFill(evaluateFill(context2));
    }
    if (evaluateStroke) {
      shape.setStroke(evaluateStroke(context2));
    }
    if (evaluateDisplacement) {
      shape.setDisplacement(evaluateDisplacement(context2));
    }
    if (evaluateRotation) {
      shape.setRotation(evaluateRotation(context2));
    }
    if (evaluateRotateWithView) {
      shape.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateScale) {
      shape.setScale(evaluateScale(context2));
    }
    return shape;
  };
}
function buildCircle(flatStyle, context) {
  const prefix = "circle-";
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateRadius = numberEvaluator(flatStyle, prefix + "radius", context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + "displacement",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const circle = new Circle_default({
    radius: 5,
    // this is arbitrary, but required - the evaluated radius is used below
    declutterMode
  });
  return function(context2) {
    if (evaluateRadius) {
      circle.setRadius(evaluateRadius(context2));
    }
    if (evaluateFill) {
      circle.setFill(evaluateFill(context2));
    }
    if (evaluateStroke) {
      circle.setStroke(evaluateStroke(context2));
    }
    if (evaluateDisplacement) {
      circle.setDisplacement(evaluateDisplacement(context2));
    }
    if (evaluateRotation) {
      circle.setRotation(evaluateRotation(context2));
    }
    if (evaluateRotateWithView) {
      circle.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateScale) {
      circle.setScale(evaluateScale(context2));
    }
    return circle;
  };
}
function numberEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return void 0;
  }
  const evaluator = buildExpression(flatStyle[name], NumberType, context);
  return function(context2) {
    return requireNumber(evaluator(context2), name);
  };
}
function stringEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], StringType, context);
  return function(context2) {
    return requireString(evaluator(context2), name);
  };
}
function patternEvaluator(flatStyle, prefix, context) {
  const srcEvaluator = stringEvaluator(
    flatStyle,
    prefix + "pattern-src",
    context
  );
  const offsetEvaluator = sizeEvaluator(
    flatStyle,
    prefix + "pattern-offset",
    context
  );
  const patternSizeEvaluator = sizeEvaluator(
    flatStyle,
    prefix + "pattern-size",
    context
  );
  const colorEvaluator = colorLikeEvaluator(
    flatStyle,
    prefix + "color",
    context
  );
  return function(context2) {
    return {
      src: srcEvaluator(context2),
      offset: offsetEvaluator && offsetEvaluator(context2),
      size: patternSizeEvaluator && patternSizeEvaluator(context2),
      color: colorEvaluator && colorEvaluator(context2)
    };
  };
}
function booleanEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], BooleanType, context);
  return function(context2) {
    const value = evaluator(context2);
    if (typeof value !== "boolean") {
      throw new Error(`Expected a boolean for ${name}`);
    }
    return value;
  };
}
function colorLikeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], ColorType, context);
  return function(context2) {
    return requireColorLike(evaluator(context2), name);
  };
}
function numberArrayEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);
  return function(context2) {
    return requireNumberArray(evaluator(context2), name);
  };
}
function coordinateEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);
  return function(context2) {
    const array = requireNumberArray(evaluator(context2), name);
    if (array.length !== 2) {
      throw new Error(`Expected two numbers for ${name}`);
    }
    return array;
  };
}
function sizeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);
  return function(context2) {
    return requireSize(evaluator(context2), name);
  };
}
function sizeLikeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(
    flatStyle[name],
    NumberArrayType | NumberType,
    context
  );
  return function(context2) {
    return requireSizeLike(evaluator(context2), name);
  };
}
function optionalNumber(flatStyle, property) {
  const value = flatStyle[property];
  if (value === void 0) {
    return void 0;
  }
  if (typeof value !== "number") {
    throw new Error(`Expected a number for ${property}`);
  }
  return value;
}
function optionalSize(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (typeof encoded === "number") {
    return toSize(encoded);
  }
  if (!Array.isArray(encoded)) {
    throw new Error(`Expected a number or size array for ${property}`);
  }
  if (encoded.length !== 2 || typeof encoded[0] !== "number" || typeof encoded[1] !== "number") {
    throw new Error(`Expected a number or size array for ${property}`);
  }
  return encoded;
}
function optionalString(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (typeof encoded !== "string") {
    throw new Error(`Expected a string for ${property}`);
  }
  return encoded;
}
function optionalIconOrigin(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (encoded !== "bottom-left" && encoded !== "bottom-right" && encoded !== "top-left" && encoded !== "top-right") {
    throw new Error(
      `Expected bottom-left, bottom-right, top-left, or top-right for ${property}`
    );
  }
  return encoded;
}
function optionalIconAnchorUnits(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (encoded !== "pixels" && encoded !== "fraction") {
    throw new Error(`Expected pixels or fraction for ${property}`);
  }
  return encoded;
}
function optionalNumberArray(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  return requireNumberArray(encoded, property);
}
function optionalDeclutterMode(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (typeof encoded !== "string") {
    throw new Error(`Expected a string for ${property}`);
  }
  if (encoded !== "declutter" && encoded !== "obstacle" && encoded !== "none") {
    throw new Error(`Expected declutter, obstacle, or none for ${property}`);
  }
  return encoded;
}
function optionalColorLike(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  return requireColorLike(encoded, property);
}
function requireNumberArray(value, property) {
  if (!Array.isArray(value)) {
    throw new Error(`Expected an array for ${property}`);
  }
  const length = value.length;
  for (let i = 0; i < length; ++i) {
    if (typeof value[i] !== "number") {
      throw new Error(`Expected an array of numbers for ${property}`);
    }
  }
  return value;
}
function requireString(value, property) {
  if (typeof value !== "string") {
    throw new Error(`Expected a string for ${property}`);
  }
  return value;
}
function requireNumber(value, property) {
  if (typeof value !== "number") {
    throw new Error(`Expected a number for ${property}`);
  }
  return value;
}
function requireColorLike(value, property) {
  if (typeof value === "string") {
    return value;
  }
  const array = requireNumberArray(value, property);
  const length = array.length;
  if (length < 3 || length > 4) {
    throw new Error(`Expected a color with 3 or 4 values for ${property}`);
  }
  return array;
}
function requireSize(value, property) {
  const size = requireNumberArray(value, property);
  if (size.length !== 2) {
    throw new Error(`Expected an array of two numbers for ${property}`);
  }
  return size;
}
function requireSizeLike(value, property) {
  if (typeof value === "number") {
    return value;
  }
  return requireSize(value, property);
}

// node_modules/ol/layer/BaseVector.js
var Property3 = {
  RENDER_ORDER: "renderOrder"
};
var BaseVectorLayer = class extends Layer_default {
  /**
   * @param {Options<FeatureType, VectorSourceType>} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    const baseOptions = Object.assign({}, options);
    delete baseOptions.style;
    delete baseOptions.renderBuffer;
    delete baseOptions.updateWhileAnimating;
    delete baseOptions.updateWhileInteracting;
    super(baseOptions);
    this.declutter_ = options.declutter ? String(options.declutter) : void 0;
    this.renderBuffer_ = options.renderBuffer !== void 0 ? options.renderBuffer : 100;
    this.style_ = null;
    this.styleFunction_ = void 0;
    this.setStyle(options.style);
    this.updateWhileAnimating_ = options.updateWhileAnimating !== void 0 ? options.updateWhileAnimating : false;
    this.updateWhileInteracting_ = options.updateWhileInteracting !== void 0 ? options.updateWhileInteracting : false;
  }
  /**
   * @return {string} Declutter group.
   * @override
   */
  getDeclutter() {
    return this.declutter_;
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   * @override
   */
  getFeatures(pixel) {
    return super.getFeatures(pixel);
  }
  /**
   * @return {number|undefined} Render buffer.
   */
  getRenderBuffer() {
    return this.renderBuffer_;
  }
  /**
   * @return {import("../render.js").OrderFunction|null|undefined} Render order.
   */
  getRenderOrder() {
    return (
      /** @type {import("../render.js").OrderFunction|null|undefined} */
      this.get(Property3.RENDER_ORDER)
    );
  }
  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null|undefined} Layer style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }
  /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   * @override
   */
  renderDeclutter(frameState, layerState) {
    const declutterGroup = this.getDeclutter();
    if (declutterGroup in frameState.declutter === false) {
      frameState.declutter[declutterGroup] = new RBush(9);
    }
    this.getRenderer().renderDeclutter(frameState, layerState);
  }
  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */
  setRenderOrder(renderOrder) {
    this.set(Property3.RENDER_ORDER, renderOrder);
  }
  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
   * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
   * ```js
   * vectorLayer.setStyle({
   *   "fill-color": "yellow",
   *   "stroke-color": "black",
   *   "stroke-width": 4
   * })
   * ```
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */
  setStyle(style) {
    this.style_ = style === void 0 ? createDefaultStyle : style;
    const styleLike = toStyleLike(style);
    this.styleFunction_ = style === null ? void 0 : toFunction(styleLike);
    this.changed();
  }
  /**
   * @param {boolean|string|number} declutter Declutter images and text.
   * @api
   */
  setDeclutter(declutter) {
    this.declutter_ = declutter ? String(declutter) : void 0;
    this.changed();
  }
};
function toStyleLike(style) {
  if (style === void 0) {
    return createDefaultStyle;
  }
  if (!style) {
    return null;
  }
  if (typeof style === "function") {
    return style;
  }
  if (style instanceof Style_default) {
    return style;
  }
  if (!Array.isArray(style)) {
    return flatStylesToStyleFunction([style]);
  }
  if (style.length === 0) {
    return [];
  }
  const length = style.length;
  const first = style[0];
  if (first instanceof Style_default) {
    const styles = new Array(length);
    for (let i = 0; i < length; ++i) {
      const candidate = style[i];
      if (!(candidate instanceof Style_default)) {
        throw new Error("Expected a list of style instances");
      }
      styles[i] = candidate;
    }
    return styles;
  }
  if ("style" in first) {
    const rules = new Array(length);
    for (let i = 0; i < length; ++i) {
      const candidate = style[i];
      if (!("style" in candidate)) {
        throw new Error("Expected a list of rules with a style property");
      }
      rules[i] = candidate;
    }
    return rulesToStyleFunction(rules);
  }
  const flatStyles = (
    /** @type {Array<import("../style/flat.js").FlatStyle>} */
    style
  );
  return flatStylesToStyleFunction(flatStyles);
}
var BaseVector_default = BaseVectorLayer;

// node_modules/ol/render/Event.js
var RenderEvent = class extends Event_default {
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */
  constructor(type, inversePixelTransform, frameState, context) {
    super(type);
    this.inversePixelTransform = inversePixelTransform;
    this.frameState = frameState;
    this.context = context;
  }
};
var Event_default2 = RenderEvent;

// node_modules/ol/renderer/Map.js
var MapRenderer = class extends Disposable_default {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(map) {
    super();
    this.map_ = map;
  }
  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(type, frameState) {
    abstract();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */
  calculateMatrices2D(frameState) {
    const viewState = frameState.viewState;
    const coordinateToPixelTransform = frameState.coordinateToPixelTransform;
    const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
    compose(
      coordinateToPixelTransform,
      frameState.size[0] / 2,
      frameState.size[1] / 2,
      1 / viewState.resolution,
      -1 / viewState.resolution,
      -viewState.rotation,
      -viewState.center[0],
      -viewState.center[1]
    );
    makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
    let result;
    const viewState = frameState.viewState;
    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
      return callback.call(thisArg, feature, managed ? layer : null, geometry);
    }
    const projection = viewState.projection;
    const translatedCoordinate = wrapX2(coordinate.slice(), projection);
    const offsets = [[0, 0]];
    if (projection.canWrapX() && checkWrapped) {
      const projectionExtent = projection.getExtent();
      const worldWidth = getWidth(projectionExtent);
      offsets.push([-worldWidth, 0], [worldWidth, 0]);
    }
    const layerStates = frameState.layerStatesArray;
    const numLayers = layerStates.length;
    const matches = (
      /** @type {Array<HitMatch<T>>} */
      []
    );
    const tmpCoord = [];
    for (let i = 0; i < offsets.length; i++) {
      for (let j = numLayers - 1; j >= 0; --j) {
        const layerState = layerStates[j];
        const layer = layerState.layer;
        if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
          const layerRenderer = layer.getRenderer();
          const source = layer.getSource();
          if (layerRenderer && source) {
            const coordinates2 = source.getWrapX() ? translatedCoordinate : coordinate;
            const callback2 = forEachFeatureAtCoordinate.bind(
              null,
              layerState.managed
            );
            tmpCoord[0] = coordinates2[0] + offsets[i][0];
            tmpCoord[1] = coordinates2[1] + offsets[i][1];
            result = layerRenderer.forEachFeatureAtCoordinate(
              tmpCoord,
              frameState,
              hitTolerance,
              callback2,
              matches
            );
          }
          if (result) {
            return result;
          }
        }
      }
    }
    if (matches.length === 0) {
      return void 0;
    }
    const order = 1 / matches.length;
    matches.forEach((m, i) => m.distanceSq += i * order);
    matches.sort((a, b) => a.distanceSq - b.distanceSq);
    matches.some((m) => {
      return result = m.callback(m.feature, m.layer, m.geometry);
    });
    return result;
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
    const hasFeature = this.forEachFeatureAtCoordinate(
      coordinate,
      frameState,
      hitTolerance,
      checkWrapped,
      TRUE,
      this,
      layerFilter,
      thisArg
    );
    return hasFeature !== void 0;
  }
  /**
   * @return {import("../Map.js").default} Map.
   */
  getMap() {
    return this.map_;
  }
  /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(frameState) {
    abstract();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  scheduleExpireIconCache(frameState) {
    if (shared.canExpireCache()) {
      frameState.postRenderFunctions.push(expireIconCache);
    }
  }
};
function expireIconCache(map, frameState) {
  shared.expire();
}
var Map_default = MapRenderer;

// node_modules/ol/renderer/Composite.js
var CompositeMapRenderer = class extends Map_default {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(map) {
    super(map);
    this.fontChangeListenerKey_ = listen(
      checkedFonts,
      ObjectEventType_default.PROPERTYCHANGE,
      map.redrawText,
      map
    );
    this.element_ = document.createElement("div");
    const style = this.element_.style;
    style.position = "absolute";
    style.width = "100%";
    style.height = "100%";
    style.zIndex = "0";
    this.element_.className = CLASS_UNSELECTABLE + " ol-layers";
    const container = map.getViewport();
    container.insertBefore(this.element_, container.firstChild || null);
    this.children_ = [];
    this.renderedVisible_ = true;
  }
  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @override
   */
  dispatchRenderEvent(type, frameState) {
    const map = this.getMap();
    if (map.hasListener(type)) {
      const event = new Event_default2(type, void 0, frameState);
      map.dispatchEvent(event);
    }
  }
  /**
   * @override
   */
  disposeInternal() {
    unlistenByKey(this.fontChangeListenerKey_);
    this.element_.remove();
    super.disposeInternal();
  }
  /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderFrame(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element_.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    this.calculateMatrices2D(frameState);
    this.dispatchRenderEvent(EventType_default3.PRECOMPOSE, frameState);
    const layerStatesArray = frameState.layerStatesArray.sort(
      (a, b) => a.zIndex - b.zIndex
    );
    const declutter = layerStatesArray.some(
      (layerState) => layerState.layer instanceof BaseVector_default && layerState.layer.getDeclutter()
    );
    if (declutter) {
      frameState.declutter = {};
    }
    const viewState = frameState.viewState;
    this.children_.length = 0;
    const renderedLayerStates = [];
    let previousElement = null;
    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      const layerState = layerStatesArray[i];
      frameState.layerIndex = i;
      const layer = layerState.layer;
      const sourceState = layer.getSourceState();
      if (!inView(layerState, viewState) || sourceState != "ready" && sourceState != "undefined") {
        layer.unrender();
        continue;
      }
      const element = layer.render(frameState, previousElement);
      if (!element) {
        continue;
      }
      if (element !== previousElement) {
        this.children_.push(element);
        previousElement = element;
      }
      renderedLayerStates.push(layerState);
    }
    this.declutter(frameState, renderedLayerStates);
    replaceChildren(this.element_, this.children_);
    this.dispatchRenderEvent(EventType_default3.POSTCOMPOSE, frameState);
    if (!this.renderedVisible_) {
      this.element_.style.display = "";
      this.renderedVisible_ = true;
    }
    this.scheduleExpireIconCache(frameState);
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {Array<import('../layer/Layer.js').State>} layerStates Layers.
   */
  declutter(frameState, layerStates) {
    if (!frameState.declutter) {
      return;
    }
    for (let i = layerStates.length - 1; i >= 0; --i) {
      const layerState = layerStates[i];
      const layer = layerState.layer;
      if (layer.getDeclutter()) {
        layer.renderDeclutter(frameState, layerState);
      }
    }
    layerStates.forEach(
      (layerState) => layerState.layer.renderDeferred(frameState)
    );
  }
};
var Composite_default = CompositeMapRenderer;

// node_modules/ol/Map.js
function removeLayerMapProperty(layer) {
  if (layer instanceof Layer_default) {
    layer.setMapInternal(null);
    return;
  }
  if (layer instanceof Group_default) {
    layer.getLayers().forEach(removeLayerMapProperty);
  }
}
function setLayerMapProperty(layer, map) {
  if (layer instanceof Layer_default) {
    layer.setMapInternal(map);
    return;
  }
  if (layer instanceof Group_default) {
    const layers = layer.getLayers().getArray();
    for (let i = 0, ii = layers.length; i < ii; ++i) {
      setLayerMapProperty(layers[i], map);
    }
  }
}
var Map = class extends Object_default {
  /**
   * @param {MapOptions} [options] Map options.
   */
  constructor(options) {
    super();
    options = options || {};
    this.on;
    this.once;
    this.un;
    const optionsInternal = createOptionsInternal(options);
    this.renderComplete_ = false;
    this.loaded_ = true;
    this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this);
    this.maxTilesLoading_ = options.maxTilesLoading !== void 0 ? options.maxTilesLoading : 16;
    this.pixelRatio_ = options.pixelRatio !== void 0 ? options.pixelRatio : DEVICE_PIXEL_RATIO;
    this.postRenderTimeoutHandle_;
    this.animationDelayKey_;
    this.animationDelay_ = this.animationDelay_.bind(this);
    this.coordinateToPixelTransform_ = create();
    this.pixelToCoordinateTransform_ = create();
    this.frameIndex_ = 0;
    this.frameState_ = null;
    this.previousExtent_ = null;
    this.viewPropertyListenerKey_ = null;
    this.viewChangeListenerKey_ = null;
    this.layerGroupPropertyListenerKeys_ = null;
    this.viewport_ = document.createElement("div");
    this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : "");
    this.viewport_.style.position = "relative";
    this.viewport_.style.overflow = "hidden";
    this.viewport_.style.width = "100%";
    this.viewport_.style.height = "100%";
    this.overlayContainer_ = document.createElement("div");
    this.overlayContainer_.style.position = "absolute";
    this.overlayContainer_.style.zIndex = "0";
    this.overlayContainer_.style.width = "100%";
    this.overlayContainer_.style.height = "100%";
    this.overlayContainer_.style.pointerEvents = "none";
    this.overlayContainer_.className = "ol-overlaycontainer";
    this.viewport_.appendChild(this.overlayContainer_);
    this.overlayContainerStopEvent_ = document.createElement("div");
    this.overlayContainerStopEvent_.style.position = "absolute";
    this.overlayContainerStopEvent_.style.zIndex = "0";
    this.overlayContainerStopEvent_.style.width = "100%";
    this.overlayContainerStopEvent_.style.height = "100%";
    this.overlayContainerStopEvent_.style.pointerEvents = "none";
    this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent";
    this.viewport_.appendChild(this.overlayContainerStopEvent_);
    this.mapBrowserEventHandler_ = null;
    this.moveTolerance_ = options.moveTolerance;
    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
    this.targetChangeHandlerKeys_ = null;
    this.targetElement_ = null;
    this.resizeObserver_ = new ResizeObserver(() => this.updateSize());
    this.controls = optionsInternal.controls || defaults();
    this.interactions = optionsInternal.interactions || defaults2({
      onFocusOnly: true
    });
    this.overlays_ = optionsInternal.overlays;
    this.overlayIdIndex_ = {};
    this.renderer_ = null;
    this.postRenderFunctions_ = [];
    this.tileQueue_ = new TileQueue_default(
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this)
    );
    this.addChangeListener(
      MapProperty_default.LAYERGROUP,
      this.handleLayerGroupChanged_
    );
    this.addChangeListener(MapProperty_default.VIEW, this.handleViewChanged_);
    this.addChangeListener(MapProperty_default.SIZE, this.handleSizeChanged_);
    this.addChangeListener(MapProperty_default.TARGET, this.handleTargetChanged_);
    this.setProperties(optionsInternal.values);
    const map = this;
    if (options.view && !(options.view instanceof View_default)) {
      options.view.then(function(viewOptions) {
        map.setView(new View_default(viewOptions));
      });
    }
    this.controls.addEventListener(
      CollectionEventType_default.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */
      (event) => {
        event.element.setMap(this);
      }
    );
    this.controls.addEventListener(
      CollectionEventType_default.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(null);
      }
    );
    this.interactions.addEventListener(
      CollectionEventType_default.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(this);
      }
    );
    this.interactions.addEventListener(
      CollectionEventType_default.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(null);
      }
    );
    this.overlays_.addEventListener(
      CollectionEventType_default.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (event) => {
        this.addOverlayInternal_(event.element);
      }
    );
    this.overlays_.addEventListener(
      CollectionEventType_default.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (event) => {
        const id = event.element.getId();
        if (id !== void 0) {
          delete this.overlayIdIndex_[id.toString()];
        }
        event.element.setMap(null);
      }
    );
    this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       */
      (control) => {
        control.setMap(this);
      }
    );
    this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       */
      (interaction) => {
        interaction.setMap(this);
      }
    );
    this.overlays_.forEach(this.addOverlayInternal_.bind(this));
  }
  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  addControl(control) {
    this.getControls().push(control);
  }
  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */
  addInteraction(interaction) {
    this.getInteractions().push(interaction);
  }
  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */
  addLayer(layer) {
    const layers = this.getLayerGroup().getLayers();
    layers.push(layer);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */
  handleLayerAdd_(event) {
    setLayerMapProperty(event.layer, this);
  }
  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */
  addOverlay(overlay) {
    this.getOverlays().push(overlay);
  }
  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */
  addOverlayInternal_(overlay) {
    const id = overlay.getId();
    if (id !== void 0) {
      this.overlayIdIndex_[id.toString()] = overlay;
    }
    overlay.setMap(this);
  }
  /**
   *
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.controls.clear();
    this.interactions.clear();
    this.overlays_.clear();
    this.resizeObserver_.disconnect();
    this.setTarget(null);
    super.disposeInternal();
  }
  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * For polygons without a fill, only the stroke will be used for hit detection.
   * Polygons must have a fill style applied to ensure that pixels inside a polygon are detected.
   * The fill can be transparent.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */
  forEachFeatureAtPixel(pixel, callback, options) {
    if (!this.frameState_ || !this.renderer_) {
      return;
    }
    const coordinate = this.getCoordinateFromPixelInternal(pixel);
    options = options !== void 0 ? options : {};
    const hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
    const layerFilter = options.layerFilter !== void 0 ? options.layerFilter : TRUE;
    const checkWrapped = options.checkWrapped !== false;
    return this.renderer_.forEachFeatureAtCoordinate(
      coordinate,
      this.frameState_,
      hitTolerance,
      checkWrapped,
      callback,
      null,
      layerFilter,
      null
    );
  }
  /**
   * Get all features that intersect a pixel on the viewport.
   * For polygons without a fill, only the stroke will be used for hit detection.
   * Polygons must have a fill style applied to ensure that pixels inside a polygon are detected.
   * The fill can be transparent.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */
  getFeaturesAtPixel(pixel, options) {
    const features = [];
    this.forEachFeatureAtPixel(
      pixel,
      function(feature) {
        features.push(feature);
      },
      options
    );
    return features;
  }
  /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */
  getAllLayers() {
    const layers = [];
    function addLayersFrom(layerGroup) {
      layerGroup.forEach(function(layer) {
        if (layer instanceof Group_default) {
          addLayersFrom(layer.getLayers());
        } else {
          layers.push(layer);
        }
      });
    }
    addLayersFrom(this.getLayers());
    return layers;
  }
  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * For polygons without a fill, only the stroke will be used for hit detection.
   * Polygons must have a fill style applied to ensure that pixels inside a polygon are detected.
   * The fill can be transparent.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */
  hasFeatureAtPixel(pixel, options) {
    if (!this.frameState_ || !this.renderer_) {
      return false;
    }
    const coordinate = this.getCoordinateFromPixelInternal(pixel);
    options = options !== void 0 ? options : {};
    const layerFilter = options.layerFilter !== void 0 ? options.layerFilter : TRUE;
    const hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
    const checkWrapped = options.checkWrapped !== false;
    return this.renderer_.hasFeatureAtCoordinate(
      coordinate,
      this.frameState_,
      hitTolerance,
      checkWrapped,
      layerFilter,
      null
    );
  }
  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  getEventCoordinate(event) {
    return this.getCoordinateFromPixel(this.getEventPixel(event));
  }
  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */
  getEventCoordinateInternal(event) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
  }
  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent|{clientX: number, clientY: number}} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */
  getEventPixel(event) {
    const viewport = this.viewport_;
    const viewportPosition = viewport.getBoundingClientRect();
    const viewportSize = this.getSize();
    const scaleX = viewportPosition.width / viewportSize[0];
    const scaleY = viewportPosition.height / viewportSize[1];
    const eventPosition = (
      //FIXME Are we really calling this with a TouchEvent anywhere?
      "changedTouches" in event ? (
        /** @type {TouchEvent} */
        event.changedTouches[0]
      ) : (
        /** @type {MouseEvent} */
        event
      )
    );
    return [
      (eventPosition.clientX - viewportPosition.left) / scaleX,
      (eventPosition.clientY - viewportPosition.top) / scaleY
    ];
  }
  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  getTarget() {
    return (
      /** @type {HTMLElement|string|undefined} */
      this.get(MapProperty_default.TARGET)
    );
  }
  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  getTargetElement() {
    return this.targetElement_;
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */
  getCoordinateFromPixel(pixel) {
    return toUserCoordinate(
      this.getCoordinateFromPixelInternal(pixel),
      this.getView().getProjection()
    );
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */
  getCoordinateFromPixelInternal(pixel) {
    const frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    return apply(frameState.pixelToCoordinateTransform, pixel.slice());
  }
  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */
  getControls() {
    return this.controls;
  }
  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */
  getOverlays() {
    return this.overlays_;
  }
  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default|null} Overlay.
   * @api
   */
  getOverlayById(id) {
    const overlay = this.overlayIdIndex_[id.toString()];
    return overlay !== void 0 ? overlay : null;
  }
  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */
  getInteractions() {
    return this.interactions;
  }
  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  getLayerGroup() {
    return (
      /** @type {LayerGroup} */
      this.get(MapProperty_default.LAYERGROUP)
    );
  }
  /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */
  setLayers(layers) {
    const group = this.getLayerGroup();
    if (layers instanceof Collection_default) {
      group.setLayers(layers);
      return;
    }
    const collection = group.getLayers();
    collection.clear();
    collection.extend(layers);
  }
  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */
  getLayers() {
    const layers = this.getLayerGroup().getLayers();
    return layers;
  }
  /**
   * @return {boolean} Layers have sources that are still loading.
   */
  getLoadingOrNotReady() {
    const layerStatesArray = this.getLayerGroup().getLayerStatesArray();
    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      const state = layerStatesArray[i];
      if (!state.visible) {
        continue;
      }
      const renderer = state.layer.getRenderer();
      if (renderer && !renderer.ready) {
        return true;
      }
      const source = state.layer.getSource();
      if (source && source.loading) {
        return true;
      }
    }
    return false;
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */
  getPixelFromCoordinate(coordinate) {
    const viewCoordinate = fromUserCoordinate(
      coordinate,
      this.getView().getProjection()
    );
    return this.getPixelFromCoordinateInternal(viewCoordinate);
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */
  getPixelFromCoordinateInternal(coordinate) {
    const frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    return apply(
      frameState.coordinateToPixelTransform,
      coordinate.slice(0, 2)
    );
  }
  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  getSize() {
    return (
      /** @type {import("./size.js").Size|undefined} */
      this.get(MapProperty_default.SIZE)
    );
  }
  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */
  getView() {
    return (
      /** @type {View} */
      this.get(MapProperty_default.VIEW)
    );
  }
  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  getViewport() {
    return this.viewport_;
  }
  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  getOverlayContainer() {
    return this.overlayContainer_;
  }
  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }
  /**
   * @return {!Document} The document where the map is displayed.
   */
  getOwnerDocument() {
    const targetElement = this.getTargetElement();
    return targetElement ? targetElement.ownerDocument : document;
  }
  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {
    return getTilePriority(
      this.frameState_,
      tile,
      tileSourceKey,
      tileCenter,
      tileResolution
    );
  }
  /**
   * @param {PointerEvent|KeyboardEvent|WheelEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */
  handleBrowserEvent(browserEvent, type) {
    type = type || browserEvent.type;
    const mapBrowserEvent = new MapBrowserEvent_default(type, this, browserEvent);
    this.handleMapBrowserEvent(mapBrowserEvent);
  }
  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  handleMapBrowserEvent(mapBrowserEvent) {
    if (!this.frameState_) {
      return;
    }
    const originalEvent = mapBrowserEvent.originalEvent;
    const eventType = originalEvent.type;
    if (eventType === EventType_default2.POINTERDOWN || eventType === EventType_default.WHEEL || eventType === EventType_default.KEYDOWN) {
      const doc = this.getOwnerDocument();
      const rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
      const target = (
        /** @type {Node} */
        originalEvent.target
      );
      const currentDoc = rootNode instanceof ShadowRoot ? rootNode.host === target ? rootNode.host.ownerDocument : rootNode : rootNode === doc ? doc.documentElement : rootNode;
      if (
        // Abort if the target is a child of the container for elements whose events are not meant
        // to be handled by map interactions.
        this.overlayContainerStopEvent_.contains(target) || // Abort if the event target is a child of the container that is no longer in the page.
        // It's possible for the target to no longer be in the page if it has been removed in an
        // event listener, this might happen in a Control that recreates it's content based on
        // user interaction either manually or via a render in something like https://reactjs.org/
        !currentDoc.contains(target)
      ) {
        return;
      }
    }
    mapBrowserEvent.frameState = this.frameState_;
    if (this.dispatchEvent(mapBrowserEvent) !== false) {
      const interactionsArray = this.getInteractions().getArray().slice();
      for (let i = interactionsArray.length - 1; i >= 0; i--) {
        const interaction = interactionsArray[i];
        if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {
          continue;
        }
        const cont = interaction.handleEvent(mapBrowserEvent);
        if (!cont || mapBrowserEvent.propagationStopped) {
          break;
        }
      }
    }
  }
  /**
   * @protected
   */
  handlePostRender() {
    const frameState = this.frameState_;
    const tileQueue = this.tileQueue_;
    if (!tileQueue.isEmpty()) {
      let maxTotalLoading = this.maxTilesLoading_;
      let maxNewLoads = maxTotalLoading;
      if (frameState) {
        const hints = frameState.viewHints;
        if (hints[ViewHint_default.ANIMATING] || hints[ViewHint_default.INTERACTING]) {
          const lowOnFrameBudget = Date.now() - frameState.time > 8;
          maxTotalLoading = lowOnFrameBudget ? 0 : 8;
          maxNewLoads = lowOnFrameBudget ? 0 : 2;
        }
      }
      if (tileQueue.getTilesLoading() < maxTotalLoading) {
        tileQueue.reprioritize();
        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
      }
    }
    if (frameState && this.renderer_ && !frameState.animate) {
      if (this.renderComplete_) {
        if (this.hasListener(EventType_default3.RENDERCOMPLETE)) {
          this.renderer_.dispatchRenderEvent(
            EventType_default3.RENDERCOMPLETE,
            frameState
          );
        }
        if (this.loaded_ === false) {
          this.loaded_ = true;
          this.dispatchEvent(
            new MapEvent_default(MapEventType_default.LOADEND, this, frameState)
          );
        }
      } else if (this.loaded_ === true) {
        this.loaded_ = false;
        this.dispatchEvent(
          new MapEvent_default(MapEventType_default.LOADSTART, this, frameState)
        );
      }
    }
    const postRenderFunctions = this.postRenderFunctions_;
    if (frameState) {
      for (let i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
        postRenderFunctions[i](this, frameState);
      }
    }
    postRenderFunctions.length = 0;
  }
  /**
   * @private
   */
  handleSizeChanged_() {
    if (this.getView() && !this.getView().getAnimating()) {
      this.getView().resolveConstraints(0);
    }
    this.render();
  }
  /**
   * @private
   */
  handleTargetChanged_() {
    if (this.mapBrowserEventHandler_) {
      for (let i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i) {
        unlistenByKey(this.targetChangeHandlerKeys_[i]);
      }
      this.targetChangeHandlerKeys_ = null;
      this.viewport_.removeEventListener(
        EventType_default.CONTEXTMENU,
        this.boundHandleBrowserEvent_
      );
      this.viewport_.removeEventListener(
        EventType_default.WHEEL,
        this.boundHandleBrowserEvent_
      );
      this.mapBrowserEventHandler_.dispose();
      this.mapBrowserEventHandler_ = null;
      this.viewport_.remove();
    }
    if (this.targetElement_) {
      this.resizeObserver_.unobserve(this.targetElement_);
      const rootNode = this.targetElement_.getRootNode();
      if (rootNode instanceof ShadowRoot) {
        this.resizeObserver_.unobserve(rootNode.host);
      }
      this.setSize(void 0);
    }
    const target = this.getTarget();
    const targetElement = typeof target === "string" ? document.getElementById(target) : target;
    this.targetElement_ = targetElement;
    if (!targetElement) {
      if (this.renderer_) {
        clearTimeout(this.postRenderTimeoutHandle_);
        this.postRenderTimeoutHandle_ = void 0;
        this.postRenderFunctions_.length = 0;
        this.renderer_.dispose();
        this.renderer_ = null;
      }
      if (this.animationDelayKey_) {
        cancelAnimationFrame(this.animationDelayKey_);
        this.animationDelayKey_ = void 0;
      }
    } else {
      targetElement.appendChild(this.viewport_);
      if (!this.renderer_) {
        this.renderer_ = new Composite_default(this);
      }
      this.mapBrowserEventHandler_ = new MapBrowserEventHandler_default(
        this,
        this.moveTolerance_
      );
      for (const key in MapBrowserEventType_default) {
        this.mapBrowserEventHandler_.addEventListener(
          MapBrowserEventType_default[key],
          this.handleMapBrowserEvent.bind(this)
        );
      }
      this.viewport_.addEventListener(
        EventType_default.CONTEXTMENU,
        this.boundHandleBrowserEvent_,
        false
      );
      this.viewport_.addEventListener(
        EventType_default.WHEEL,
        this.boundHandleBrowserEvent_,
        PASSIVE_EVENT_LISTENERS ? { passive: false } : false
      );
      let keyboardEventTarget;
      if (!this.keyboardEventTarget_) {
        const targetRoot = targetElement.getRootNode();
        const targetCandidate = targetRoot instanceof ShadowRoot ? targetRoot.host : targetElement;
        keyboardEventTarget = targetCandidate;
      } else {
        keyboardEventTarget = this.keyboardEventTarget_;
      }
      this.targetChangeHandlerKeys_ = [
        listen(
          keyboardEventTarget,
          EventType_default.KEYDOWN,
          this.handleBrowserEvent,
          this
        ),
        listen(
          keyboardEventTarget,
          EventType_default.KEYPRESS,
          this.handleBrowserEvent,
          this
        )
      ];
      const rootNode = targetElement.getRootNode();
      if (rootNode instanceof ShadowRoot) {
        this.resizeObserver_.observe(rootNode.host);
      }
      this.resizeObserver_.observe(targetElement);
    }
    this.updateSize();
  }
  /**
   * @private
   */
  handleTileChange_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewPropertyChanged_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewChanged_() {
    if (this.viewPropertyListenerKey_) {
      unlistenByKey(this.viewPropertyListenerKey_);
      this.viewPropertyListenerKey_ = null;
    }
    if (this.viewChangeListenerKey_) {
      unlistenByKey(this.viewChangeListenerKey_);
      this.viewChangeListenerKey_ = null;
    }
    const view = this.getView();
    if (view) {
      this.updateViewportSize_(this.getSize());
      this.viewPropertyListenerKey_ = listen(
        view,
        ObjectEventType_default.PROPERTYCHANGE,
        this.handleViewPropertyChanged_,
        this
      );
      this.viewChangeListenerKey_ = listen(
        view,
        EventType_default.CHANGE,
        this.handleViewPropertyChanged_,
        this
      );
      view.resolveConstraints(0);
    }
    this.render();
  }
  /**
   * @private
   */
  handleLayerGroupChanged_() {
    if (this.layerGroupPropertyListenerKeys_) {
      this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);
      this.layerGroupPropertyListenerKeys_ = null;
    }
    const layerGroup = this.getLayerGroup();
    if (layerGroup) {
      this.handleLayerAdd_(new GroupEvent("addlayer", layerGroup));
      this.layerGroupPropertyListenerKeys_ = [
        listen(layerGroup, ObjectEventType_default.PROPERTYCHANGE, this.render, this),
        listen(layerGroup, EventType_default.CHANGE, this.render, this),
        listen(layerGroup, "addlayer", this.handleLayerAdd_, this),
        listen(layerGroup, "removelayer", this.handleLayerRemove_, this)
      ];
    }
    this.render();
  }
  /**
   * @return {boolean} Is rendered.
   */
  isRendered() {
    return !!this.frameState_;
  }
  /**
   * @private
   */
  animationDelay_() {
    this.animationDelayKey_ = void 0;
    this.renderFrame_(Date.now());
  }
  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  renderSync() {
    if (this.animationDelayKey_) {
      cancelAnimationFrame(this.animationDelayKey_);
    }
    this.animationDelay_();
  }
  /**
   * Redraws all text after new fonts have loaded
   */
  redrawText() {
    const layerStates = this.getLayerGroup().getLayerStatesArray();
    for (let i = 0, ii = layerStates.length; i < ii; ++i) {
      const layer = layerStates[i].layer;
      if (layer.hasRenderer()) {
        layer.getRenderer().handleFontsChanged();
      }
    }
  }
  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  render() {
    if (this.renderer_ && this.animationDelayKey_ === void 0) {
      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
    }
  }
  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  removeControl(control) {
    return this.getControls().remove(control);
  }
  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  removeInteraction(interaction) {
    return this.getInteractions().remove(interaction);
  }
  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  removeLayer(layer) {
    const layers = this.getLayerGroup().getLayers();
    return layers.remove(layer);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */
  handleLayerRemove_(event) {
    removeLayerMapProperty(event.layer);
  }
  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  removeOverlay(overlay) {
    return this.getOverlays().remove(overlay);
  }
  /**
   * @param {number} time Time.
   * @private
   */
  renderFrame_(time) {
    const size = this.getSize();
    const view = this.getView();
    const previousFrameState = this.frameState_;
    let frameState = null;
    if (size !== void 0 && hasArea(size) && view && view.isDef()) {
      const viewHints = view.getHints(
        this.frameState_ ? this.frameState_.viewHints : void 0
      );
      const viewState = view.getState();
      frameState = {
        animate: false,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutter: null,
        extent: getForViewAndSize(
          viewState.center,
          viewState.resolution,
          viewState.rotation,
          size
        ),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size,
        tileQueue: this.tileQueue_,
        time,
        usedTiles: {},
        viewState,
        viewHints,
        wantedTiles: {},
        mapId: getUid(this),
        renderTargets: {}
      };
      if (viewState.nextCenter && viewState.nextResolution) {
        const rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;
        frameState.nextExtent = getForViewAndSize(
          viewState.nextCenter,
          viewState.nextResolution,
          rotation,
          size
        );
      }
    }
    this.frameState_ = frameState;
    this.renderer_.renderFrame(frameState);
    if (frameState) {
      if (frameState.animate) {
        this.render();
      }
      Array.prototype.push.apply(
        this.postRenderFunctions_,
        frameState.postRenderFunctions
      );
      if (previousFrameState) {
        const moveStart = !this.previousExtent_ || !isEmpty2(this.previousExtent_) && !equals2(frameState.extent, this.previousExtent_);
        if (moveStart) {
          this.dispatchEvent(
            new MapEvent_default(MapEventType_default.MOVESTART, this, previousFrameState)
          );
          this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);
        }
      }
      const idle = this.previousExtent_ && !frameState.viewHints[ViewHint_default.ANIMATING] && !frameState.viewHints[ViewHint_default.INTERACTING] && !equals2(frameState.extent, this.previousExtent_);
      if (idle) {
        this.dispatchEvent(
          new MapEvent_default(MapEventType_default.MOVEEND, this, frameState)
        );
        clone(frameState.extent, this.previousExtent_);
      }
    }
    this.dispatchEvent(new MapEvent_default(MapEventType_default.POSTRENDER, this, frameState));
    this.renderComplete_ = (this.hasListener(MapEventType_default.LOADSTART) || this.hasListener(MapEventType_default.LOADEND) || this.hasListener(EventType_default3.RENDERCOMPLETE)) && !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady();
    if (!this.postRenderTimeoutHandle_) {
      this.postRenderTimeoutHandle_ = setTimeout(() => {
        this.postRenderTimeoutHandle_ = void 0;
        this.handlePostRender();
      }, 0);
    }
  }
  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  setLayerGroup(layerGroup) {
    const oldLayerGroup = this.getLayerGroup();
    if (oldLayerGroup) {
      this.handleLayerRemove_(new GroupEvent("removelayer", oldLayerGroup));
    }
    this.set(MapProperty_default.LAYERGROUP, layerGroup);
  }
  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  setSize(size) {
    this.set(MapProperty_default.SIZE, size);
  }
  /**
   * Set the target element to render this map into.
   * For accessibility (focus and keyboard events for map navigation), the `target` element must have a
   *  properly configured `tabindex` attribute. If the `target` element is inside a Shadow DOM, the
   *  `tabindex` atribute must be set on the custom element's host element.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  setTarget(target) {
    this.set(MapProperty_default.TARGET, target);
  }
  /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>|null} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */
  setView(view) {
    if (!view || view instanceof View_default) {
      this.set(MapProperty_default.VIEW, view);
      return;
    }
    this.set(MapProperty_default.VIEW, new View_default());
    const map = this;
    view.then(function(viewOptions) {
      map.setView(new View_default(viewOptions));
    });
  }
  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  updateSize() {
    const targetElement = this.getTargetElement();
    let size = void 0;
    if (targetElement) {
      const computedStyle = getComputedStyle(targetElement);
      const width = targetElement.offsetWidth - parseFloat(computedStyle["borderLeftWidth"]) - parseFloat(computedStyle["paddingLeft"]) - parseFloat(computedStyle["paddingRight"]) - parseFloat(computedStyle["borderRightWidth"]);
      const height = targetElement.offsetHeight - parseFloat(computedStyle["borderTopWidth"]) - parseFloat(computedStyle["paddingTop"]) - parseFloat(computedStyle["paddingBottom"]) - parseFloat(computedStyle["borderBottomWidth"]);
      if (!isNaN(width) && !isNaN(height)) {
        size = [Math.max(0, width), Math.max(0, height)];
        if (!hasArea(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) {
          warn(
            "No map visible because the map container's width or height are 0."
          );
        }
      }
    }
    const oldSize = this.getSize();
    if (size && (!oldSize || !equals(size, oldSize))) {
      this.setSize(size);
      this.updateViewportSize_(size);
    }
  }
  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @param {import("./size.js").Size|undefined} size The size.
   * @private
   */
  updateViewportSize_(size) {
    const view = this.getView();
    if (view) {
      view.setViewportSize(size);
    }
  }
};
function createOptionsInternal(options) {
  let keyboardEventTarget = null;
  if (options.keyboardEventTarget !== void 0) {
    keyboardEventTarget = typeof options.keyboardEventTarget === "string" ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
  }
  const values = {};
  const layerGroup = options.layers && typeof /** @type {?} */
  options.layers.getLayers === "function" ? (
    /** @type {LayerGroup} */
    options.layers
  ) : new Group_default({
    layers: (
      /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
      options.layers
    )
  });
  values[MapProperty_default.LAYERGROUP] = layerGroup;
  values[MapProperty_default.TARGET] = options.target;
  values[MapProperty_default.VIEW] = options.view instanceof View_default ? options.view : new View_default();
  let controls;
  if (options.controls !== void 0) {
    if (Array.isArray(options.controls)) {
      controls = new Collection_default(options.controls.slice());
    } else {
      assert(
        typeof /** @type {?} */
        options.controls.getArray === "function",
        "Expected `controls` to be an array or an `ol/Collection.js`"
      );
      controls = options.controls;
    }
  }
  let interactions;
  if (options.interactions !== void 0) {
    if (Array.isArray(options.interactions)) {
      interactions = new Collection_default(options.interactions.slice());
    } else {
      assert(
        typeof /** @type {?} */
        options.interactions.getArray === "function",
        "Expected `interactions` to be an array or an `ol/Collection.js`"
      );
      interactions = options.interactions;
    }
  }
  let overlays;
  if (options.overlays !== void 0) {
    if (Array.isArray(options.overlays)) {
      overlays = new Collection_default(options.overlays.slice());
    } else {
      assert(
        typeof /** @type {?} */
        options.overlays.getArray === "function",
        "Expected `overlays` to be an array or an `ol/Collection.js`"
      );
      overlays = options.overlays;
    }
  } else {
    overlays = new Collection_default();
  }
  return {
    controls,
    interactions,
    keyboardEventTarget,
    overlays,
    values
  };
}
var Map_default2 = Map;

// node_modules/ol/TileRange.js
var TileRange = class {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  constructor(minX, maxX, minY, maxY) {
    this.minX = minX;
    this.maxX = maxX;
    this.minY = minY;
    this.maxY = maxY;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  contains(tileCoord) {
    return this.containsXY(tileCoord[1], tileCoord[2]);
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */
  containsTileRange(tileRange) {
    return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
  }
  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */
  containsXY(x, y) {
    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */
  equals(tileRange) {
    return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   */
  extend(tileRange) {
    if (tileRange.minX < this.minX) {
      this.minX = tileRange.minX;
    }
    if (tileRange.maxX > this.maxX) {
      this.maxX = tileRange.maxX;
    }
    if (tileRange.minY < this.minY) {
      this.minY = tileRange.minY;
    }
    if (tileRange.maxY > this.maxY) {
      this.maxY = tileRange.maxY;
    }
  }
  /**
   * @return {number} Height.
   */
  getHeight() {
    return this.maxY - this.minY + 1;
  }
  /**
   * @return {import("./size.js").Size} Size.
   */
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }
  /**
   * @return {number} Width.
   */
  getWidth() {
    return this.maxX - this.minX + 1;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */
  intersects(tileRange) {
    return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
  }
};
function createOrUpdate2(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== void 0) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  }
  return new TileRange(minX, maxX, minY, maxY);
}
var TileRange_default = TileRange;

// node_modules/ol/tilecoord.js
function createOrUpdate3(z, x, y, tileCoord) {
  if (tileCoord !== void 0) {
    tileCoord[0] = z;
    tileCoord[1] = x;
    tileCoord[2] = y;
    return tileCoord;
  }
  return [z, x, y];
}
function getKeyZXY(z, x, y) {
  return z + "/" + x + "/" + y;
}
function hash(tileCoord) {
  return hashZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}
function hashZXY(z, x, y) {
  return (x << z) + y;
}
function withinExtentAndZ(tileCoord, tileGrid) {
  const z = tileCoord[0];
  const x = tileCoord[1];
  const y = tileCoord[2];
  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  const tileRange = tileGrid.getFullTileRange(z);
  if (!tileRange) {
    return true;
  }
  return tileRange.containsXY(x, y);
}

// node_modules/ol/tilegrid/TileGrid.js
var tmpTileCoord = [0, 0, 0];
var DECIMALS = 5;
var TileGrid = class {
  /**
   * @param {Options} options Tile grid options.
   */
  constructor(options) {
    this.minZoom = options.minZoom !== void 0 ? options.minZoom : 0;
    this.resolutions_ = options.resolutions;
    assert(
      isSorted(
        this.resolutions_,
        /**
         * @param {number} a First resolution
         * @param {number} b Second resolution
         * @return {number} Comparison result
         */
        (a, b) => b - a,
        true
      ),
      "`resolutions` must be sorted in descending order"
    );
    let zoomFactor;
    if (!options.origins) {
      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
        if (!zoomFactor) {
          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
        } else {
          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
            zoomFactor = void 0;
            break;
          }
        }
      }
    }
    this.zoomFactor_ = zoomFactor;
    this.maxZoom = this.resolutions_.length - 1;
    this.origin_ = options.origin !== void 0 ? options.origin : null;
    this.origins_ = null;
    if (options.origins !== void 0) {
      this.origins_ = options.origins;
      assert(
        this.origins_.length == this.resolutions_.length,
        "Number of `origins` and `resolutions` must be equal"
      );
    }
    const extent = options.extent;
    if (extent !== void 0 && !this.origin_ && !this.origins_) {
      this.origin_ = getTopLeft(extent);
    }
    assert(
      !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
      "Either `origin` or `origins` must be configured, never both"
    );
    this.tileSizes_ = null;
    if (options.tileSizes !== void 0) {
      this.tileSizes_ = options.tileSizes;
      assert(
        this.tileSizes_.length == this.resolutions_.length,
        "Number of `tileSizes` and `resolutions` must be equal"
      );
    }
    this.tileSize_ = options.tileSize !== void 0 ? options.tileSize : !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;
    assert(
      !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
      "Either `tileSize` or `tileSizes` must be configured, never both"
    );
    this.extent_ = extent !== void 0 ? extent : null;
    this.fullTileRanges_ = null;
    this.tmpSize_ = [0, 0];
    this.tmpExtent_ = [0, 0, 0, 0];
    if (options.sizes !== void 0) {
      this.fullTileRanges_ = options.sizes.map((size, z) => {
        const tileRange = new TileRange_default(
          Math.min(0, size[0]),
          Math.max(size[0] - 1, -1),
          Math.min(0, size[1]),
          Math.max(size[1] - 1, -1)
        );
        if (extent) {
          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
        }
        return tileRange;
      });
    } else if (extent) {
      this.calculateTileRanges_(extent);
    }
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  forEachTileCoord(extent, zoom, callback) {
    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
        callback([zoom, i, j]);
      }
    }
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */
  forEachTileCoordParentTileRange(tileCoord, callback, tempTileRange, tempExtent) {
    let tileRange, x, y;
    let tileCoordExtent = null;
    let z = tileCoord[0] - 1;
    if (this.zoomFactor_ === 2) {
      x = tileCoord[1];
      y = tileCoord[2];
    } else {
      tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);
    }
    while (z >= this.minZoom) {
      if (x !== void 0 && y !== void 0) {
        x = Math.floor(x / 2);
        y = Math.floor(y / 2);
        tileRange = createOrUpdate2(x, x, y, y, tempTileRange);
      } else {
        tileRange = this.getTileRangeForExtentAndZ(
          tileCoordExtent,
          z,
          tempTileRange
        );
      }
      if (callback(z, tileRange)) {
        return true;
      }
      --z;
    }
    return false;
  }
  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */
  getMaxZoom() {
    return this.maxZoom;
  }
  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */
  getMinZoom() {
    return this.minZoom;
  }
  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */
  getOrigin(z) {
    if (this.origin_) {
      return this.origin_;
    }
    return this.origins_[z];
  }
  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */
  getResolution(z) {
    return this.resolutions_[z];
  }
  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {
    if (tileCoord[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const minX = tileCoord[1] * 2;
        const minY = tileCoord[2] * 2;
        return createOrUpdate2(
          minX,
          minX + 1,
          minY,
          minY + 1,
          tempTileRange
        );
      }
      const tileCoordExtent = this.getTileCoordExtent(
        tileCoord,
        tempExtent || this.tmpExtent_
      );
      return this.getTileRangeForExtentAndZ(
        tileCoordExtent,
        tileCoord[0] + 1,
        tempTileRange
      );
    }
    return null;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {
    if (z > this.maxZoom || z < this.minZoom) {
      return null;
    }
    const tileCoordZ = tileCoord[0];
    const tileCoordX = tileCoord[1];
    const tileCoordY = tileCoord[2];
    if (z === tileCoordZ) {
      return createOrUpdate2(
        tileCoordX,
        tileCoordY,
        tileCoordX,
        tileCoordY,
        tempTileRange
      );
    }
    if (this.zoomFactor_) {
      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
      const minX = Math.floor(tileCoordX * factor);
      const minY = Math.floor(tileCoordY * factor);
      if (z < tileCoordZ) {
        return createOrUpdate2(minX, minX, minY, minY, tempTileRange);
      }
      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
      return createOrUpdate2(minX, maxX, minY, maxY, tempTileRange);
    }
    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
  }
  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */
  getTileRangeForExtentAndZ(extent, z, tempTileRange) {
    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tmpTileCoord);
    const minX = tmpTileCoord[1];
    const minY = tmpTileCoord[2];
    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tmpTileCoord);
    const maxX = tmpTileCoord[1];
    const maxY = tmpTileCoord[2];
    return createOrUpdate2(minX, maxX, minY, maxY, tempTileRange);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */
  getTileCoordCenter(tileCoord) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
    return [
      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution
    ];
  }
  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getTileCoordExtent(tileCoord, tempExtent) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
    const maxX = minX + tileSize[0] * resolution;
    const maxY = minY + tileSize[1] * resolution;
    return createOrUpdate(minX, minY, maxX, maxY, tempExtent);
  }
  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {
    return this.getTileCoordForXYAndResolution_(
      coordinate[0],
      coordinate[1],
      resolution,
      false,
      opt_tileCoord
    );
  }
  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndResolution_(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
    const z = this.getZForResolution(resolution);
    const scale4 = resolution / this.getResolution(z);
    const origin = this.getOrigin(z);
    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);
    let tileCoordX = scale4 * (x - origin[0]) / resolution / tileSize[0];
    let tileCoordY = scale4 * (origin[1] - y) / resolution / tileSize[1];
    if (reverseIntersectionPolicy) {
      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = floor(tileCoordX, DECIMALS);
      tileCoordY = floor(tileCoordY, DECIMALS);
    }
    return createOrUpdate3(z, tileCoordX, tileCoordY, opt_tileCoord);
  }
  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
    const origin = this.getOrigin(z);
    const resolution = this.getResolution(z);
    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);
    let tileCoordX = (x - origin[0]) / resolution / tileSize[0];
    let tileCoordY = (origin[1] - y) / resolution / tileSize[1];
    if (reverseIntersectionPolicy) {
      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = floor(tileCoordX, DECIMALS);
      tileCoordY = floor(tileCoordY, DECIMALS);
    }
    return createOrUpdate3(z, tileCoordX, tileCoordY, opt_tileCoord);
  }
  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {
    return this.getTileCoordForXYAndZ_(
      coordinate[0],
      coordinate[1],
      z,
      false,
      opt_tileCoord
    );
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */
  getTileCoordResolution(tileCoord) {
    return this.resolutions_[tileCoord[0]];
  }
  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */
  getTileSize(z) {
    if (this.tileSize_) {
      return this.tileSize_;
    }
    return this.tileSizes_[z];
  }
  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
   */
  getFullTileRange(z) {
    if (!this.fullTileRanges_) {
      return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;
    }
    return this.fullTileRanges_[z];
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */
  getZForResolution(resolution, opt_direction) {
    const z = linearFindNearest(
      this.resolutions_,
      resolution,
      opt_direction || 0
    );
    return clamp(z, this.minZoom, this.maxZoom);
  }
  /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */
  tileCoordIntersectsViewport(tileCoord, viewport) {
    return intersectsLinearRing(
      viewport,
      0,
      viewport.length,
      2,
      this.getTileCoordExtent(tileCoord)
    );
  }
  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */
  calculateTileRanges_(extent) {
    const length = this.resolutions_.length;
    const fullTileRanges = new Array(length);
    for (let z = this.minZoom; z < length; ++z) {
      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
    }
    this.fullTileRanges_ = fullTileRanges;
  }
};
var TileGrid_default = TileGrid;

// node_modules/ol/tilegrid/WMTS.js
var WMTSTileGrid = class extends TileGrid_default {
  /**
   * @param {Options} options WMTS options.
   */
  constructor(options) {
    super({
      extent: options.extent,
      origin: options.origin,
      origins: options.origins,
      resolutions: options.resolutions,
      tileSize: options.tileSize,
      tileSizes: options.tileSizes,
      sizes: options.sizes
    });
    this.matrixIds_ = options.matrixIds;
  }
  /**
   * @param {number} z Z.
   * @return {string} MatrixId..
   */
  getMatrixId(z) {
    return this.matrixIds_[z];
  }
  /**
   * Get the list of matrix identifiers.
   * @return {Array<string>} MatrixIds.
   * @api
   */
  getMatrixIds() {
    return this.matrixIds_;
  }
};
var WMTS_default = WMTSTileGrid;

// src/Map.js
var import_proj42 = __toESM(require_proj4(), 1);

// node_modules/ol/proj/proj4.js
var registered = null;
function register(proj42) {
  registered = proj42;
  const projCodes = Object.keys(proj42.defs);
  const len = projCodes.length;
  let i, j;
  for (i = 0; i < len; ++i) {
    const code = projCodes[i];
    if (!get(code)) {
      const def = proj42.defs(code);
      let units = (
        /** @type {import("./Units.js").Units} */
        def.units
      );
      if (!units && def.projName === "longlat") {
        units = "degrees";
      }
      addProjection(
        new Projection_default({
          code,
          axisOrientation: def.axis,
          metersPerUnit: def.to_meter,
          units
        })
      );
    }
  }
  for (i = 0; i < len; ++i) {
    const code1 = projCodes[i];
    const proj1 = get(code1);
    for (j = 0; j < len; ++j) {
      const code2 = projCodes[j];
      const proj2 = get(code2);
      if (!get2(code1, code2)) {
        if (proj42.defs[code1] === proj42.defs[code2]) {
          addEquivalentProjections([proj1, proj2]);
        } else {
          const transform2 = proj42(code1, code2);
          addCoordinateTransforms(
            proj1,
            proj2,
            createSafeCoordinateTransform(proj1, proj2, transform2.forward),
            createSafeCoordinateTransform(proj2, proj1, transform2.inverse)
          );
        }
      }
    }
  }
}

// node_modules/ol/control/FullScreen.js
var events = ["fullscreenchange", "webkitfullscreenchange"];
var FullScreenEventType = {
  /**
   * Triggered after the map entered fullscreen.
   * @event FullScreenEventType#enterfullscreen
   * @api
   */
  ENTERFULLSCREEN: "enterfullscreen",
  /**
   * Triggered after the map leave fullscreen.
   * @event FullScreenEventType#leavefullscreen
   * @api
   */
  LEAVEFULLSCREEN: "leavefullscreen"
};
var FullScreen = class extends Control_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      target: options.target
    });
    this.on;
    this.once;
    this.un;
    this.keys_ = options.keys !== void 0 ? options.keys : false;
    this.source_ = options.source;
    this.isInFullscreen_ = false;
    this.boundHandleMapTargetChange_ = this.handleMapTargetChange_.bind(this);
    this.cssClassName_ = options.className !== void 0 ? options.className : "ol-full-screen";
    this.documentListeners_ = [];
    this.activeClassName_ = options.activeClassName !== void 0 ? options.activeClassName.split(" ") : [this.cssClassName_ + "-true"];
    this.inactiveClassName_ = options.inactiveClassName !== void 0 ? options.inactiveClassName.split(" ") : [this.cssClassName_ + "-false"];
    const label = options.label !== void 0 ? options.label : "\u2922";
    this.labelNode_ = typeof label === "string" ? document.createTextNode(label) : label;
    const labelActive = options.labelActive !== void 0 ? options.labelActive : "\xD7";
    this.labelActiveNode_ = typeof labelActive === "string" ? document.createTextNode(labelActive) : labelActive;
    const tipLabel = options.tipLabel ? options.tipLabel : "Toggle full-screen";
    this.button_ = document.createElement("button");
    this.button_.title = tipLabel;
    this.button_.setAttribute("type", "button");
    this.button_.appendChild(this.labelNode_);
    this.button_.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this),
      false
    );
    this.setClassName_(this.button_, this.isInFullscreen_);
    this.element.className = `${this.cssClassName_} ${CLASS_UNSELECTABLE} ${CLASS_CONTROL}`;
    this.element.appendChild(this.button_);
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(event) {
    event.preventDefault();
    this.handleFullScreen_();
  }
  /**
   * @private
   */
  handleFullScreen_() {
    const map = this.getMap();
    if (!map) {
      return;
    }
    const doc = map.getOwnerDocument();
    if (!isFullScreenSupported(doc)) {
      return;
    }
    if (isFullScreen(doc)) {
      exitFullScreen(doc);
    } else {
      let element;
      if (this.source_) {
        element = typeof this.source_ === "string" ? doc.getElementById(this.source_) : this.source_;
      } else {
        element = map.getTargetElement();
      }
      if (this.keys_) {
        requestFullScreenWithKeys(element);
      } else {
        requestFullScreen(element);
      }
    }
  }
  /**
   * @private
   */
  handleFullScreenChange_() {
    const map = this.getMap();
    if (!map) {
      return;
    }
    const wasInFullscreen = this.isInFullscreen_;
    this.isInFullscreen_ = isFullScreen(map.getOwnerDocument());
    if (wasInFullscreen !== this.isInFullscreen_) {
      this.setClassName_(this.button_, this.isInFullscreen_);
      if (this.isInFullscreen_) {
        replaceNode(this.labelActiveNode_, this.labelNode_);
        this.dispatchEvent(FullScreenEventType.ENTERFULLSCREEN);
      } else {
        replaceNode(this.labelNode_, this.labelActiveNode_);
        this.dispatchEvent(FullScreenEventType.LEAVEFULLSCREEN);
      }
      map.updateSize();
    }
  }
  /**
   * @param {HTMLElement} element Target element
   * @param {boolean} fullscreen True if fullscreen class name should be active
   * @private
   */
  setClassName_(element, fullscreen) {
    if (fullscreen) {
      element.classList.remove(...this.inactiveClassName_);
      element.classList.add(...this.activeClassName_);
    } else {
      element.classList.remove(...this.activeClassName_);
      element.classList.add(...this.inactiveClassName_);
    }
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   * @override
   */
  setMap(map) {
    const oldMap = this.getMap();
    if (oldMap) {
      oldMap.removeChangeListener(
        MapProperty_default.TARGET,
        this.boundHandleMapTargetChange_
      );
    }
    super.setMap(map);
    this.handleMapTargetChange_();
    if (map) {
      map.addChangeListener(
        MapProperty_default.TARGET,
        this.boundHandleMapTargetChange_
      );
    }
  }
  /**
   * @private
   */
  handleMapTargetChange_() {
    const listeners = this.documentListeners_;
    for (let i = 0, ii = listeners.length; i < ii; ++i) {
      unlistenByKey(listeners[i]);
    }
    listeners.length = 0;
    const map = this.getMap();
    if (map) {
      const doc = map.getOwnerDocument();
      if (isFullScreenSupported(doc)) {
        this.element.classList.remove(CLASS_UNSUPPORTED);
      } else {
        this.element.classList.add(CLASS_UNSUPPORTED);
      }
      for (let i = 0, ii = events.length; i < ii; ++i) {
        listeners.push(
          listen(doc, events[i], this.handleFullScreenChange_, this)
        );
      }
      this.handleFullScreenChange_();
    }
  }
};
function isFullScreenSupported(doc) {
  const body = doc.body;
  return !!(body["webkitRequestFullscreen"] || body.requestFullscreen && doc.fullscreenEnabled);
}
function isFullScreen(doc) {
  return !!(doc["webkitIsFullScreen"] || doc.fullscreenElement);
}
function requestFullScreen(element) {
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else if (element["webkitRequestFullscreen"]) {
    element["webkitRequestFullscreen"]();
  }
}
function requestFullScreenWithKeys(element) {
  if (element["webkitRequestFullscreen"]) {
    element["webkitRequestFullscreen"]();
  } else {
    requestFullScreen(element);
  }
}
function exitFullScreen(doc) {
  if (doc.exitFullscreen) {
    doc.exitFullscreen();
  } else if (doc["webkitExitFullscreen"]) {
    doc["webkitExitFullscreen"]();
  }
}
var FullScreen_default = FullScreen;

// node_modules/ol/Overlay.js
var Property4 = {
  ELEMENT: "element",
  MAP: "map",
  OFFSET: "offset",
  POSITION: "position",
  POSITIONING: "positioning"
};
var Overlay = class extends Object_default {
  /**
   * @param {Options} options Overlay options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    this.options = options;
    this.id = options.id;
    this.insertFirst = options.insertFirst !== void 0 ? options.insertFirst : true;
    this.stopEvent = options.stopEvent !== void 0 ? options.stopEvent : true;
    this.element = document.createElement("div");
    this.element.className = options.className !== void 0 ? options.className : "ol-overlay-container " + CLASS_SELECTABLE;
    this.element.style.position = "absolute";
    this.element.style.pointerEvents = "auto";
    this.autoPan = options.autoPan === true ? {} : options.autoPan || void 0;
    this.rendered = {
      transform_: "",
      visible: true
    };
    this.mapPostrenderListenerKey = null;
    this.addChangeListener(Property4.ELEMENT, this.handleElementChanged);
    this.addChangeListener(Property4.MAP, this.handleMapChanged);
    this.addChangeListener(Property4.OFFSET, this.handleOffsetChanged);
    this.addChangeListener(Property4.POSITION, this.handlePositionChanged);
    this.addChangeListener(Property4.POSITIONING, this.handlePositioningChanged);
    if (options.element !== void 0) {
      this.setElement(options.element);
    }
    this.setOffset(options.offset !== void 0 ? options.offset : [0, 0]);
    this.setPositioning(options.positioning || "top-left");
    if (options.position !== void 0) {
      this.setPosition(options.position);
    }
  }
  /**
   * Get the DOM element of this overlay.
   * @return {HTMLElement|undefined} The Element containing the overlay.
   * @observable
   * @api
   */
  getElement() {
    return (
      /** @type {HTMLElement|undefined} */
      this.get(Property4.ELEMENT)
    );
  }
  /**
   * Get the overlay identifier which is set on constructor.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id;
  }
  /**
   * Get the map associated with this overlay.
   * @return {import("./Map.js").default|null} The map that the
   * overlay is part of.
   * @observable
   * @api
   */
  getMap() {
    return (
      /** @type {import("./Map.js").default|null} */
      this.get(Property4.MAP) || null
    );
  }
  /**
   * Get the offset of this overlay.
   * @return {Array<number>} The offset.
   * @observable
   * @api
   */
  getOffset() {
    return (
      /** @type {Array<number>} */
      this.get(Property4.OFFSET)
    );
  }
  /**
   * Get the current position of this overlay.
   * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
   *     anchored at.
   * @observable
   * @api
   */
  getPosition() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(Property4.POSITION)
    );
  }
  /**
   * Get the current positioning of this overlay.
   * @return {Positioning} How the overlay is positioned
   *     relative to its point on the map.
   * @observable
   * @api
   */
  getPositioning() {
    return (
      /** @type {Positioning} */
      this.get(Property4.POSITIONING)
    );
  }
  /**
   * @protected
   */
  handleElementChanged() {
    removeChildren(this.element);
    const element = this.getElement();
    if (element) {
      this.element.appendChild(element);
    }
  }
  /**
   * @protected
   */
  handleMapChanged() {
    if (this.mapPostrenderListenerKey) {
      this.element?.remove();
      unlistenByKey(this.mapPostrenderListenerKey);
      this.mapPostrenderListenerKey = null;
    }
    const map = this.getMap();
    if (map) {
      this.mapPostrenderListenerKey = listen(
        map,
        MapEventType_default.POSTRENDER,
        this.render,
        this
      );
      this.updatePixelPosition();
      const container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();
      if (this.insertFirst) {
        container.insertBefore(this.element, container.childNodes[0] || null);
      } else {
        container.appendChild(this.element);
      }
      this.performAutoPan();
    }
  }
  /**
   * @protected
   */
  render() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handleOffsetChanged() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handlePositionChanged() {
    this.updatePixelPosition();
    this.performAutoPan();
  }
  /**
   * @protected
   */
  handlePositioningChanged() {
    this.updatePixelPosition();
  }
  /**
   * Set the DOM element to be associated with this overlay.
   * @param {HTMLElement|undefined} element The Element containing the overlay.
   * @observable
   * @api
   */
  setElement(element) {
    this.set(Property4.ELEMENT, element);
  }
  /**
   * Set the map to be associated with this overlay.
   * @param {import("./Map.js").default|null} map The map that the
   * overlay is part of. Pass `null` to just remove the overlay from the current map.
   * @observable
   * @api
   */
  setMap(map) {
    this.set(Property4.MAP, map);
  }
  /**
   * Set the offset for this overlay.
   * @param {Array<number>} offset Offset.
   * @observable
   * @api
   */
  setOffset(offset) {
    this.set(Property4.OFFSET, offset);
  }
  /**
   * Set the position for this overlay. If the position is `undefined` the
   * overlay is hidden.
   * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
   *     is anchored at.
   * @observable
   * @api
   */
  setPosition(position) {
    this.set(Property4.POSITION, position);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary) using the configured autoPan parameters
   * @protected
   */
  performAutoPan() {
    if (this.autoPan) {
      this.panIntoView(this.autoPan);
    }
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary).
   * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action
   * @api
   */
  panIntoView(panIntoViewOptions) {
    const map = this.getMap();
    if (!map || !map.getTargetElement() || !this.get(Property4.POSITION)) {
      return;
    }
    const mapRect = this.getRect(map.getTargetElement(), map.getSize());
    const element = this.getElement();
    const overlayRect = this.getRect(element, [
      outerWidth(element),
      outerHeight(element)
    ]);
    panIntoViewOptions = panIntoViewOptions || {};
    const myMargin = panIntoViewOptions.margin === void 0 ? 20 : panIntoViewOptions.margin;
    if (!containsExtent(mapRect, overlayRect)) {
      const offsetLeft = overlayRect[0] - mapRect[0];
      const offsetRight = mapRect[2] - overlayRect[2];
      const offsetTop = overlayRect[1] - mapRect[1];
      const offsetBottom = mapRect[3] - overlayRect[3];
      const delta = [0, 0];
      if (offsetLeft < 0) {
        delta[0] = offsetLeft - myMargin;
      } else if (offsetRight < 0) {
        delta[0] = Math.abs(offsetRight) + myMargin;
      }
      if (offsetTop < 0) {
        delta[1] = offsetTop - myMargin;
      } else if (offsetBottom < 0) {
        delta[1] = Math.abs(offsetBottom) + myMargin;
      }
      if (delta[0] !== 0 || delta[1] !== 0) {
        const center = (
          /** @type {import("./coordinate.js").Coordinate} */
          map.getView().getCenterInternal()
        );
        const centerPx = map.getPixelFromCoordinateInternal(center);
        if (!centerPx) {
          return;
        }
        const newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];
        const panOptions = panIntoViewOptions.animation || {};
        map.getView().animateInternal({
          center: map.getCoordinateFromPixelInternal(newCenterPx),
          duration: panOptions.duration,
          easing: panOptions.easing
        });
      }
    }
  }
  /**
   * Get the extent of an element relative to the document
   * @param {HTMLElement} element The element.
   * @param {import("./size.js").Size} size The size of the element.
   * @return {import("./extent.js").Extent} The extent.
   * @protected
   */
  getRect(element, size) {
    const box = element.getBoundingClientRect();
    const offsetX = box.left + window.pageXOffset;
    const offsetY = box.top + window.pageYOffset;
    return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];
  }
  /**
   * Set the positioning for this overlay.
   * @param {Positioning} positioning how the overlay is
   *     positioned relative to its point on the map.
   * @observable
   * @api
   */
  setPositioning(positioning) {
    this.set(Property4.POSITIONING, positioning);
  }
  /**
   * Modify the visibility of the element.
   * @param {boolean} visible Element visibility.
   * @protected
   */
  setVisible(visible) {
    if (this.rendered.visible !== visible) {
      this.element.style.display = visible ? "" : "none";
      this.rendered.visible = visible;
    }
  }
  /**
   * Update pixel position.
   * @protected
   */
  updatePixelPosition() {
    const map = this.getMap();
    const position = this.getPosition();
    if (!map || !map.isRendered() || !position) {
      this.setVisible(false);
      return;
    }
    const pixel = map.getPixelFromCoordinate(position);
    const mapSize = map.getSize();
    this.updateRenderedPosition(pixel, mapSize);
  }
  /**
   * @param {import("./pixel.js").Pixel} pixel The pixel location.
   * @param {import("./size.js").Size|undefined} mapSize The map size.
   * @protected
   */
  updateRenderedPosition(pixel, mapSize) {
    const style = this.element.style;
    const offset = this.getOffset();
    const positioning = this.getPositioning();
    this.setVisible(true);
    const x = Math.round(pixel[0] + offset[0]) + "px";
    const y = Math.round(pixel[1] + offset[1]) + "px";
    let posX = "0%";
    let posY = "0%";
    if (positioning == "bottom-right" || positioning == "center-right" || positioning == "top-right") {
      posX = "-100%";
    } else if (positioning == "bottom-center" || positioning == "center-center" || positioning == "top-center") {
      posX = "-50%";
    }
    if (positioning == "bottom-left" || positioning == "bottom-center" || positioning == "bottom-right") {
      posY = "-100%";
    } else if (positioning == "center-left" || positioning == "center-center" || positioning == "center-right") {
      posY = "-50%";
    }
    const transform2 = `translate(${posX}, ${posY}) translate(${x}, ${y})`;
    if (this.rendered.transform_ != transform2) {
      this.rendered.transform_ = transform2;
      style.transform = transform2;
    }
  }
  /**
   * returns the options this Overlay has been created with
   * @return {Options} overlay options
   */
  getOptions() {
    return this.options;
  }
};
var Overlay_default = Overlay;

// node_modules/ol/control/ScaleLine.js
var UNITS_PROP = "units";
var LEADING_DIGITS = [1, 2, 5];
var DEFAULT_DPI = 25.4 / 0.28;
var ScaleLine = class extends Control_default {
  /**
   * @param {Options} [options] Scale line options.
   */
  constructor(options) {
    options = options ? options : {};
    const element = document.createElement("div");
    element.style.pointerEvents = "none";
    super({
      element,
      render: options.render,
      target: options.target
    });
    this.on;
    this.once;
    this.un;
    const className = options.className !== void 0 ? options.className : options.bar ? "ol-scale-bar" : "ol-scale-line";
    this.innerElement_ = document.createElement("div");
    this.innerElement_.className = className + "-inner";
    this.element.className = className + " " + CLASS_UNSELECTABLE;
    this.element.appendChild(this.innerElement_);
    this.viewState_ = null;
    this.minWidth_ = options.minWidth !== void 0 ? options.minWidth : 64;
    this.maxWidth_ = options.maxWidth;
    this.renderedVisible_ = false;
    this.renderedWidth_ = void 0;
    this.renderedHTML_ = "";
    this.addChangeListener(UNITS_PROP, this.handleUnitsChanged_);
    this.setUnits(options.units || "metric");
    this.scaleBar_ = options.bar || false;
    this.scaleBarSteps_ = options.steps || 4;
    this.scaleBarText_ = options.text || false;
    this.dpi_ = options.dpi || void 0;
  }
  /**
   * Return the units to use in the scale line.
   * @return {Units} The units
   * to use in the scale line.
   * @observable
   * @api
   */
  getUnits() {
    return this.get(UNITS_PROP);
  }
  /**
   * @private
   */
  handleUnitsChanged_() {
    this.updateElement_();
  }
  /**
   * Set the units to use in the scale line.
   * @param {Units} units The units to use in the scale line.
   * @observable
   * @api
   */
  setUnits(units) {
    this.set(UNITS_PROP, units);
  }
  /**
   * Specify the dpi of output device such as printer.
   * @param {number|undefined} dpi The dpi of output device.
   * @api
   */
  setDpi(dpi) {
    this.dpi_ = dpi;
  }
  /**
   * @private
   */
  updateElement_() {
    const viewState = this.viewState_;
    if (!viewState) {
      if (this.renderedVisible_) {
        this.element.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    const center = viewState.center;
    const projection = viewState.projection;
    const units = this.getUnits();
    const pointResolutionUnits = units == "degrees" ? "degrees" : "m";
    let pointResolution = getPointResolution(
      projection,
      viewState.resolution,
      center,
      pointResolutionUnits
    );
    const minWidth = this.minWidth_ * (this.dpi_ || DEFAULT_DPI) / DEFAULT_DPI;
    const maxWidth = this.maxWidth_ !== void 0 ? this.maxWidth_ * (this.dpi_ || DEFAULT_DPI) / DEFAULT_DPI : void 0;
    let nominalCount = minWidth * pointResolution;
    let suffix = "";
    if (units == "degrees") {
      const metersPerDegree = METERS_PER_UNIT.degrees;
      nominalCount *= metersPerDegree;
      if (nominalCount < metersPerDegree / 60) {
        suffix = "\u2033";
        pointResolution *= 3600;
      } else if (nominalCount < metersPerDegree) {
        suffix = "\u2032";
        pointResolution *= 60;
      } else {
        suffix = "\xB0";
      }
    } else if (units == "imperial") {
      if (nominalCount < 0.9144) {
        suffix = "in";
        pointResolution /= 0.0254;
      } else if (nominalCount < 1609.344) {
        suffix = "ft";
        pointResolution /= 0.3048;
      } else {
        suffix = "mi";
        pointResolution /= 1609.344;
      }
    } else if (units == "nautical") {
      pointResolution /= 1852;
      suffix = "NM";
    } else if (units == "metric") {
      if (nominalCount < 1e-6) {
        suffix = "nm";
        pointResolution *= 1e9;
      } else if (nominalCount < 1e-3) {
        suffix = "\u03BCm";
        pointResolution *= 1e6;
      } else if (nominalCount < 1) {
        suffix = "mm";
        pointResolution *= 1e3;
      } else if (nominalCount < 1e3) {
        suffix = "m";
      } else {
        suffix = "km";
        pointResolution /= 1e3;
      }
    } else if (units == "us") {
      if (nominalCount < 0.9144) {
        suffix = "in";
        pointResolution *= 39.37;
      } else if (nominalCount < 1609.344) {
        suffix = "ft";
        pointResolution /= 0.30480061;
      } else {
        suffix = "mi";
        pointResolution /= 1609.3472;
      }
    } else {
      throw new Error("Invalid units");
    }
    let i = 3 * Math.floor(Math.log(minWidth * pointResolution) / Math.log(10));
    let count, width, decimalCount;
    let previousCount = 0;
    let previousWidth, previousDecimalCount;
    while (true) {
      decimalCount = Math.floor(i / 3);
      const decimal = Math.pow(10, decimalCount);
      count = LEADING_DIGITS[(i % 3 + 3) % 3] * decimal;
      width = Math.round(count / pointResolution);
      if (isNaN(width)) {
        this.element.style.display = "none";
        this.renderedVisible_ = false;
        return;
      }
      if (maxWidth !== void 0 && width >= maxWidth) {
        count = previousCount;
        width = previousWidth;
        decimalCount = previousDecimalCount;
        break;
      } else if (width >= minWidth) {
        break;
      }
      previousCount = count;
      previousWidth = width;
      previousDecimalCount = decimalCount;
      ++i;
    }
    const html = this.scaleBar_ ? this.createScaleBar(width, count, suffix) : count.toFixed(decimalCount < 0 ? -decimalCount : 0) + " " + suffix;
    if (this.renderedHTML_ != html) {
      this.innerElement_.innerHTML = html;
      this.renderedHTML_ = html;
    }
    if (this.renderedWidth_ != width) {
      this.innerElement_.style.width = width + "px";
      this.renderedWidth_ = width;
    }
    if (!this.renderedVisible_) {
      this.element.style.display = "";
      this.renderedVisible_ = true;
    }
  }
  /**
   * @private
   * @param {number} width The current width of the scalebar.
   * @param {number} scale The current scale.
   * @param {string} suffix The suffix to append to the scale text.
   * @return {string} The stringified HTML of the scalebar.
   */
  createScaleBar(width, scale4, suffix) {
    const resolutionScale = this.getScaleForResolution();
    const mapScale = resolutionScale < 1 ? Math.round(1 / resolutionScale).toLocaleString() + " : 1" : "1 : " + Math.round(resolutionScale).toLocaleString();
    const steps = this.scaleBarSteps_;
    const stepWidth = width / steps;
    const scaleSteps = [this.createMarker("absolute")];
    for (let i = 0; i < steps; ++i) {
      const cls = i % 2 === 0 ? "ol-scale-singlebar-odd" : "ol-scale-singlebar-even";
      scaleSteps.push(
        `<div><div class="ol-scale-singlebar ${cls}" style="width: ${stepWidth}px;"></div>` + this.createMarker("relative") + // render text every second step, except when only 2 steps
        (i % 2 === 0 || steps === 2 ? this.createStepText(i, width, false, scale4, suffix) : "") + "</div>"
      );
    }
    scaleSteps.push(this.createStepText(steps, width, true, scale4, suffix));
    const scaleBarText = this.scaleBarText_ ? `<div class="ol-scale-text" style="width: ${width}px;">` + mapScale + "</div>" : "";
    return scaleBarText + scaleSteps.join("");
  }
  /**
   * Creates a marker at given position
   * @param {'absolute'|'relative'} position The position, absolute or relative
   * @return {string} The stringified div containing the marker
   */
  createMarker(position) {
    const top = position === "absolute" ? 3 : -10;
    return `<div class="ol-scale-step-marker" style="position: ${position}; top: ${top}px;"></div>`;
  }
  /**
   * Creates the label for a marker marker at given position
   * @param {number} i The iterator
   * @param {number} width The width the scalebar will currently use
   * @param {boolean} isLast Flag indicating if we add the last step text
   * @param {number} scale The current scale for the whole scalebar
   * @param {string} suffix The suffix for the scale
   * @return {string} The stringified div containing the step text
   */
  createStepText(i, width, isLast, scale4, suffix) {
    const length = i === 0 ? 0 : Math.round(scale4 / this.scaleBarSteps_ * i * 100) / 100;
    const lengthString = length + (i === 0 ? "" : " " + suffix);
    const margin = i === 0 ? -3 : width / this.scaleBarSteps_ * -1;
    const minWidth = i === 0 ? 0 : width / this.scaleBarSteps_ * 2;
    return `<div class="ol-scale-step-text" style="margin-left: ${margin}px;text-align: ${i === 0 ? "left" : "center"};min-width: ${minWidth}px;left: ${isLast ? width + "px" : "unset"};">` + lengthString + "</div>";
  }
  /**
   * Returns the appropriate scale for the given resolution and units.
   * @return {number} The appropriate scale.
   */
  getScaleForResolution() {
    const resolution = getPointResolution(
      this.viewState_.projection,
      this.viewState_.resolution,
      this.viewState_.center,
      "m"
    );
    const dpi = this.dpi_ || DEFAULT_DPI;
    const inchesPerMeter = 1e3 / 25.4;
    return resolution * inchesPerMeter * dpi;
  }
  /**
   * Update the scale line element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    const frameState = mapEvent.frameState;
    if (!frameState) {
      this.viewState_ = null;
    } else {
      this.viewState_ = frameState.viewState;
    }
    this.updateElement_();
  }
};
var ScaleLine_default = ScaleLine;

// node_modules/ol/control/ZoomSlider.js
var Direction = {
  VERTICAL: 0,
  HORIZONTAL: 1
};
var ZoomSlider = class extends Control_default {
  /**
   * @param {Options} [options] Zoom slider options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      target: options.target,
      element: document.createElement("div"),
      render: options.render
    });
    this.dragListenerKeys_ = [];
    this.currentResolution_ = void 0;
    this.direction_ = Direction.VERTICAL;
    this.dragging_;
    this.heightLimit_ = 0;
    this.widthLimit_ = 0;
    this.startX_;
    this.startY_;
    this.thumbSize_ = null;
    this.sliderInitialized_ = false;
    this.duration_ = options.duration !== void 0 ? options.duration : 200;
    const className = options.className !== void 0 ? options.className : "ol-zoomslider";
    const thumbElement = document.createElement("button");
    thumbElement.setAttribute("type", "button");
    thumbElement.className = className + "-thumb " + CLASS_UNSELECTABLE;
    const containerElement = this.element;
    containerElement.className = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    containerElement.appendChild(thumbElement);
    containerElement.addEventListener(
      EventType_default2.POINTERDOWN,
      this.handleDraggerStart_.bind(this),
      false
    );
    containerElement.addEventListener(
      EventType_default2.POINTERMOVE,
      this.handleDraggerDrag_.bind(this),
      false
    );
    containerElement.addEventListener(
      EventType_default2.POINTERUP,
      this.handleDraggerEnd_.bind(this),
      false
    );
    containerElement.addEventListener(
      EventType_default.CLICK,
      this.handleContainerClick_.bind(this),
      false
    );
    thumbElement.addEventListener(EventType_default.CLICK, stopPropagation, false);
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   * @override
   */
  setMap(map) {
    super.setMap(map);
    if (map) {
      map.render();
    }
  }
  /**
   * Initializes the slider element. This will determine and set this controls
   * direction_ and also constrain the dragging of the thumb to always be within
   * the bounds of the container.
   *
   * @return {boolean} Initialization successful
   * @private
   */
  initSlider_() {
    const container = this.element;
    let containerWidth = container.offsetWidth;
    let containerHeight = container.offsetHeight;
    if (containerWidth === 0 && containerHeight === 0) {
      return this.sliderInitialized_ = false;
    }
    const containerStyle = getComputedStyle(container);
    containerWidth -= parseFloat(containerStyle["paddingRight"]) + parseFloat(containerStyle["paddingLeft"]);
    containerHeight -= parseFloat(containerStyle["paddingTop"]) + parseFloat(containerStyle["paddingBottom"]);
    const thumb = (
      /** @type {HTMLElement} */
      container.firstElementChild
    );
    const thumbStyle = getComputedStyle(thumb);
    const thumbWidth = thumb.offsetWidth + parseFloat(thumbStyle["marginRight"]) + parseFloat(thumbStyle["marginLeft"]);
    const thumbHeight = thumb.offsetHeight + parseFloat(thumbStyle["marginTop"]) + parseFloat(thumbStyle["marginBottom"]);
    this.thumbSize_ = [thumbWidth, thumbHeight];
    if (containerWidth > containerHeight) {
      this.direction_ = Direction.HORIZONTAL;
      this.widthLimit_ = containerWidth - thumbWidth;
    } else {
      this.direction_ = Direction.VERTICAL;
      this.heightLimit_ = containerHeight - thumbHeight;
    }
    return this.sliderInitialized_ = true;
  }
  /**
   * @param {PointerEvent} event The browser event to handle.
   * @private
   */
  handleContainerClick_(event) {
    const view = this.getMap().getView();
    const relativePosition = this.getRelativePosition_(
      event.offsetX - this.thumbSize_[0] / 2,
      event.offsetY - this.thumbSize_[1] / 2
    );
    const resolution = this.getResolutionForPosition_(relativePosition);
    const zoom = view.getConstrainedZoom(view.getZoomForResolution(resolution));
    view.animateInternal({
      zoom,
      duration: this.duration_,
      easing: easeOut
    });
  }
  /**
   * Handle dragger start events.
   * @param {PointerEvent} event The drag event.
   * @private
   */
  handleDraggerStart_(event) {
    if (!this.dragging_ && event.target === this.element.firstElementChild) {
      const element = (
        /** @type {HTMLElement} */
        this.element.firstElementChild
      );
      this.getMap().getView().beginInteraction();
      this.startX_ = event.clientX - parseFloat(element.style.left);
      this.startY_ = event.clientY - parseFloat(element.style.top);
      this.dragging_ = true;
      if (this.dragListenerKeys_.length === 0) {
        const drag = this.handleDraggerDrag_;
        const end = this.handleDraggerEnd_;
        const doc = this.getMap().getOwnerDocument();
        this.dragListenerKeys_.push(
          listen(doc, EventType_default2.POINTERMOVE, drag, this),
          listen(doc, EventType_default2.POINTERUP, end, this)
        );
      }
    }
  }
  /**
   * Handle dragger drag events.
   *
   * @param {PointerEvent} event The drag event.
   * @private
   */
  handleDraggerDrag_(event) {
    if (this.dragging_) {
      const deltaX = event.clientX - this.startX_;
      const deltaY = event.clientY - this.startY_;
      const relativePosition = this.getRelativePosition_(deltaX, deltaY);
      this.currentResolution_ = this.getResolutionForPosition_(relativePosition);
      this.getMap().getView().setResolution(this.currentResolution_);
    }
  }
  /**
   * Handle dragger end events.
   * @param {PointerEvent} event The drag event.
   * @private
   */
  handleDraggerEnd_(event) {
    if (this.dragging_) {
      const view = this.getMap().getView();
      view.endInteraction();
      this.dragging_ = false;
      this.startX_ = void 0;
      this.startY_ = void 0;
      this.dragListenerKeys_.forEach(unlistenByKey);
      this.dragListenerKeys_.length = 0;
    }
  }
  /**
   * Positions the thumb inside its container according to the given resolution.
   *
   * @param {number} res The res.
   * @private
   */
  setThumbPosition_(res) {
    const position = this.getPositionForResolution_(res);
    const thumb = (
      /** @type {HTMLElement} */
      this.element.firstElementChild
    );
    if (this.direction_ == Direction.HORIZONTAL) {
      thumb.style.left = this.widthLimit_ * position + "px";
    } else {
      thumb.style.top = this.heightLimit_ * position + "px";
    }
  }
  /**
   * Calculates the relative position of the thumb given x and y offsets.  The
   * relative position scales from 0 to 1.  The x and y offsets are assumed to be
   * in pixel units within the dragger limits.
   *
   * @param {number} x Pixel position relative to the left of the slider.
   * @param {number} y Pixel position relative to the top of the slider.
   * @return {number} The relative position of the thumb.
   * @private
   */
  getRelativePosition_(x, y) {
    let amount;
    if (this.direction_ === Direction.HORIZONTAL) {
      amount = x / this.widthLimit_;
    } else {
      amount = y / this.heightLimit_;
    }
    return clamp(amount, 0, 1);
  }
  /**
   * Calculates the corresponding resolution of the thumb given its relative
   * position (where 0 is the minimum and 1 is the maximum).
   *
   * @param {number} position The relative position of the thumb.
   * @return {number} The corresponding resolution.
   * @private
   */
  getResolutionForPosition_(position) {
    const fn = this.getMap().getView().getResolutionForValueFunction();
    return fn(1 - position);
  }
  /**
   * Determines the relative position of the slider for the given resolution.  A
   * relative position of 0 corresponds to the minimum view resolution.  A
   * relative position of 1 corresponds to the maximum view resolution.
   *
   * @param {number} res The resolution.
   * @return {number} The relative position value (between 0 and 1).
   * @private
   */
  getPositionForResolution_(res) {
    const fn = this.getMap().getView().getValueForResolutionFunction();
    return clamp(1 - fn(res), 0, 1);
  }
  /**
   * Update the zoomslider element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    if (!mapEvent.frameState) {
      return;
    }
    if (!this.sliderInitialized_ && !this.initSlider_()) {
      return;
    }
    const res = mapEvent.frameState.viewState.resolution;
    this.currentResolution_ = res;
    this.setThumbPosition_(res);
  }
};
var ZoomSlider_default = ZoomSlider;

// node_modules/ol/featureloader.js
var withCredentials = false;
function loadFeaturesXhr(url, format, extent, resolution, projection, success, failure) {
  const xhr2 = new XMLHttpRequest();
  xhr2.open(
    "GET",
    typeof url === "function" ? url(extent, resolution, projection) : url,
    true
  );
  if (format.getType() == "arraybuffer") {
    xhr2.responseType = "arraybuffer";
  }
  xhr2.withCredentials = withCredentials;
  xhr2.onload = function(event) {
    if (!xhr2.status || xhr2.status >= 200 && xhr2.status < 300) {
      const type = format.getType();
      try {
        let source;
        if (type == "text" || type == "json") {
          source = xhr2.responseText;
        } else if (type == "xml") {
          source = xhr2.responseXML || xhr2.responseText;
        } else if (type == "arraybuffer") {
          source = /** @type {ArrayBuffer} */
          xhr2.response;
        }
        if (source) {
          success(
            /** @type {Array<FeatureType>} */
            format.readFeatures(source, {
              extent,
              featureProjection: projection
            }),
            format.readProjection(source)
          );
        } else {
          failure();
        }
      } catch {
        failure();
      }
    } else {
      failure();
    }
  };
  xhr2.onerror = failure;
  xhr2.send();
}
function xhr(url, format) {
  return function(extent, resolution, projection, success, failure) {
    loadFeaturesXhr(
      url,
      format,
      extent,
      resolution,
      projection,
      /**
       * @param {Array<FeatureType>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */
      (features, dataProjection) => {
        this.addFeatures(features);
        if (success !== void 0) {
          success(features);
        }
      },
      () => {
        this.changed();
        if (failure !== void 0) {
          failure();
        }
      }
    );
  };
}

// node_modules/ol/loadingstrategy.js
function all2(extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
}

// node_modules/ol/Feature.js
var Feature = class _Feature extends Object_default {
  /**
   * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */
  constructor(geometryOrProperties) {
    super();
    this.on;
    this.once;
    this.un;
    this.id_ = void 0;
    this.geometryName_ = "geometry";
    this.style_ = null;
    this.styleFunction_ = void 0;
    this.geometryChangeKey_ = null;
    this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
    if (geometryOrProperties) {
      if (typeof /** @type {?} */
      geometryOrProperties.getSimplifiedGeometry === "function") {
        const geometry = (
          /** @type {Geometry} */
          geometryOrProperties
        );
        this.setGeometry(geometry);
      } else {
        const properties = geometryOrProperties;
        this.setProperties(properties);
      }
    }
  }
  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature<Geometry>} The clone.
   * @api
   */
  clone() {
    const clone2 = (
      /** @type {Feature<Geometry>} */
      new _Feature(this.hasProperties() ? this.getProperties() : null)
    );
    clone2.setGeometryName(this.getGeometryName());
    const geometry = this.getGeometry();
    if (geometry) {
      clone2.setGeometry(
        /** @type {Geometry} */
        geometry.clone()
      );
    }
    const style = this.getStyle();
    if (style) {
      clone2.setStyle(style);
    }
    return clone2;
  }
  /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */
  getGeometry() {
    return (
      /** @type {Geometry|undefined} */
      this.get(this.geometryName_)
    );
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */
  getGeometryName() {
    return this.geometryName_;
  }
  /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @private
   */
  handleGeometryChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleGeometryChanged_() {
    if (this.geometryChangeKey_) {
      unlistenByKey(this.geometryChangeKey_);
      this.geometryChangeKey_ = null;
    }
    const geometry = this.getGeometry();
    if (geometry) {
      this.geometryChangeKey_ = listen(
        geometry,
        EventType_default.CHANGE,
        this.handleGeometryChange_,
        this
      );
    }
    this.changed();
  }
  /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */
  setGeometry(geometry) {
    this.set(this.geometryName_, geometry);
  }
  /**
   * Set the style for the feature to override the layer style.  This can be a
   * single style object, an array of styles, or a function that takes a
   * resolution and returns an array of styles. To unset the feature style, call
   * `setStyle()` without arguments or a falsey value.
   * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setStyle(style) {
    this.style_ = style;
    this.styleFunction_ = !style ? void 0 : createStyleFunction(style);
    this.changed();
  }
  /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setId(id) {
    this.id_ = id;
    this.changed();
  }
  /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */
  setGeometryName(name) {
    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
    this.geometryName_ = name;
    this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
    this.handleGeometryChanged_();
  }
};
function createStyleFunction(obj) {
  if (typeof obj === "function") {
    return obj;
  }
  let styles;
  if (Array.isArray(obj)) {
    styles = obj;
  } else {
    assert(
      typeof /** @type {?} */
      obj.getZIndex === "function",
      "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"
    );
    const style = (
      /** @type {import("./style/Style.js").default} */
      obj
    );
    styles = [style];
  }
  return function() {
    return styles;
  };
}
var Feature_default = Feature;

// node_modules/ol/geom/flat/center.js
function linearRingss(flatCoordinates, offset, endss, stride) {
  const flatCenters = [];
  let extent = createEmpty();
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    extent = createOrUpdateFromFlatCoordinates(
      flatCoordinates,
      offset,
      ends[0],
      stride
    );
    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
    offset = ends[ends.length - 1];
  }
  return flatCenters;
}

// node_modules/ol/geom/flat/interpolate.js
function interpolatePoint(flatCoordinates, offset, end, stride, fraction, dest, dimension) {
  let o, t;
  const n = (end - offset) / stride;
  if (n === 1) {
    o = offset;
  } else if (n === 2) {
    o = offset;
    t = fraction;
  } else if (n !== 0) {
    let x1 = flatCoordinates[offset];
    let y1 = flatCoordinates[offset + 1];
    let length = 0;
    const cumulativeLengths = [0];
    for (let i = offset + stride; i < end; i += stride) {
      const x2 = flatCoordinates[i];
      const y2 = flatCoordinates[i + 1];
      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      cumulativeLengths.push(length);
      x1 = x2;
      y1 = y2;
    }
    const target = fraction * length;
    const index = binarySearch(cumulativeLengths, target);
    if (index < 0) {
      t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
      o = offset + (-index - 2) * stride;
    } else {
      o = offset + index * stride;
    }
  }
  dimension = dimension > 1 ? dimension : 2;
  dest = dest ? dest : new Array(dimension);
  for (let i = 0; i < dimension; ++i) {
    dest[i] = o === void 0 ? NaN : t === void 0 ? flatCoordinates[o + i] : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);
  }
  return dest;
}

// node_modules/ol/geom/flat/length.js
function lineStringLength(flatCoordinates, offset, end, stride) {
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  let length = 0;
  for (let i = offset + stride; i < end; i += stride) {
    const x2 = flatCoordinates[i];
    const y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }
  return length;
}

// node_modules/ol/render/Feature.js
var tmpTransform2 = create();
var RenderFeature = class _RenderFeature {
  /**
   * @param {Type} type Geometry type.
   * @param {Array<number>} flatCoordinates Flat coordinates. These always need
   *     to be right-handed for polygons.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Object<string, *>} properties Properties.
   * @param {number|string|undefined} id Feature id.
   */
  constructor(type, flatCoordinates, ends, stride, properties, id) {
    this.styleFunction;
    this.extent_;
    this.id_ = id;
    this.type_ = type;
    this.flatCoordinates_ = flatCoordinates;
    this.flatInteriorPoints_ = null;
    this.flatMidpoints_ = null;
    this.ends_ = ends || null;
    this.properties_ = properties;
    this.squaredTolerance_;
    this.stride_ = stride;
    this.simplifiedGeometry_;
  }
  /**
   * Get a feature property by its key.
   * @param {string} key Key
   * @return {*} Value for the requested key.
   * @api
   */
  get(key) {
    return this.properties_[key];
  }
  /**
   * Get the extent of this feature's geometry.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    if (!this.extent_) {
      this.extent_ = this.type_ === "Point" ? createOrUpdateFromCoordinate(this.flatCoordinates_) : createOrUpdateFromFlatCoordinates(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2
      );
    }
    return this.extent_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoint() {
    if (!this.flatInteriorPoints_) {
      const flatCenter = getCenter(this.getExtent());
      this.flatInteriorPoints_ = getInteriorPointOfArray(
        this.flatCoordinates_,
        0,
        this.ends_,
        2,
        flatCenter,
        0
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (!this.flatInteriorPoints_) {
      const ends = inflateEnds(this.flatCoordinates_, this.ends_);
      const flatCenters = linearRingss(this.flatCoordinates_, 0, ends, 2);
      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(
        this.flatCoordinates_,
        0,
        ends,
        2,
        flatCenters
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = interpolatePoint(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2,
        0.5
      );
    }
    return this.flatMidpoints_;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = [];
      const flatCoordinates = this.flatCoordinates_;
      let offset = 0;
      const ends = (
        /** @type {Array<number>} */
        this.ends_
      );
      for (let i = 0, ii = ends.length; i < ii; ++i) {
        const end = ends[i];
        const midpoint = interpolatePoint(flatCoordinates, offset, end, 2, 0.5);
        extend(this.flatMidpoints_, midpoint);
        offset = end;
      }
    }
    return this.flatMidpoints_;
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is set when reading data from a remote source.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getOrientedFlatCoordinates() {
    return this.flatCoordinates_;
  }
  /**
   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
   * determining the geometry type in style function (see {@link #getType}).
   * @return {RenderFeature} Feature.
   * @api
   */
  getGeometry() {
    return this;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {RenderFeature} Simplified geometry.
   */
  getSimplifiedGeometry(squaredTolerance) {
    return this;
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {RenderFeature} Simplified geometry.
   */
  simplifyTransformed(squaredTolerance, transform2) {
    return this;
  }
  /**
   * Get the feature properties.
   * @return {Object<string, *>} Feature properties.
   * @api
   */
  getProperties() {
    return this.properties_;
  }
  /**
   * Get an object of all property names and values.  This has the same behavior as getProperties,
   * but is here to conform with the {@link module:ol/Feature~Feature} interface.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.properties_;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride_;
  }
  /**
   * @return {import('../style/Style.js').StyleFunction|undefined} Style
   */
  getStyleFunction() {
    return this.styleFunction;
  }
  /**
   * Get the type of this feature's geometry.
   * @return {Type} Geometry type.
   * @api
   */
  getType() {
    return this.type_;
  }
  /**
   * Transform geometry coordinates from tile pixel space to projected.
   *
   * @param {import("../proj.js").ProjectionLike} projection The data projection
   */
  transform(projection) {
    projection = get3(projection);
    const pixelExtent = projection.getExtent();
    const projectedExtent = projection.getWorldExtent();
    if (pixelExtent && projectedExtent) {
      const scale4 = getHeight(projectedExtent) / getHeight(pixelExtent);
      compose(
        tmpTransform2,
        projectedExtent[0],
        projectedExtent[3],
        scale4,
        -scale4,
        0,
        0,
        0
      );
      transform2D(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2,
        tmpTransform2,
        this.flatCoordinates_
      );
    }
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   */
  applyTransform(transformFn) {
    transformFn(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
  }
  /**
   * @return {RenderFeature} A cloned render feature.
   */
  clone() {
    return new _RenderFeature(
      this.type_,
      this.flatCoordinates_.slice(),
      this.ends_?.slice(),
      this.stride_,
      Object.assign({}, this.properties_),
      this.id_
    );
  }
  /**
   * @return {Array<number>|null} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Add transform and resolution based geometry simplification to this instance.
   * @return {RenderFeature} This render feature.
   */
  enableSimplifyTransformed() {
    this.simplifyTransformed = memoizeOne((squaredTolerance, transform2) => {
      if (squaredTolerance === this.squaredTolerance_) {
        return this.simplifiedGeometry_;
      }
      this.simplifiedGeometry_ = this.clone();
      if (transform2) {
        this.simplifiedGeometry_.applyTransform(transform2);
      }
      const simplifiedFlatCoordinates = this.simplifiedGeometry_.getFlatCoordinates();
      let simplifiedEnds;
      switch (this.type_) {
        case "LineString":
          simplifiedFlatCoordinates.length = douglasPeucker(
            simplifiedFlatCoordinates,
            0,
            this.simplifiedGeometry_.flatCoordinates_.length,
            this.simplifiedGeometry_.stride_,
            squaredTolerance,
            simplifiedFlatCoordinates,
            0
          );
          simplifiedEnds = [simplifiedFlatCoordinates.length];
          break;
        case "MultiLineString":
          simplifiedEnds = [];
          simplifiedFlatCoordinates.length = douglasPeuckerArray(
            simplifiedFlatCoordinates,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            squaredTolerance,
            simplifiedFlatCoordinates,
            0,
            simplifiedEnds
          );
          break;
        case "Polygon":
          simplifiedEnds = [];
          simplifiedFlatCoordinates.length = quantizeArray(
            simplifiedFlatCoordinates,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            Math.sqrt(squaredTolerance),
            simplifiedFlatCoordinates,
            0,
            simplifiedEnds
          );
          break;
        default:
      }
      if (simplifiedEnds) {
        this.simplifiedGeometry_ = new _RenderFeature(
          this.type_,
          simplifiedFlatCoordinates,
          simplifiedEnds,
          2,
          this.properties_,
          this.id_
        );
      }
      this.squaredTolerance_ = squaredTolerance;
      return this.simplifiedGeometry_;
    });
    return this;
  }
};
RenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;
var Feature_default2 = RenderFeature;

// node_modules/ol/structs/RBush.js
var RBush2 = class {
  /**
   * @param {number} [maxEntries] Max entries.
   */
  constructor(maxEntries) {
    this.rbush_ = new RBush(maxEntries);
    this.items_ = {};
  }
  /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  insert(extent, value) {
    const item = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3],
      value
    };
    this.rbush_.insert(item);
    this.items_[getUid(value)] = item;
  }
  /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */
  load(extents, values) {
    const items = new Array(values.length);
    for (let i = 0, l = values.length; i < l; i++) {
      const extent = extents[i];
      const value = values[i];
      const item = {
        minX: extent[0],
        minY: extent[1],
        maxX: extent[2],
        maxY: extent[3],
        value
      };
      items[i] = item;
      this.items_[getUid(value)] = item;
    }
    this.rbush_.load(items);
  }
  /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */
  remove(value) {
    const uid = getUid(value);
    const item = this.items_[uid];
    delete this.items_[uid];
    return this.rbush_.remove(item) !== null;
  }
  /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  update(extent, value) {
    const item = this.items_[getUid(value)];
    const bbox = [item.minX, item.minY, item.maxX, item.maxY];
    if (!equals2(bbox, extent)) {
      this.remove(value);
      this.insert(extent, value);
    }
  }
  /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */
  getAll() {
    const items = this.rbush_.all();
    return items.map(function(item) {
      return item.value;
    });
  }
  /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */
  getInExtent(extent) {
    const bbox = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3]
    };
    const items = this.rbush_.search(bbox);
    return items.map(function(item) {
      return item.value;
    });
  }
  /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): R} callback Callback.
   * @return {R|undefined} Callback return value.
   * @template R
   */
  forEach(callback) {
    return this.forEach_(this.getAll(), callback);
  }
  /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): R} callback Callback.
   * @return {R|undefined} Callback return value.
   * @template R
   */
  forEachInExtent(extent, callback) {
    return this.forEach_(this.getInExtent(extent), callback);
  }
  /**
   * @param {Array<T>} values Values.
   * @param {function(T): R} callback Callback.
   * @return {R|undefined} Callback return value.
   * @template R
   * @private
   */
  forEach_(values, callback) {
    let result;
    for (let i = 0, l = values.length; i < l; i++) {
      result = callback(values[i]);
      if (result) {
        return result;
      }
    }
    return result;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return isEmpty(this.items_);
  }
  /**
   * Remove all values from the RBush.
   */
  clear() {
    this.rbush_.clear();
    this.items_ = {};
  }
  /**
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} Extent.
   */
  getExtent(extent) {
    const data = this.rbush_.toJSON();
    return createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, extent);
  }
  /**
   * @param {RBush<T>} rbush R-Tree.
   */
  concat(rbush) {
    this.rbush_.load(rbush.rbush_.all());
    for (const i in rbush.items_) {
      this.items_[i] = rbush.items_[i];
    }
  }
};
var RBush_default = RBush2;

// node_modules/ol/source/Source.js
var Source = class extends Object_default {
  /**
   * @param {Options} options Source options.
   */
  constructor(options) {
    super();
    this.projection = get3(options.projection);
    this.attributions_ = adaptAttributions(options.attributions);
    this.attributionsCollapsible_ = options.attributionsCollapsible ?? true;
    this.loading = false;
    this.state_ = options.state !== void 0 ? options.state : "ready";
    this.wrapX_ = options.wrapX !== void 0 ? options.wrapX : false;
    this.interpolate_ = !!options.interpolate;
    this.viewResolver = null;
    this.viewRejector = null;
    const self2 = this;
    this.viewPromise_ = new Promise(function(resolve, reject) {
      self2.viewResolver = resolve;
      self2.viewRejector = reject;
    });
  }
  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */
  getAttributions() {
    return this.attributions_;
  }
  /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */
  getAttributionsCollapsible() {
    return this.attributionsCollapsible_;
  }
  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */
  getProjection() {
    return this.projection;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(projection) {
    return null;
  }
  /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */
  getView() {
    return this.viewPromise_;
  }
  /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */
  getState() {
    return this.state_;
  }
  /**
   * @return {boolean|undefined} Wrap X.
   */
  getWrapX() {
    return this.wrapX_;
  }
  /**
   * @return {boolean} Use linear interpolation when resampling.
   */
  getInterpolate() {
    return this.interpolate_;
  }
  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */
  refresh() {
    this.changed();
  }
  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */
  setAttributions(attributions) {
    this.attributions_ = adaptAttributions(attributions);
    this.changed();
  }
  /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */
  setState(state) {
    this.state_ = state;
    this.changed();
  }
};
function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (typeof attributionLike === "function") {
    return attributionLike;
  }
  if (!Array.isArray(attributionLike)) {
    attributionLike = [attributionLike];
  }
  return (frameState) => attributionLike;
}
var Source_default = Source;

// node_modules/ol/source/VectorEventType.js
var VectorEventType_default = {
  /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: "addfeature",
  /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: "changefeature",
  /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: "clear",
  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: "removefeature",
  /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */
  FEATURESLOADSTART: "featuresloadstart",
  /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */
  FEATURESLOADEND: "featuresloadend",
  /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */
  FEATURESLOADERROR: "featuresloaderror"
};

// node_modules/ol/source/Vector.js
var VectorSourceEvent = class extends Event_default {
  /**
   * @param {string} type Type.
   * @param {FeatureType} [feature] Feature.
   * @param {Array<FeatureType>} [features] Features.
   */
  constructor(type, feature, features) {
    super(type);
    this.feature = feature;
    this.features = features;
  }
};
var VectorSource = class extends Source_default {
  /**
   * @param {Options<FeatureType>} [options] Vector source options.
   */
  constructor(options) {
    options = options || {};
    super({
      attributions: options.attributions,
      interpolate: true,
      projection: void 0,
      state: "ready",
      wrapX: options.wrapX !== void 0 ? options.wrapX : true
    });
    this.on;
    this.once;
    this.un;
    this.loader_ = VOID;
    this.format_ = options.format || null;
    this.overlaps_ = options.overlaps === void 0 ? true : options.overlaps;
    this.url_ = options.url;
    if (options.loader !== void 0) {
      this.loader_ = options.loader;
    } else if (this.url_ !== void 0) {
      assert(this.format_, "`format` must be set when `url` is set");
      this.loader_ = xhr(this.url_, this.format_);
    }
    this.strategy_ = options.strategy !== void 0 ? options.strategy : all2;
    const useSpatialIndex = options.useSpatialIndex !== void 0 ? options.useSpatialIndex : true;
    this.featuresRtree_ = useSpatialIndex ? new RBush_default() : null;
    this.loadedExtentsRtree_ = new RBush_default();
    this.loadingExtentsCount_ = 0;
    this.nullGeometryFeatures_ = {};
    this.idIndex_ = {};
    this.uidIndex_ = {};
    this.featureChangeKeys_ = {};
    this.featuresCollection_ = null;
    let collection;
    let features;
    if (Array.isArray(options.features)) {
      features = options.features;
    } else if (options.features) {
      collection = options.features;
      features = collection.getArray();
    }
    if (!useSpatialIndex && collection === void 0) {
      collection = new Collection_default(features);
    }
    if (features !== void 0) {
      this.addFeaturesInternal(features);
    }
    if (collection !== void 0) {
      this.bindFeaturesCollection_(collection);
    }
  }
  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if a {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {FeatureType} feature Feature to add.
   * @api
   */
  addFeature(feature) {
    this.addFeatureInternal(feature);
    this.changed();
  }
  /**
   * Add a feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @protected
   */
  addFeatureInternal(feature) {
    const featureKey = getUid(feature);
    if (!this.addToIndex_(featureKey, feature)) {
      if (this.featuresCollection_) {
        this.featuresCollection_.remove(feature);
      }
      return;
    }
    this.setupChangeEvents_(featureKey, feature);
    const geometry = feature.getGeometry();
    if (geometry) {
      const extent = geometry.getExtent();
      if (this.featuresRtree_) {
        this.featuresRtree_.insert(extent, feature);
      }
    } else {
      this.nullGeometryFeatures_[featureKey] = feature;
    }
    this.dispatchEvent(
      new VectorSourceEvent(VectorEventType_default.ADDFEATURE, feature)
    );
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @private
   */
  setupChangeEvents_(featureKey, feature) {
    if (feature instanceof Feature_default2) {
      return;
    }
    this.featureChangeKeys_[featureKey] = [
      listen(feature, EventType_default.CHANGE, this.handleFeatureChange_, this),
      listen(
        feature,
        ObjectEventType_default.PROPERTYCHANGE,
        this.handleFeatureChange_,
        this
      )
    ];
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */
  addToIndex_(featureKey, feature) {
    let valid = true;
    if (feature.getId() !== void 0) {
      const id = String(feature.getId());
      if (!(id in this.idIndex_)) {
        this.idIndex_[id] = feature;
      } else if (feature instanceof Feature_default2) {
        const indexedFeature = this.idIndex_[id];
        if (!(indexedFeature instanceof Feature_default2)) {
          valid = false;
        } else if (!Array.isArray(indexedFeature)) {
          this.idIndex_[id] = [indexedFeature, feature];
        } else {
          indexedFeature.push(feature);
        }
      } else {
        valid = false;
      }
    }
    if (valid) {
      assert(
        !(featureKey in this.uidIndex_),
        "The passed `feature` was already added to the source"
      );
      this.uidIndex_[featureKey] = feature;
    }
    return valid;
  }
  /**
   * Add a batch of features to the source.
   * @param {Array<FeatureType>} features Features to add.
   * @api
   */
  addFeatures(features) {
    this.addFeaturesInternal(features);
    this.changed();
  }
  /**
   * Add features without firing a `change` event.
   * @param {Array<FeatureType>} features Features.
   * @protected
   */
  addFeaturesInternal(features) {
    const extents = [];
    const newFeatures = [];
    const geometryFeatures = [];
    for (let i = 0, length = features.length; i < length; i++) {
      const feature = features[i];
      const featureKey = getUid(feature);
      if (this.addToIndex_(featureKey, feature)) {
        newFeatures.push(feature);
      }
    }
    for (let i = 0, length = newFeatures.length; i < length; i++) {
      const feature = newFeatures[i];
      const featureKey = getUid(feature);
      this.setupChangeEvents_(featureKey, feature);
      const geometry = feature.getGeometry();
      if (geometry) {
        const extent = geometry.getExtent();
        extents.push(extent);
        geometryFeatures.push(feature);
      } else {
        this.nullGeometryFeatures_[featureKey] = feature;
      }
    }
    if (this.featuresRtree_) {
      this.featuresRtree_.load(extents, geometryFeatures);
    }
    if (this.hasListener(VectorEventType_default.ADDFEATURE)) {
      for (let i = 0, length = newFeatures.length; i < length; i++) {
        this.dispatchEvent(
          new VectorSourceEvent(VectorEventType_default.ADDFEATURE, newFeatures[i])
        );
      }
    }
  }
  /**
   * @param {!Collection<FeatureType>} collection Collection.
   * @private
   */
  bindFeaturesCollection_(collection) {
    let modifyingCollection = false;
    this.addEventListener(
      VectorEventType_default.ADDFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */
      function(evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          collection.push(evt.feature);
          modifyingCollection = false;
        }
      }
    );
    this.addEventListener(
      VectorEventType_default.REMOVEFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */
      function(evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          collection.remove(evt.feature);
          modifyingCollection = false;
        }
      }
    );
    collection.addEventListener(
      CollectionEventType_default.ADD,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */
      (evt) => {
        if (!modifyingCollection) {
          modifyingCollection = true;
          this.addFeature(evt.element);
          modifyingCollection = false;
        }
      }
    );
    collection.addEventListener(
      CollectionEventType_default.REMOVE,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */
      (evt) => {
        if (!modifyingCollection) {
          modifyingCollection = true;
          this.removeFeature(evt.element);
          modifyingCollection = false;
        }
      }
    );
    this.featuresCollection_ = collection;
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
   * @api
   */
  clear(fast) {
    if (fast) {
      for (const featureId in this.featureChangeKeys_) {
        const keys = this.featureChangeKeys_[featureId];
        keys.forEach(unlistenByKey);
      }
      if (!this.featuresCollection_) {
        this.featureChangeKeys_ = {};
        this.idIndex_ = {};
        this.uidIndex_ = {};
      }
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.forEach((feature) => {
          this.removeFeatureInternal(feature);
        });
        for (const id in this.nullGeometryFeatures_) {
          this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
        }
      }
    }
    if (this.featuresCollection_) {
      this.featuresCollection_.clear();
    }
    if (this.featuresRtree_) {
      this.featuresRtree_.clear();
    }
    this.nullGeometryFeatures_ = {};
    const clearEvent = new VectorSourceEvent(VectorEventType_default.CLEAR);
    this.dispatchEvent(clearEvent);
    this.changed();
  }
  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(FeatureType): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeature(callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEach(callback);
    }
    if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  }
  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
   * called for all features.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */
  forEachFeatureAtCoordinateDirect(coordinate, callback) {
    const extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
    return this.forEachFeatureInExtent(extent, function(feature) {
      const geometry = feature.getGeometry();
      if (geometry instanceof Feature_default2 || geometry.intersectsCoordinate(coordinate)) {
        return callback(feature);
      }
      return void 0;
    });
  }
  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureInExtent(extent, callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEachInExtent(extent, callback);
    }
    if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  }
  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureIntersectingExtent(extent, callback) {
    return this.forEachFeatureInExtent(
      extent,
      /**
       * @param {FeatureType} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */
      function(feature) {
        const geometry = feature.getGeometry();
        if (geometry instanceof Feature_default2 || geometry.intersectsExtent(extent)) {
          const result = callback(feature);
          if (result) {
            return result;
          }
        }
      }
    );
  }
  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with a {@link module:ol/Collection~Collection} as `features`.
   * @return {Collection<FeatureType>|null} The collection of features.
   * @api
   */
  getFeaturesCollection() {
    return this.featuresCollection_;
  }
  /**
   * Get a snapshot of the features currently on the source in random order. The returned array
   * is a copy, the features are references to the features in the source.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeatures() {
    let features;
    if (this.featuresCollection_) {
      features = this.featuresCollection_.getArray().slice(0);
    } else if (this.featuresRtree_) {
      features = this.featuresRtree_.getAll();
      if (!isEmpty(this.nullGeometryFeatures_)) {
        extend(features, Object.values(this.nullGeometryFeatures_));
      }
    }
    return features;
  }
  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeaturesAtCoordinate(coordinate) {
    const features = [];
    this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
      features.push(feature);
    });
    return features;
  }
  /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../proj/Projection.js").default} [projection] Include features
   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeaturesInExtent(extent, projection) {
    if (this.featuresRtree_) {
      const multiWorld = projection && projection.canWrapX() && this.getWrapX();
      if (!multiWorld) {
        return this.featuresRtree_.getInExtent(extent);
      }
      const extents = wrapAndSliceX(extent, projection);
      return [].concat(
        ...extents.map((anExtent) => this.featuresRtree_.getInExtent(anExtent))
      );
    }
    if (this.featuresCollection_) {
      return this.featuresCollection_.getArray().slice(0);
    }
    return [];
  }
  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false` and the features in this source are of type
   * {@link module:ol/Feature~Feature}.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType):boolean} [filter] Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {FeatureType} Closest feature.
   * @api
   */
  getClosestFeatureToCoordinate(coordinate, filter) {
    const x = coordinate[0];
    const y = coordinate[1];
    let closestFeature = null;
    const closestPoint = [NaN, NaN];
    let minSquaredDistance = Infinity;
    const extent = [-Infinity, -Infinity, Infinity, Infinity];
    filter = filter ? filter : TRUE;
    this.featuresRtree_.forEachInExtent(
      extent,
      /**
       * @param {FeatureType} feature Feature.
       */
      function(feature) {
        if (filter(feature)) {
          const geometry = feature.getGeometry();
          const previousMinSquaredDistance = minSquaredDistance;
          minSquaredDistance = geometry instanceof Feature_default2 ? 0 : geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
          if (minSquaredDistance < previousMinSquaredDistance) {
            closestFeature = feature;
            const minDistance = Math.sqrt(minSquaredDistance);
            extent[0] = x - minDistance;
            extent[1] = y - minDistance;
            extent[2] = x + minDistance;
            extent[3] = y + minDistance;
          }
        }
      }
    );
    return closestFeature;
  }
  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent(extent) {
    return this.featuresRtree_.getExtent(extent);
  }
  /**
   * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
   * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
   * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
   * `GeometryCollection` member.
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {FeatureClassOrArrayOfRenderFeatures<FeatureType>|null} The feature (or `null` if not found).
   * @api
   */
  getFeatureById(id) {
    const feature = this.idIndex_[id.toString()];
    return feature !== void 0 ? (
      /** @type {FeatureClassOrArrayOfRenderFeatures<FeatureType>} */
      feature
    ) : null;
  }
  /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {FeatureType|null} The feature (or `null` if not found).
   */
  getFeatureByUid(uid) {
    const feature = this.uidIndex_[uid];
    return feature !== void 0 ? feature : null;
  }
  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default<FeatureType>|null}} The feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }
  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * @param {Event} event Event.
   * @private
   */
  handleFeatureChange_(event) {
    const feature = (
      /** @type {FeatureType} */
      event.target
    );
    const featureKey = getUid(feature);
    const geometry = feature.getGeometry();
    if (!geometry) {
      if (!(featureKey in this.nullGeometryFeatures_)) {
        if (this.featuresRtree_) {
          this.featuresRtree_.remove(feature);
        }
        this.nullGeometryFeatures_[featureKey] = feature;
      }
    } else {
      const extent = geometry.getExtent();
      if (featureKey in this.nullGeometryFeatures_) {
        delete this.nullGeometryFeatures_[featureKey];
        if (this.featuresRtree_) {
          this.featuresRtree_.insert(extent, feature);
        }
      } else {
        if (this.featuresRtree_) {
          this.featuresRtree_.update(extent, feature);
        }
      }
    }
    const id = feature.getId();
    if (id !== void 0) {
      const sid = id.toString();
      if (this.idIndex_[sid] !== feature) {
        this.removeFromIdIndex_(feature);
        this.idIndex_[sid] = feature;
      }
    } else {
      this.removeFromIdIndex_(feature);
      this.uidIndex_[featureKey] = feature;
    }
    this.changed();
    this.dispatchEvent(
      new VectorSourceEvent(VectorEventType_default.CHANGEFEATURE, feature)
    );
  }
  /**
   * Returns true if the feature is contained within the source.
   * @param {FeatureType} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */
  hasFeature(feature) {
    const id = feature.getId();
    if (id !== void 0) {
      return id in this.idIndex_;
    }
    return getUid(feature) in this.uidIndex_;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    if (this.featuresRtree_) {
      return this.featuresRtree_.isEmpty() && isEmpty(this.nullGeometryFeatures_);
    }
    if (this.featuresCollection_) {
      return this.featuresCollection_.getLength() === 0;
    }
    return true;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(extent, resolution, projection) {
    const loadedExtentsRtree = this.loadedExtentsRtree_;
    const extentsToLoad = this.strategy_(extent, resolution, projection);
    for (let i = 0, ii = extentsToLoad.length; i < ii; ++i) {
      const extentToLoad = extentsToLoad[i];
      const alreadyLoaded = loadedExtentsRtree.forEachInExtent(
        extentToLoad,
        /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */
        function(object) {
          return containsExtent(object.extent, extentToLoad);
        }
      );
      if (!alreadyLoaded) {
        ++this.loadingExtentsCount_;
        this.dispatchEvent(
          new VectorSourceEvent(VectorEventType_default.FEATURESLOADSTART)
        );
        this.loader_.call(
          this,
          extentToLoad,
          resolution,
          projection,
          /**
           * @param {Array<FeatureType>} features Loaded features
           */
          (features) => {
            --this.loadingExtentsCount_;
            this.dispatchEvent(
              new VectorSourceEvent(
                VectorEventType_default.FEATURESLOADEND,
                void 0,
                features
              )
            );
          },
          () => {
            --this.loadingExtentsCount_;
            this.dispatchEvent(
              new VectorSourceEvent(VectorEventType_default.FEATURESLOADERROR)
            );
          }
        );
        loadedExtentsRtree.insert(extentToLoad, { extent: extentToLoad.slice() });
      }
    }
    this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
  }
  /**
   * @override
   */
  refresh() {
    this.clear(true);
    this.loadedExtentsRtree_.clear();
    super.refresh();
  }
  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  removeLoadedExtent(extent) {
    const loadedExtentsRtree = this.loadedExtentsRtree_;
    const obj = loadedExtentsRtree.forEachInExtent(extent, function(object) {
      if (equals2(object.extent, extent)) {
        return object;
      }
    });
    if (obj) {
      loadedExtentsRtree.remove(obj);
    }
  }
  /**
   * Batch remove features from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {Array<FeatureType>} features Features to remove.
   * @api
   */
  removeFeatures(features) {
    let removed = false;
    for (let i = 0, ii = features.length; i < ii; ++i) {
      removed = this.removeFeatureInternal(features[i]) || removed;
    }
    if (removed) {
      this.changed();
    }
  }
  /**
   * Remove a single feature from the source. If you want to batch remove
   * features, use the {@link module:ol/source/Vector~VectorSource#removeFeatures #removeFeatures()} method
   * instead.
   * @param {FeatureType} feature Feature to remove.
   * @api
   */
  removeFeature(feature) {
    if (!feature) {
      return;
    }
    const removed = this.removeFeatureInternal(feature);
    if (removed) {
      this.changed();
    }
  }
  /**
   * Remove feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @return {boolean} True if the feature was removed, false if it was not found.
   * @protected
   */
  removeFeatureInternal(feature) {
    const featureKey = getUid(feature);
    if (!(featureKey in this.uidIndex_)) {
      return false;
    }
    if (featureKey in this.nullGeometryFeatures_) {
      delete this.nullGeometryFeatures_[featureKey];
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.remove(feature);
      }
    }
    const featureChangeKeys = this.featureChangeKeys_[featureKey];
    featureChangeKeys?.forEach(unlistenByKey);
    delete this.featureChangeKeys_[featureKey];
    const id = feature.getId();
    if (id !== void 0) {
      const idString = id.toString();
      const indexedFeature = this.idIndex_[idString];
      if (indexedFeature === feature) {
        delete this.idIndex_[idString];
      } else if (Array.isArray(indexedFeature)) {
        indexedFeature.splice(indexedFeature.indexOf(feature), 1);
        if (indexedFeature.length === 1) {
          this.idIndex_[idString] = indexedFeature[0];
        }
      }
    }
    delete this.uidIndex_[featureKey];
    if (this.hasListener(VectorEventType_default.REMOVEFEATURE)) {
      this.dispatchEvent(
        new VectorSourceEvent(VectorEventType_default.REMOVEFEATURE, feature)
      );
    }
    return true;
  }
  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {FeatureType} feature The feature.
   * @private
   */
  removeFromIdIndex_(feature) {
    for (const id in this.idIndex_) {
      if (this.idIndex_[id] === feature) {
        delete this.idIndex_[id];
        break;
      }
    }
  }
  /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */
  setLoader(loader) {
    this.loader_ = loader;
  }
  /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */
  setUrl(url) {
    assert(this.format_, "`format` must be set when `url` is set");
    this.url_ = url;
    this.setLoader(xhr(url, this.format_));
  }
  /**
   * @param {boolean} overlaps The source can have overlapping geometries.
   */
  setOverlaps(overlaps) {
    this.overlaps_ = overlaps;
    this.changed();
  }
};
var Vector_default = VectorSource;

// node_modules/ol/render/VectorContext.js
var VectorContext = class {
  /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   * @param {number} [index] Render order index.
   */
  drawCustom(geometry, feature, renderer, hitDetectionRenderer, index) {
  }
  /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */
  drawGeometry(geometry) {
  }
  /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */
  setStyle(style) {
  }
  /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawCircle(circleGeometry, feature, index) {
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   * @param {number} [index] Render order index.
   */
  drawFeature(feature, style, index) {
  }
  /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawGeometryCollection(geometryCollectionGeometry, feature, index) {
  }
  /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawLineString(lineStringGeometry, feature, index) {
  }
  /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiLineString(multiLineStringGeometry, feature, index) {
  }
  /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPoint(multiPointGeometry, feature, index) {
  }
  /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPolygon(multiPolygonGeometry, feature, index) {
  }
  /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPoint(pointGeometry, feature, index) {
  }
  /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPolygon(polygonGeometry, feature, index) {
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawText(geometry, feature, index) {
  }
  /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(fillStyle, strokeStyle) {
  }
  /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
   */
  setImageStyle(imageStyle, declutterImageWithText) {
  }
  /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
   */
  setTextStyle(textStyle, declutterImageWithText) {
  }
};
var VectorContext_default = VectorContext;

// node_modules/ol/render/canvas/Instruction.js
var Instruction = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
};
var fillInstruction = [Instruction.FILL];
var strokeInstruction = [Instruction.STROKE];
var beginPathInstruction = [Instruction.BEGIN_PATH];
var closePathInstruction = [Instruction.CLOSE_PATH];
var Instruction_default = Instruction;

// node_modules/ol/render/canvas/Builder.js
var CanvasBuilder = class extends VectorContext_default {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super();
    this.tolerance = tolerance;
    this.maxExtent = maxExtent;
    this.pixelRatio = pixelRatio;
    this.maxLineWidth = 0;
    this.resolution = resolution;
    this.beginGeometryInstruction1_ = null;
    this.beginGeometryInstruction2_ = null;
    this.bufferedMaxExtent_ = null;
    this.instructions = [];
    this.coordinates = [];
    this.tmpCoordinate_ = [];
    this.hitDetectionInstructions = [];
    this.state = /** @type {import("../canvas.js").FillStrokeState} */
    {};
  }
  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */
  applyPixelRatio(dashArray) {
    const pixelRatio = this.pixelRatio;
    return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
      return dash * pixelRatio;
    });
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @protected
   * @return {number} My end
   */
  appendFlatPointCoordinates(flatCoordinates, stride) {
    const extent = this.getBufferedMaxExtent();
    const tmpCoord = this.tmpCoordinate_;
    const coordinates2 = this.coordinates;
    let myEnd = coordinates2.length;
    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      tmpCoord[0] = flatCoordinates[i];
      tmpCoord[1] = flatCoordinates[i + 1];
      if (containsCoordinate(extent, tmpCoord)) {
        coordinates2[myEnd++] = tmpCoord[0];
        coordinates2[myEnd++] = tmpCoord[1];
      }
    }
    return myEnd;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */
  appendFlatLineCoordinates(flatCoordinates, offset, end, stride, closed, skipFirst) {
    const coordinates2 = this.coordinates;
    let myEnd = coordinates2.length;
    const extent = this.getBufferedMaxExtent();
    if (skipFirst) {
      offset += stride;
    }
    let lastXCoord = flatCoordinates[offset];
    let lastYCoord = flatCoordinates[offset + 1];
    const nextCoord = this.tmpCoordinate_;
    let skipped = true;
    let i, lastRel, nextRel;
    for (i = offset + stride; i < end; i += stride) {
      nextCoord[0] = flatCoordinates[i];
      nextCoord[1] = flatCoordinates[i + 1];
      nextRel = coordinateRelationship(extent, nextCoord);
      if (nextRel !== lastRel) {
        if (skipped) {
          coordinates2[myEnd++] = lastXCoord;
          coordinates2[myEnd++] = lastYCoord;
          skipped = false;
        }
        coordinates2[myEnd++] = nextCoord[0];
        coordinates2[myEnd++] = nextCoord[1];
      } else if (nextRel === Relationship_default.INTERSECTING) {
        coordinates2[myEnd++] = nextCoord[0];
        coordinates2[myEnd++] = nextCoord[1];
        skipped = false;
      } else {
        skipped = true;
      }
      lastXCoord = nextCoord[0];
      lastYCoord = nextCoord[1];
      lastRel = nextRel;
    }
    if (closed && skipped || i === offset + stride) {
      coordinates2[myEnd++] = lastXCoord;
      coordinates2[myEnd++] = lastYCoord;
    }
    return myEnd;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */
  drawCustomCoordinates_(flatCoordinates, offset, ends, stride, builderEnds) {
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      const builderEnd = this.appendFlatLineCoordinates(
        flatCoordinates,
        offset,
        end,
        stride,
        false,
        false
      );
      builderEnds.push(builderEnd);
      offset = end;
    }
    return offset;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   * @param {number} [index] Render order index.
   * @override
   */
  drawCustom(geometry, feature, renderer, hitDetectionRenderer, index) {
    this.beginGeometry(geometry, feature, index);
    const type = geometry.getType();
    const stride = geometry.getStride();
    const builderBegin = this.coordinates.length;
    let flatCoordinates, builderEnd, builderEnds, builderEndss;
    let offset;
    switch (type) {
      case "MultiPolygon":
        flatCoordinates = /** @type {import("../../geom/MultiPolygon.js").default} */
        geometry.getOrientedFlatCoordinates();
        builderEndss = [];
        const endss = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          geometry.getEndss()
        );
        offset = 0;
        for (let i = 0, ii = endss.length; i < ii; ++i) {
          const myEnds = [];
          offset = this.drawCustomCoordinates_(
            flatCoordinates,
            offset,
            endss[i],
            stride,
            myEnds
          );
          builderEndss.push(myEnds);
        }
        this.instructions.push([
          Instruction_default.CUSTOM,
          builderBegin,
          builderEndss,
          geometry,
          renderer,
          inflateMultiCoordinatesArray,
          index
        ]);
        this.hitDetectionInstructions.push([
          Instruction_default.CUSTOM,
          builderBegin,
          builderEndss,
          geometry,
          hitDetectionRenderer || renderer,
          inflateMultiCoordinatesArray,
          index
        ]);
        break;
      case "Polygon":
      case "MultiLineString":
        builderEnds = [];
        flatCoordinates = type == "Polygon" ? (
          /** @type {import("../../geom/Polygon.js").default} */
          geometry.getOrientedFlatCoordinates()
        ) : geometry.getFlatCoordinates();
        offset = this.drawCustomCoordinates_(
          flatCoordinates,
          0,
          /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
          geometry.getEnds(),
          stride,
          builderEnds
        );
        this.instructions.push([
          Instruction_default.CUSTOM,
          builderBegin,
          builderEnds,
          geometry,
          renderer,
          inflateCoordinatesArray,
          index
        ]);
        this.hitDetectionInstructions.push([
          Instruction_default.CUSTOM,
          builderBegin,
          builderEnds,
          geometry,
          hitDetectionRenderer || renderer,
          inflateCoordinatesArray,
          index
        ]);
        break;
      case "LineString":
      case "Circle":
        flatCoordinates = geometry.getFlatCoordinates();
        builderEnd = this.appendFlatLineCoordinates(
          flatCoordinates,
          0,
          flatCoordinates.length,
          stride,
          false,
          false
        );
        this.instructions.push([
          Instruction_default.CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          renderer,
          inflateCoordinates,
          index
        ]);
        this.hitDetectionInstructions.push([
          Instruction_default.CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          hitDetectionRenderer || renderer,
          inflateCoordinates,
          index
        ]);
        break;
      case "MultiPoint":
        flatCoordinates = geometry.getFlatCoordinates();
        builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
        if (builderEnd > builderBegin) {
          this.instructions.push([
            Instruction_default.CUSTOM,
            builderBegin,
            builderEnd,
            geometry,
            renderer,
            inflateCoordinates,
            index
          ]);
          this.hitDetectionInstructions.push([
            Instruction_default.CUSTOM,
            builderBegin,
            builderEnd,
            geometry,
            hitDetectionRenderer || renderer,
            inflateCoordinates,
            index
          ]);
        }
        break;
      case "Point":
        flatCoordinates = geometry.getFlatCoordinates();
        this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
        builderEnd = this.coordinates.length;
        this.instructions.push([
          Instruction_default.CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          renderer,
          void 0,
          index
        ]);
        this.hitDetectionInstructions.push([
          Instruction_default.CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          hitDetectionRenderer || renderer,
          void 0,
          index
        ]);
        break;
      default:
    }
    this.endGeometry(feature);
  }
  /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} index Render order index
   */
  beginGeometry(geometry, feature, index) {
    this.beginGeometryInstruction1_ = [
      Instruction_default.BEGIN_GEOMETRY,
      feature,
      0,
      geometry,
      index
    ];
    this.instructions.push(this.beginGeometryInstruction1_);
    this.beginGeometryInstruction2_ = [
      Instruction_default.BEGIN_GEOMETRY,
      feature,
      0,
      geometry,
      index
    ];
    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates
    };
  }
  /**
   * Reverse the hit detection instructions.
   */
  reverseHitDetectionInstructions() {
    const hitDetectionInstructions = this.hitDetectionInstructions;
    hitDetectionInstructions.reverse();
    let i;
    const n = hitDetectionInstructions.length;
    let instruction;
    let type;
    let begin = -1;
    for (i = 0; i < n; ++i) {
      instruction = hitDetectionInstructions[i];
      type = /** @type {import("./Instruction.js").default} */
      instruction[0];
      if (type == Instruction_default.END_GEOMETRY) {
        begin = i;
      } else if (type == Instruction_default.BEGIN_GEOMETRY) {
        instruction[2] = i;
        reverseSubArray(this.hitDetectionInstructions, begin, i);
        begin = -1;
      }
    }
  }
  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import('../canvas.js').FillStrokeState} [state] State.
   * @return {import('../canvas.js').FillStrokeState} State.
   */
  fillStyleToState(fillStyle, state = (
    /** @type {import('../canvas.js').FillStrokeState} */
    {}
  )) {
    if (fillStyle) {
      const fillStyleColor = fillStyle.getColor();
      state.fillPatternScale = fillStyleColor && typeof fillStyleColor === "object" && "src" in fillStyleColor ? this.pixelRatio : 1;
      state.fillStyle = asColorLike(
        fillStyleColor ? fillStyleColor : defaultFillStyle
      );
    } else {
      state.fillStyle = void 0;
    }
    return state;
  }
  /**
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {import("../canvas.js").FillStrokeState} State.
   */
  strokeStyleToState(strokeStyle, state = (
    /** @type {import('../canvas.js').FillStrokeState} */
    {}
  )) {
    if (strokeStyle) {
      const strokeStyleColor = strokeStyle.getColor();
      state.strokeStyle = asColorLike(
        strokeStyleColor ? strokeStyleColor : defaultStrokeStyle
      );
      const strokeStyleLineCap = strokeStyle.getLineCap();
      state.lineCap = strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap;
      const strokeStyleLineDash = strokeStyle.getLineDash();
      state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;
      const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;
      const strokeStyleLineJoin = strokeStyle.getLineJoin();
      state.lineJoin = strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin;
      const strokeStyleWidth = strokeStyle.getWidth();
      state.lineWidth = strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth;
      const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      state.miterLimit = strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit;
      if (state.lineWidth > this.maxLineWidth) {
        this.maxLineWidth = state.lineWidth;
        this.bufferedMaxExtent_ = null;
      }
    } else {
      state.strokeStyle = void 0;
      state.lineCap = void 0;
      state.lineDash = null;
      state.lineDashOffset = void 0;
      state.lineJoin = void 0;
      state.lineWidth = void 0;
      state.miterLimit = void 0;
    }
    return state;
  }
  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   * @override
   */
  setFillStrokeStyle(fillStyle, strokeStyle) {
    const state = this.state;
    this.fillStyleToState(fillStyle, state);
    this.strokeStyleToState(strokeStyle, state);
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */
  createFill(state) {
    const fillStyle = state.fillStyle;
    const fillInstruction2 = [Instruction_default.SET_FILL_STYLE, fillStyle];
    if (typeof fillStyle !== "string") {
      fillInstruction2.push(state.fillPatternScale);
    }
    return fillInstruction2;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(state) {
    this.instructions.push(this.createStroke(state));
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */
  createStroke(state) {
    return [
      Instruction_default.SET_STROKE_STYLE,
      state.strokeStyle,
      state.lineWidth * this.pixelRatio,
      state.lineCap,
      state.lineJoin,
      state.miterLimit,
      state.lineDash ? this.applyPixelRatio(state.lineDash) : null,
      state.lineDashOffset * this.pixelRatio
    ];
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */
  updateFillStyle(state, createFill) {
    const fillStyle = state.fillStyle;
    if (typeof fillStyle !== "string" || state.currentFillStyle != fillStyle) {
      if (fillStyle !== void 0) {
        this.instructions.push(createFill.call(this, state));
      }
      state.currentFillStyle = fillStyle;
    }
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */
  updateStrokeStyle(state, applyStroke) {
    const strokeStyle = state.strokeStyle;
    const lineCap = state.lineCap;
    const lineDash = state.lineDash;
    const lineDashOffset = state.lineDashOffset;
    const lineJoin = state.lineJoin;
    const lineWidth = state.lineWidth;
    const miterLimit = state.miterLimit;
    if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
      if (strokeStyle !== void 0) {
        applyStroke.call(this, state);
      }
      state.currentStrokeStyle = strokeStyle;
      state.currentLineCap = lineCap;
      state.currentLineDash = lineDash;
      state.currentLineDashOffset = lineDashOffset;
      state.currentLineJoin = lineJoin;
      state.currentLineWidth = lineWidth;
      state.currentMiterLimit = miterLimit;
    }
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  endGeometry(feature) {
    this.beginGeometryInstruction1_[2] = this.instructions.length;
    this.beginGeometryInstruction1_ = null;
    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
    this.beginGeometryInstruction2_ = null;
    const endGeometryInstruction = [Instruction_default.END_GEOMETRY, feature];
    this.instructions.push(endGeometryInstruction);
    this.hitDetectionInstructions.push(endGeometryInstruction);
  }
  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */
  getBufferedMaxExtent() {
    if (!this.bufferedMaxExtent_) {
      this.bufferedMaxExtent_ = clone(this.maxExtent);
      if (this.maxLineWidth > 0) {
        const width = this.resolution * (this.maxLineWidth + 1) / 2;
        buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
      }
    }
    return this.bufferedMaxExtent_;
  }
};
var Builder_default = CanvasBuilder;

// node_modules/ol/render/canvas/ImageBuilder.js
var CanvasImageBuilder = class extends Builder_default {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super(tolerance, maxExtent, resolution, pixelRatio);
    this.hitDetectionImage_ = null;
    this.image_ = null;
    this.imagePixelRatio_ = void 0;
    this.anchorX_ = void 0;
    this.anchorY_ = void 0;
    this.height_ = void 0;
    this.opacity_ = void 0;
    this.originX_ = void 0;
    this.originY_ = void 0;
    this.rotateWithView_ = void 0;
    this.rotation_ = void 0;
    this.scale_ = void 0;
    this.width_ = void 0;
    this.declutterMode_ = void 0;
    this.declutterImageWithText_ = void 0;
  }
  /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawPoint(pointGeometry, feature, index) {
    if (!this.image_ || this.maxExtent && !containsCoordinate(this.maxExtent, pointGeometry.getFlatCoordinates())) {
      return;
    }
    this.beginGeometry(pointGeometry, feature, index);
    const flatCoordinates = pointGeometry.getFlatCoordinates();
    const stride = pointGeometry.getStride();
    const myBegin = this.coordinates.length;
    const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
    this.instructions.push([
      Instruction_default.DRAW_IMAGE,
      myBegin,
      myEnd,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]);
    this.hitDetectionInstructions.push([
      Instruction_default.DRAW_IMAGE,
      myBegin,
      myEnd,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]);
    this.endGeometry(feature);
  }
  /**
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawMultiPoint(multiPointGeometry, feature, index) {
    if (!this.image_) {
      return;
    }
    this.beginGeometry(multiPointGeometry, feature, index);
    const flatCoordinates = multiPointGeometry.getFlatCoordinates();
    const filteredFlatCoordinates = [];
    for (let i = 0, ii = flatCoordinates.length; i < ii; i += multiPointGeometry.getStride()) {
      if (!this.maxExtent || containsCoordinate(this.maxExtent, flatCoordinates.slice(i, i + 2))) {
        filteredFlatCoordinates.push(
          flatCoordinates[i],
          flatCoordinates[i + 1]
        );
      }
    }
    const myBegin = this.coordinates.length;
    const myEnd = this.appendFlatPointCoordinates(filteredFlatCoordinates, 2);
    this.instructions.push([
      Instruction_default.DRAW_IMAGE,
      myBegin,
      myEnd,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]);
    this.hitDetectionInstructions.push([
      Instruction_default.DRAW_IMAGE,
      myBegin,
      myEnd,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]);
    this.endGeometry(feature);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   * @override
   */
  finish() {
    this.reverseHitDetectionInstructions();
    this.anchorX_ = void 0;
    this.anchorY_ = void 0;
    this.hitDetectionImage_ = null;
    this.image_ = null;
    this.imagePixelRatio_ = void 0;
    this.height_ = void 0;
    this.scale_ = void 0;
    this.opacity_ = void 0;
    this.originX_ = void 0;
    this.originY_ = void 0;
    this.rotateWithView_ = void 0;
    this.rotation_ = void 0;
    this.width_ = void 0;
    return super.finish();
  }
  /**
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @param {Object} [sharedData] Shared data.
   * @override
   */
  setImageStyle(imageStyle, sharedData) {
    const anchor = imageStyle.getAnchor();
    const size = imageStyle.getSize();
    const origin = imageStyle.getOrigin();
    this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
    this.anchorX_ = anchor[0];
    this.anchorY_ = anchor[1];
    this.hitDetectionImage_ = imageStyle.getHitDetectionImage();
    this.image_ = imageStyle.getImage(this.pixelRatio);
    this.height_ = size[1];
    this.opacity_ = imageStyle.getOpacity();
    this.originX_ = origin[0];
    this.originY_ = origin[1];
    this.rotateWithView_ = imageStyle.getRotateWithView();
    this.rotation_ = imageStyle.getRotation();
    this.scale_ = imageStyle.getScaleArray();
    this.width_ = size[0];
    this.declutterMode_ = imageStyle.getDeclutterMode();
    this.declutterImageWithText_ = sharedData;
  }
};
var ImageBuilder_default = CanvasImageBuilder;

// node_modules/ol/render/canvas/LineStringBuilder.js
var CanvasLineStringBuilder = class extends Builder_default {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super(tolerance, maxExtent, resolution, pixelRatio);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */
  drawFlatCoordinates_(flatCoordinates, offset, end, stride) {
    const myBegin = this.coordinates.length;
    const myEnd = this.appendFlatLineCoordinates(
      flatCoordinates,
      offset,
      end,
      stride,
      false,
      false
    );
    const moveToLineToInstruction = [
      Instruction_default.MOVE_TO_LINE_TO,
      myBegin,
      myEnd
    ];
    this.instructions.push(moveToLineToInstruction);
    this.hitDetectionInstructions.push(moveToLineToInstruction);
    return end;
  }
  /**
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawLineString(lineStringGeometry, feature, index) {
    const state = this.state;
    const strokeStyle = state.strokeStyle;
    const lineWidth = state.lineWidth;
    if (strokeStyle === void 0 || lineWidth === void 0) {
      return;
    }
    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(lineStringGeometry, feature, index);
    this.hitDetectionInstructions.push(
      [
        Instruction_default.SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        defaultLineDash,
        defaultLineDashOffset
      ],
      beginPathInstruction
    );
    const flatCoordinates = lineStringGeometry.getFlatCoordinates();
    const stride = lineStringGeometry.getStride();
    this.drawFlatCoordinates_(
      flatCoordinates,
      0,
      flatCoordinates.length,
      stride
    );
    this.hitDetectionInstructions.push(strokeInstruction);
    this.endGeometry(feature);
  }
  /**
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawMultiLineString(multiLineStringGeometry, feature, index) {
    const state = this.state;
    const strokeStyle = state.strokeStyle;
    const lineWidth = state.lineWidth;
    if (strokeStyle === void 0 || lineWidth === void 0) {
      return;
    }
    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(multiLineStringGeometry, feature, index);
    this.hitDetectionInstructions.push(
      [
        Instruction_default.SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        defaultLineDash,
        defaultLineDashOffset
      ],
      beginPathInstruction
    );
    const ends = multiLineStringGeometry.getEnds();
    const flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
    const stride = multiLineStringGeometry.getStride();
    let offset = 0;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.drawFlatCoordinates_(
        flatCoordinates,
        offset,
        /** @type {number} */
        ends[i],
        stride
      );
    }
    this.hitDetectionInstructions.push(strokeInstruction);
    this.endGeometry(feature);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   * @override
   */
  finish() {
    const state = this.state;
    if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
      this.instructions.push(strokeInstruction);
    }
    this.reverseHitDetectionInstructions();
    this.state = null;
    return super.finish();
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @override
   */
  applyStroke(state) {
    if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
      this.instructions.push(strokeInstruction);
      state.lastStroke = this.coordinates.length;
    }
    state.lastStroke = 0;
    super.applyStroke(state);
    this.instructions.push(beginPathInstruction);
  }
};
var LineStringBuilder_default = CanvasLineStringBuilder;

// node_modules/ol/render/canvas/PolygonBuilder.js
var CanvasPolygonBuilder = class extends Builder_default {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super(tolerance, maxExtent, resolution, pixelRatio);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {
    const state = this.state;
    const fill = state.fillStyle !== void 0;
    const stroke = state.strokeStyle !== void 0;
    const numEnds = ends.length;
    this.instructions.push(beginPathInstruction);
    this.hitDetectionInstructions.push(beginPathInstruction);
    for (let i = 0; i < numEnds; ++i) {
      const end = ends[i];
      const myBegin = this.coordinates.length;
      const myEnd = this.appendFlatLineCoordinates(
        flatCoordinates,
        offset,
        end,
        stride,
        true,
        !stroke
      );
      const moveToLineToInstruction = [
        Instruction_default.MOVE_TO_LINE_TO,
        myBegin,
        myEnd
      ];
      this.instructions.push(moveToLineToInstruction);
      this.hitDetectionInstructions.push(moveToLineToInstruction);
      if (stroke) {
        this.instructions.push(closePathInstruction);
        this.hitDetectionInstructions.push(closePathInstruction);
      }
      offset = end;
    }
    if (fill) {
      this.instructions.push(fillInstruction);
      this.hitDetectionInstructions.push(fillInstruction);
    }
    if (stroke) {
      this.instructions.push(strokeInstruction);
      this.hitDetectionInstructions.push(strokeInstruction);
    }
    return offset;
  }
  /**
   * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawCircle(circleGeometry, feature, index) {
    const state = this.state;
    const fillStyle = state.fillStyle;
    const strokeStyle = state.strokeStyle;
    if (fillStyle === void 0 && strokeStyle === void 0) {
      return;
    }
    this.setFillStrokeStyles_();
    this.beginGeometry(circleGeometry, feature, index);
    if (state.fillStyle !== void 0) {
      this.hitDetectionInstructions.push([
        Instruction_default.SET_FILL_STYLE,
        defaultFillStyle
      ]);
    }
    if (state.strokeStyle !== void 0) {
      this.hitDetectionInstructions.push([
        Instruction_default.SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        defaultLineDash,
        defaultLineDashOffset
      ]);
    }
    const flatCoordinates = circleGeometry.getFlatCoordinates();
    const stride = circleGeometry.getStride();
    const myBegin = this.coordinates.length;
    this.appendFlatLineCoordinates(
      flatCoordinates,
      0,
      flatCoordinates.length,
      stride,
      false,
      false
    );
    const circleInstruction = [Instruction_default.CIRCLE, myBegin];
    this.instructions.push(beginPathInstruction, circleInstruction);
    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
    if (state.fillStyle !== void 0) {
      this.instructions.push(fillInstruction);
      this.hitDetectionInstructions.push(fillInstruction);
    }
    if (state.strokeStyle !== void 0) {
      this.instructions.push(strokeInstruction);
      this.hitDetectionInstructions.push(strokeInstruction);
    }
    this.endGeometry(feature);
  }
  /**
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawPolygon(polygonGeometry, feature, index) {
    const state = this.state;
    const fillStyle = state.fillStyle;
    const strokeStyle = state.strokeStyle;
    if (fillStyle === void 0 && strokeStyle === void 0) {
      return;
    }
    this.setFillStrokeStyles_();
    this.beginGeometry(polygonGeometry, feature, index);
    if (state.fillStyle !== void 0) {
      this.hitDetectionInstructions.push([
        Instruction_default.SET_FILL_STYLE,
        defaultFillStyle
      ]);
    }
    if (state.strokeStyle !== void 0) {
      this.hitDetectionInstructions.push([
        Instruction_default.SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        defaultLineDash,
        defaultLineDashOffset
      ]);
    }
    const ends = polygonGeometry.getEnds();
    const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
    const stride = polygonGeometry.getStride();
    this.drawFlatCoordinatess_(
      flatCoordinates,
      0,
      /** @type {Array<number>} */
      ends,
      stride
    );
    this.endGeometry(feature);
  }
  /**
   * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawMultiPolygon(multiPolygonGeometry, feature, index) {
    const state = this.state;
    const fillStyle = state.fillStyle;
    const strokeStyle = state.strokeStyle;
    if (fillStyle === void 0 && strokeStyle === void 0) {
      return;
    }
    this.setFillStrokeStyles_();
    this.beginGeometry(multiPolygonGeometry, feature, index);
    if (state.fillStyle !== void 0) {
      this.hitDetectionInstructions.push([
        Instruction_default.SET_FILL_STYLE,
        defaultFillStyle
      ]);
    }
    if (state.strokeStyle !== void 0) {
      this.hitDetectionInstructions.push([
        Instruction_default.SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        defaultLineDash,
        defaultLineDashOffset
      ]);
    }
    const endss = multiPolygonGeometry.getEndss();
    const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
    const stride = multiPolygonGeometry.getStride();
    let offset = 0;
    for (let i = 0, ii = endss.length; i < ii; ++i) {
      offset = this.drawFlatCoordinatess_(
        flatCoordinates,
        offset,
        endss[i],
        stride
      );
    }
    this.endGeometry(feature);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   * @override
   */
  finish() {
    this.reverseHitDetectionInstructions();
    this.state = null;
    const tolerance = this.tolerance;
    if (tolerance !== 0) {
      const coordinates2 = this.coordinates;
      for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
        coordinates2[i] = snap(coordinates2[i], tolerance);
      }
    }
    return super.finish();
  }
  /**
   * @private
   */
  setFillStrokeStyles_() {
    const state = this.state;
    const fillStyle = state.fillStyle;
    if (fillStyle !== void 0) {
      this.updateFillStyle(state, this.createFill);
    }
    if (state.strokeStyle !== void 0) {
      this.updateStrokeStyle(state, this.applyStroke);
    }
  }
};
var PolygonBuilder_default = CanvasPolygonBuilder;

// node_modules/ol/geom/flat/linechunk.js
function lineChunk(chunkLength, flatCoordinates, offset, end, stride) {
  const chunks = [];
  let cursor = offset;
  let chunkM = 0;
  let currentChunk = flatCoordinates.slice(offset, 2);
  while (chunkM < chunkLength && cursor + stride < end) {
    const [x1, y1] = currentChunk.slice(-2);
    const x2 = flatCoordinates[cursor + stride];
    const y2 = flatCoordinates[cursor + stride + 1];
    const segmentLength = Math.sqrt(
      (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)
    );
    chunkM += segmentLength;
    if (chunkM >= chunkLength) {
      const m = (chunkLength - chunkM + segmentLength) / segmentLength;
      const x = lerp(x1, x2, m);
      const y = lerp(y1, y2, m);
      currentChunk.push(x, y);
      chunks.push(currentChunk);
      currentChunk = [x, y];
      if (chunkM == chunkLength) {
        cursor += stride;
      }
      chunkM = 0;
    } else if (chunkM < chunkLength) {
      currentChunk.push(
        flatCoordinates[cursor + stride],
        flatCoordinates[cursor + stride + 1]
      );
      cursor += stride;
    } else {
      const missing = segmentLength - chunkM;
      const x = lerp(x1, x2, missing / segmentLength);
      const y = lerp(y1, y2, missing / segmentLength);
      currentChunk.push(x, y);
      chunks.push(currentChunk);
      currentChunk = [x, y];
      chunkM = 0;
      cursor += stride;
    }
  }
  if (chunkM > 0) {
    chunks.push(currentChunk);
  }
  return chunks;
}

// node_modules/ol/geom/flat/straightchunk.js
function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
  let chunkStart = offset;
  let chunkEnd = offset;
  let chunkM = 0;
  let m = 0;
  let start = offset;
  let acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
  for (i = offset; i < end; i += stride) {
    const x2 = flatCoordinates[i];
    const y2 = flatCoordinates[i + 1];
    if (x1 !== void 0) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);
      if (x12 !== void 0) {
        m += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
        if (acos > maxAngle) {
          if (m > chunkM) {
            chunkM = m;
            chunkStart = start;
            chunkEnd = i;
          }
          m = 0;
          start = i - stride;
        }
      }
      m12 = m23;
      x12 = x23;
      y12 = y23;
    }
    x1 = x2;
    y1 = y2;
  }
  m += m23;
  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
}

// node_modules/ol/render/canvas/TextBuilder.js
var TEXT_ALIGN = {
  "left": 0,
  "center": 0.5,
  "right": 1,
  "top": 0,
  "middle": 0.5,
  "hanging": 0.2,
  "alphabetic": 0.8,
  "ideographic": 0.8,
  "bottom": 1
};
var CanvasTextBuilder = class extends Builder_default {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super(tolerance, maxExtent, resolution, pixelRatio);
    this.labels_ = null;
    this.text_ = "";
    this.textOffsetX_ = 0;
    this.textOffsetY_ = 0;
    this.textRotateWithView_ = void 0;
    this.textKeepUpright_ = void 0;
    this.textRotation_ = 0;
    this.textFillState_ = null;
    this.fillStates = {};
    this.fillStates[defaultFillStyle] = { fillStyle: defaultFillStyle };
    this.textStrokeState_ = null;
    this.strokeStates = {};
    this.textState_ = /** @type {import("../canvas.js").TextState} */
    {};
    this.textStates = {};
    this.textKey_ = "";
    this.fillKey_ = "";
    this.strokeKey_ = "";
    this.declutterMode_ = void 0;
    this.declutterImageWithText_ = void 0;
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   * @override
   */
  finish() {
    const instructions = super.finish();
    instructions.textStates = this.textStates;
    instructions.fillStates = this.fillStates;
    instructions.strokeStates = this.strokeStates;
    return instructions;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawText(geometry, feature, index) {
    const fillState = this.textFillState_;
    const strokeState = this.textStrokeState_;
    const textState = this.textState_;
    if (this.text_ === "" || !textState || !fillState && !strokeState) {
      return;
    }
    const coordinates2 = this.coordinates;
    let begin = coordinates2.length;
    const geometryType = geometry.getType();
    let flatCoordinates = null;
    let stride = geometry.getStride();
    if (textState.placement === "line" && (geometryType == "LineString" || geometryType == "MultiLineString" || geometryType == "Polygon" || geometryType == "MultiPolygon")) {
      if (!intersects(this.maxExtent, geometry.getExtent())) {
        return;
      }
      let ends;
      flatCoordinates = geometry.getFlatCoordinates();
      if (geometryType == "LineString") {
        ends = [flatCoordinates.length];
      } else if (geometryType == "MultiLineString") {
        ends = /** @type {import("../../geom/MultiLineString.js").default} */
        geometry.getEnds();
      } else if (geometryType == "Polygon") {
        ends = /** @type {import("../../geom/Polygon.js").default} */
        geometry.getEnds().slice(0, 1);
      } else if (geometryType == "MultiPolygon") {
        const endss = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          geometry.getEndss()
        );
        ends = [];
        for (let i = 0, ii = endss.length; i < ii; ++i) {
          ends.push(endss[i][0]);
        }
      }
      this.beginGeometry(geometry, feature, index);
      const repeat = textState.repeat;
      const textAlign = repeat ? void 0 : textState.textAlign;
      let flatOffset = 0;
      for (let o = 0, oo = ends.length; o < oo; ++o) {
        let chunks;
        if (repeat) {
          chunks = lineChunk(
            repeat * this.resolution,
            flatCoordinates,
            flatOffset,
            ends[o],
            stride
          );
        } else {
          chunks = [flatCoordinates.slice(flatOffset, ends[o])];
        }
        for (let c = 0, cc = chunks.length; c < cc; ++c) {
          const chunk = chunks[c];
          let chunkBegin = 0;
          let chunkEnd = chunk.length;
          if (textAlign == void 0) {
            const range = matchingChunk(
              textState.maxAngle,
              chunk,
              0,
              chunk.length,
              2
            );
            chunkBegin = range[0];
            chunkEnd = range[1];
          }
          for (let i = chunkBegin; i < chunkEnd; i += stride) {
            coordinates2.push(chunk[i], chunk[i + 1]);
          }
          const end = coordinates2.length;
          flatOffset = ends[o];
          this.drawChars_(begin, end);
          begin = end;
        }
      }
      this.endGeometry(feature);
    } else {
      let geometryWidths = textState.overflow ? null : [];
      switch (geometryType) {
        case "Point":
        case "MultiPoint":
          flatCoordinates = /** @type {import("../../geom/MultiPoint.js").default} */
          geometry.getFlatCoordinates();
          break;
        case "LineString":
          flatCoordinates = /** @type {import("../../geom/LineString.js").default} */
          geometry.getFlatMidpoint();
          break;
        case "Circle":
          flatCoordinates = /** @type {import("../../geom/Circle.js").default} */
          geometry.getCenter();
          break;
        case "MultiLineString":
          flatCoordinates = /** @type {import("../../geom/MultiLineString.js").default} */
          geometry.getFlatMidpoints();
          stride = 2;
          break;
        case "Polygon":
          flatCoordinates = /** @type {import("../../geom/Polygon.js").default} */
          geometry.getFlatInteriorPoint();
          if (!textState.overflow) {
            geometryWidths.push(flatCoordinates[2] / this.resolution);
          }
          stride = 3;
          break;
        case "MultiPolygon":
          const interiorPoints = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            geometry.getFlatInteriorPoints()
          );
          flatCoordinates = [];
          for (let i = 0, ii = interiorPoints.length; i < ii; i += 3) {
            if (!textState.overflow) {
              geometryWidths.push(interiorPoints[i + 2] / this.resolution);
            }
            flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
          }
          if (flatCoordinates.length === 0) {
            return;
          }
          stride = 2;
          break;
        default:
      }
      const end = this.appendFlatPointCoordinates(flatCoordinates, stride);
      if (end === begin) {
        return;
      }
      if (geometryWidths && (end - begin) / 2 !== flatCoordinates.length / stride) {
        let beg = begin / 2;
        geometryWidths = geometryWidths.filter((w, i) => {
          const keep = coordinates2[(beg + i) * 2] === flatCoordinates[i * stride] && coordinates2[(beg + i) * 2 + 1] === flatCoordinates[i * stride + 1];
          if (!keep) {
            --beg;
          }
          return keep;
        });
      }
      this.saveTextStates_();
      const backgroundFill = textState.backgroundFill ? this.createFill(this.fillStyleToState(textState.backgroundFill)) : null;
      const backgroundStroke = textState.backgroundStroke ? this.createStroke(this.strokeStyleToState(textState.backgroundStroke)) : null;
      this.beginGeometry(geometry, feature, index);
      let padding = textState.padding;
      if (padding != defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {
        let p0 = textState.padding[0];
        let p12 = textState.padding[1];
        let p22 = textState.padding[2];
        let p32 = textState.padding[3];
        if (textState.scale[0] < 0) {
          p12 = -p12;
          p32 = -p32;
        }
        if (textState.scale[1] < 0) {
          p0 = -p0;
          p22 = -p22;
        }
        padding = [p0, p12, p22, p32];
      }
      const pixelRatio = this.pixelRatio;
      this.instructions.push([
        Instruction_default.DRAW_IMAGE,
        begin,
        end,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [1, 1],
        NaN,
        this.declutterMode_,
        this.declutterImageWithText_,
        padding == defaultPadding ? defaultPadding : padding.map(function(p) {
          return p * pixelRatio;
        }),
        backgroundFill,
        backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        geometryWidths
      ]);
      const scale4 = 1 / pixelRatio;
      const hitDetectionBackgroundFill = backgroundFill ? backgroundFill.slice(0) : null;
      if (hitDetectionBackgroundFill) {
        hitDetectionBackgroundFill[1] = defaultFillStyle;
      }
      this.hitDetectionInstructions.push([
        Instruction_default.DRAW_IMAGE,
        begin,
        end,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [scale4, scale4],
        NaN,
        this.declutterMode_,
        this.declutterImageWithText_,
        padding,
        hitDetectionBackgroundFill,
        backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_ ? defaultFillStyle : this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        geometryWidths
      ]);
      this.endGeometry(feature);
    }
  }
  /**
   * @private
   */
  saveTextStates_() {
    const strokeState = this.textStrokeState_;
    const textState = this.textState_;
    const fillState = this.textFillState_;
    const strokeKey = this.strokeKey_;
    if (strokeState) {
      if (!(strokeKey in this.strokeStates)) {
        this.strokeStates[strokeKey] = {
          strokeStyle: strokeState.strokeStyle,
          lineCap: strokeState.lineCap,
          lineDashOffset: strokeState.lineDashOffset,
          lineWidth: strokeState.lineWidth,
          lineJoin: strokeState.lineJoin,
          miterLimit: strokeState.miterLimit,
          lineDash: strokeState.lineDash
        };
      }
    }
    const textKey = this.textKey_;
    if (!(textKey in this.textStates)) {
      this.textStates[textKey] = {
        font: textState.font,
        textAlign: textState.textAlign || defaultTextAlign,
        justify: textState.justify,
        textBaseline: textState.textBaseline || defaultTextBaseline,
        scale: textState.scale
      };
    }
    const fillKey = this.fillKey_;
    if (fillState) {
      if (!(fillKey in this.fillStates)) {
        this.fillStates[fillKey] = {
          fillStyle: fillState.fillStyle
        };
      }
    }
  }
  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   */
  drawChars_(begin, end) {
    const strokeState = this.textStrokeState_;
    const textState = this.textState_;
    const strokeKey = this.strokeKey_;
    const textKey = this.textKey_;
    const fillKey = this.fillKey_;
    this.saveTextStates_();
    const pixelRatio = this.pixelRatio;
    const baseline = TEXT_ALIGN[textState.textBaseline];
    const offsetY = this.textOffsetY_ * pixelRatio;
    const text = this.text_;
    const strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
    this.instructions.push([
      Instruction_default.DRAW_CHARS,
      begin,
      end,
      baseline,
      textState.overflow,
      fillKey,
      textState.maxAngle,
      pixelRatio,
      offsetY,
      strokeKey,
      strokeWidth * pixelRatio,
      text,
      textKey,
      1,
      this.declutterMode_,
      this.textKeepUpright_
    ]);
    this.hitDetectionInstructions.push([
      Instruction_default.DRAW_CHARS,
      begin,
      end,
      baseline,
      textState.overflow,
      fillKey ? defaultFillStyle : fillKey,
      textState.maxAngle,
      pixelRatio,
      offsetY,
      strokeKey,
      strokeWidth * pixelRatio,
      text,
      textKey,
      1 / pixelRatio,
      this.declutterMode_,
      this.textKeepUpright_
    ]);
  }
  /**
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @param {Object} [sharedData] Shared data.
   * @override
   */
  setTextStyle(textStyle, sharedData) {
    let textState, fillState, strokeState;
    if (!textStyle) {
      this.text_ = "";
    } else {
      const textFillStyle = textStyle.getFill();
      if (!textFillStyle) {
        fillState = null;
        this.textFillState_ = fillState;
      } else {
        fillState = this.textFillState_;
        if (!fillState) {
          fillState = /** @type {import("../canvas.js").FillState} */
          {};
          this.textFillState_ = fillState;
        }
        fillState.fillStyle = asColorLike(
          textFillStyle.getColor() || defaultFillStyle
        );
      }
      const textStrokeStyle = textStyle.getStroke();
      if (!textStrokeStyle) {
        strokeState = null;
        this.textStrokeState_ = strokeState;
      } else {
        strokeState = this.textStrokeState_;
        if (!strokeState) {
          strokeState = /** @type {import("../canvas.js").StrokeState} */
          {};
          this.textStrokeState_ = strokeState;
        }
        const lineDash = textStrokeStyle.getLineDash();
        const lineDashOffset = textStrokeStyle.getLineDashOffset();
        const lineWidth = textStrokeStyle.getWidth();
        const miterLimit = textStrokeStyle.getMiterLimit();
        strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;
        strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;
        strokeState.lineDashOffset = lineDashOffset === void 0 ? defaultLineDashOffset : lineDashOffset;
        strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;
        strokeState.lineWidth = lineWidth === void 0 ? defaultLineWidth : lineWidth;
        strokeState.miterLimit = miterLimit === void 0 ? defaultMiterLimit : miterLimit;
        strokeState.strokeStyle = asColorLike(
          textStrokeStyle.getColor() || defaultStrokeStyle
        );
      }
      textState = this.textState_;
      const font = textStyle.getFont() || defaultFont;
      registerFont(font);
      const textScale = textStyle.getScaleArray();
      textState.overflow = textStyle.getOverflow();
      textState.font = font;
      textState.maxAngle = textStyle.getMaxAngle();
      textState.placement = textStyle.getPlacement();
      textState.textAlign = textStyle.getTextAlign();
      textState.repeat = textStyle.getRepeat();
      textState.justify = textStyle.getJustify();
      textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;
      textState.backgroundFill = textStyle.getBackgroundFill();
      textState.backgroundStroke = textStyle.getBackgroundStroke();
      textState.padding = textStyle.getPadding() || defaultPadding;
      textState.scale = textScale === void 0 ? [1, 1] : textScale;
      const textOffsetX = textStyle.getOffsetX();
      const textOffsetY = textStyle.getOffsetY();
      const textRotateWithView = textStyle.getRotateWithView();
      const textKeepUpright = textStyle.getKeepUpright();
      const textRotation = textStyle.getRotation();
      this.text_ = textStyle.getText() || "";
      this.textOffsetX_ = textOffsetX === void 0 ? 0 : textOffsetX;
      this.textOffsetY_ = textOffsetY === void 0 ? 0 : textOffsetY;
      this.textRotateWithView_ = textRotateWithView === void 0 ? false : textRotateWithView;
      this.textKeepUpright_ = textKeepUpright === void 0 ? true : textKeepUpright;
      this.textRotation_ = textRotation === void 0 ? 0 : textRotation;
      this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == "string" ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + "|" + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + "[" + strokeState.lineDash.join() + "]" : "";
      this.textKey_ = textState.font + textState.scale + (textState.textAlign || "?") + (textState.repeat || "?") + (textState.justify || "?") + (textState.textBaseline || "?");
      this.fillKey_ = fillState && fillState.fillStyle ? typeof fillState.fillStyle == "string" ? fillState.fillStyle : "|" + getUid(fillState.fillStyle) : "";
    }
    this.declutterMode_ = textStyle.getDeclutterMode();
    this.declutterImageWithText_ = sharedData;
  }
};
var TextBuilder_default = CanvasTextBuilder;

// node_modules/ol/render/canvas/BuilderGroup.js
var BATCH_CONSTRUCTORS = {
  "Circle": PolygonBuilder_default,
  "Default": Builder_default,
  "Image": ImageBuilder_default,
  "LineString": LineStringBuilder_default,
  "Polygon": PolygonBuilder_default,
  "Text": TextBuilder_default
};
var BuilderGroup = class {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    this.tolerance_ = tolerance;
    this.maxExtent_ = maxExtent;
    this.pixelRatio_ = pixelRatio;
    this.resolution_ = resolution;
    this.buildersByZIndex_ = {};
  }
  /**
   * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */
  finish() {
    const builderInstructions = {};
    for (const zKey in this.buildersByZIndex_) {
      builderInstructions[zKey] = builderInstructions[zKey] || {};
      const builders = this.buildersByZIndex_[zKey];
      for (const builderKey in builders) {
        const builderInstruction = builders[builderKey].finish();
        builderInstructions[zKey][builderKey] = builderInstruction;
      }
    }
    return builderInstructions;
  }
  /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("../canvas.js").BuilderType} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */
  getBuilder(zIndex, builderType) {
    const zIndexKey = zIndex !== void 0 ? zIndex.toString() : "0";
    let replays = this.buildersByZIndex_[zIndexKey];
    if (replays === void 0) {
      replays = {};
      this.buildersByZIndex_[zIndexKey] = replays;
    }
    let replay = replays[builderType];
    if (replay === void 0) {
      const Constructor = BATCH_CONSTRUCTORS[builderType];
      replay = new Constructor(
        this.tolerance_,
        this.maxExtent_,
        this.resolution_,
        this.pixelRatio_
      );
      replays[builderType] = replay;
    }
    return replay;
  }
};
var BuilderGroup_default = BuilderGroup;

// node_modules/ol/geom/flat/textpath.js
function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale4, measureAndCacheTextWidth2, font, cache3, rotation, keepUpright = true) {
  let x2 = flatCoordinates[offset];
  let y2 = flatCoordinates[offset + 1];
  let x1 = 0;
  let y1 = 0;
  let segmentLength = 0;
  let segmentM = 0;
  function advance() {
    x1 = x2;
    y1 = y2;
    offset += stride;
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    segmentM += segmentLength;
    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }
  do {
    advance();
  } while (offset < end - stride && segmentM + segmentLength < startM);
  let interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
  const beginX = lerp(x1, x2, interpolate);
  const beginY = lerp(y1, y2, interpolate);
  const startOffset = offset - stride;
  const startLength = segmentM;
  const endM = startM + scale4 * measureAndCacheTextWidth2(font, text, cache3);
  while (offset < end - stride && segmentM + segmentLength < endM) {
    advance();
  }
  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
  const endX = lerp(x1, x2, interpolate);
  const endY = lerp(y1, y2, interpolate);
  let reverse = false;
  if (keepUpright) {
    if (rotation) {
      const flat = [beginX, beginY, endX, endY];
      rotate2(flat, 0, 4, 2, rotation, flat, flat);
      reverse = flat[0] > flat[2];
    } else {
      reverse = beginX > endX;
    }
  }
  const PI = Math.PI;
  const result = [];
  const singleSegment = startOffset + stride === offset;
  offset = startOffset;
  segmentLength = 0;
  segmentM = startLength;
  x2 = flatCoordinates[offset];
  y2 = flatCoordinates[offset + 1];
  let previousAngle;
  if (singleSegment) {
    advance();
    previousAngle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      previousAngle += previousAngle > 0 ? -PI : PI;
    }
    const x = (endX + beginX) / 2;
    const y = (endY + beginY) / 2;
    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];
    return result;
  }
  text = text.replace(/\n/g, " ");
  for (let i = 0, ii = text.length; i < ii; ) {
    advance();
    let angle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      angle += angle > 0 ? -PI : PI;
    }
    if (previousAngle !== void 0) {
      let delta = angle - previousAngle;
      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }
    previousAngle = angle;
    const iStart = i;
    let charLength = 0;
    for (; i < ii; ++i) {
      const index = reverse ? ii - i - 1 : i;
      const len = scale4 * measureAndCacheTextWidth2(font, text[index], cache3);
      if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {
        break;
      }
      charLength += len;
    }
    if (i === iStart) {
      continue;
    }
    const chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);
    interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;
    const x = lerp(x1, x2, interpolate);
    const y = lerp(y1, y2, interpolate);
    result.push([x, y, charLength / 2, angle, chars]);
    startM += charLength;
  }
  return result;
}

// node_modules/ol/render/canvas/ZIndexContext.js
var ZIndexContext = class {
  constructor() {
    this.instructions_ = [];
    this.zIndex = 0;
    this.offset_ = 0;
    this.context_ = /** @type {ZIndexContextProxy} */
    new Proxy(getSharedCanvasContext2D(), {
      get: (target, property) => {
        if (typeof /** @type {*} */
        getSharedCanvasContext2D()[property] !== "function") {
          return void 0;
        }
        this.push_(property);
        return this.pushMethodArgs_;
      },
      set: (target, property, value) => {
        this.push_(property, value);
        return true;
      }
    });
  }
  /**
   * @param {...*} args Arguments to push to the instructions array.
   * @private
   */
  push_(...args) {
    const instructions = this.instructions_;
    const index = this.zIndex + this.offset_;
    if (!instructions[index]) {
      instructions[index] = [];
    }
    instructions[index].push(...args);
  }
  /**
   * @private
   * @param {...*} args Args.
   * @return {ZIndexContext} This.
   */
  pushMethodArgs_ = (...args) => {
    this.push_(args);
    return this;
  };
  /**
   * Push a function that renders to the context directly.
   * @param {function(CanvasRenderingContext2D): void} render Function.
   */
  pushFunction(render2) {
    this.push_(render2);
  }
  /**
   * Get a proxy for CanvasRenderingContext2D which does not support getting state
   * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a
   * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,
   * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.
   * @return {ZIndexContextProxy} Context.
   */
  getContext() {
    return this.context_;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   */
  draw(context) {
    this.instructions_.forEach((instructionsAtIndex) => {
      for (let i = 0, ii = instructionsAtIndex.length; i < ii; ++i) {
        const property = instructionsAtIndex[i];
        if (typeof property === "function") {
          property(context);
          continue;
        }
        const instructionAtIndex = instructionsAtIndex[++i];
        if (typeof /** @type {*} */
        context[property] === "function") {
          context[property](...instructionAtIndex);
        } else {
          if (typeof instructionAtIndex === "function") {
            context[property] = instructionAtIndex(context);
            continue;
          }
          context[property] = instructionAtIndex;
        }
      }
    });
  }
  clear() {
    this.instructions_.length = 0;
    this.zIndex = 0;
    this.offset_ = 0;
  }
  /**
   * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to
   * avoid conflicting context.clip() or context.save()/restore() calls.
   */
  offset() {
    this.offset_ = this.instructions_.length;
    this.zIndex = 0;
  }
};
var ZIndexContext_default = ZIndexContext;

// node_modules/ol/render/canvas/Executor.js
var tmpExtent = createEmpty();
var p1 = [];
var p2 = [];
var p3 = [];
var p4 = [];
function getDeclutterBox(replayImageOrLabelArgs) {
  return replayImageOrLabelArgs[3].declutterBox;
}
var rtlRegEx = new RegExp(
  /* eslint-disable prettier/prettier */
  "[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]"
  /* eslint-enable prettier/prettier */
);
function horizontalTextAlign(text, align) {
  if (align === "start") {
    align = rtlRegEx.test(text) ? "right" : "left";
  } else if (align === "end") {
    align = rtlRegEx.test(text) ? "left" : "right";
  }
  return TEXT_ALIGN[align];
}
function createTextChunks(acc, line, i) {
  if (i > 0) {
    acc.push("\n", "");
  }
  acc.push(line, "");
  return acc;
}
function richTextToPlainText(result, part, index) {
  if (index % 2 === 0) {
    result += part;
  }
  return result;
}
var Executor = class {
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions.
   * @param {boolean} [deferredRendering] Enable deferred rendering.
   */
  constructor(resolution, pixelRatio, overlaps, instructions, deferredRendering) {
    this.overlaps = overlaps;
    this.pixelRatio = pixelRatio;
    this.resolution = resolution;
    this.alignAndScaleFill_;
    this.instructions = instructions.instructions;
    this.coordinates = instructions.coordinates;
    this.coordinateCache_ = {};
    this.renderedTransform_ = create();
    this.hitDetectionInstructions = instructions.hitDetectionInstructions;
    this.pixelCoordinates_ = null;
    this.viewRotation_ = 0;
    this.fillStates = instructions.fillStates || {};
    this.strokeStates = instructions.strokeStates || {};
    this.textStates = instructions.textStates || {};
    this.widths_ = {};
    this.labels_ = {};
    this.zIndexContext_ = deferredRendering ? new ZIndexContext_default() : null;
  }
  /**
   * @return {ZIndexContext} ZIndex context.
   */
  getZIndexContext() {
    return this.zIndexContext_;
  }
  /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */
  createLabel(text, textKey, fillKey, strokeKey) {
    const key = text + textKey + fillKey + strokeKey;
    if (this.labels_[key]) {
      return this.labels_[key];
    }
    const strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
    const fillState = fillKey ? this.fillStates[fillKey] : null;
    const textState = this.textStates[textKey];
    const pixelRatio = this.pixelRatio;
    const scale4 = [
      textState.scale[0] * pixelRatio,
      textState.scale[1] * pixelRatio
    ];
    const align = textState.justify ? TEXT_ALIGN[textState.justify] : horizontalTextAlign(
      Array.isArray(text) ? text[0] : text,
      textState.textAlign || defaultTextAlign
    );
    const strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
    const chunks = Array.isArray(text) ? text : String(text).split("\n").reduce(createTextChunks, []);
    const { width, height, widths, heights, lineWidths } = getTextDimensions(
      textState,
      chunks
    );
    const renderWidth = width + strokeWidth;
    const contextInstructions = [];
    const w = (renderWidth + 2) * scale4[0];
    const h = (height + strokeWidth) * scale4[1];
    const label = {
      width: w < 0 ? Math.floor(w) : Math.ceil(w),
      height: h < 0 ? Math.floor(h) : Math.ceil(h),
      contextInstructions
    };
    if (scale4[0] != 1 || scale4[1] != 1) {
      contextInstructions.push("scale", scale4);
    }
    if (strokeKey) {
      contextInstructions.push("strokeStyle", strokeState.strokeStyle);
      contextInstructions.push("lineWidth", strokeWidth);
      contextInstructions.push("lineCap", strokeState.lineCap);
      contextInstructions.push("lineJoin", strokeState.lineJoin);
      contextInstructions.push("miterLimit", strokeState.miterLimit);
      contextInstructions.push("setLineDash", [strokeState.lineDash]);
      contextInstructions.push("lineDashOffset", strokeState.lineDashOffset);
    }
    if (fillKey) {
      contextInstructions.push("fillStyle", fillState.fillStyle);
    }
    contextInstructions.push("textBaseline", "middle");
    contextInstructions.push("textAlign", "center");
    const leftRight = 0.5 - align;
    let x = align * renderWidth + leftRight * strokeWidth;
    const strokeInstructions = [];
    const fillInstructions = [];
    let lineHeight = 0;
    let lineOffset = 0;
    let widthHeightIndex = 0;
    let lineWidthIndex = 0;
    let previousFont;
    for (let i = 0, ii = chunks.length; i < ii; i += 2) {
      const text2 = chunks[i];
      if (text2 === "\n") {
        lineOffset += lineHeight;
        lineHeight = 0;
        x = align * renderWidth + leftRight * strokeWidth;
        ++lineWidthIndex;
        continue;
      }
      const font = chunks[i + 1] || textState.font;
      if (font !== previousFont) {
        if (strokeKey) {
          strokeInstructions.push("font", font);
        }
        if (fillKey) {
          fillInstructions.push("font", font);
        }
        previousFont = font;
      }
      lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);
      const fillStrokeArgs = [
        text2,
        x + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),
        0.5 * (strokeWidth + lineHeight) + lineOffset
      ];
      x += widths[widthHeightIndex];
      if (strokeKey) {
        strokeInstructions.push("strokeText", fillStrokeArgs);
      }
      if (fillKey) {
        fillInstructions.push("fillText", fillStrokeArgs);
      }
      ++widthHeightIndex;
    }
    Array.prototype.push.apply(contextInstructions, strokeInstructions);
    Array.prototype.push.apply(contextInstructions, fillInstructions);
    this.labels_[key] = label;
    return label;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */
  replayTextBackground_(context, p12, p22, p32, p42, fillInstruction2, strokeInstruction2) {
    context.beginPath();
    context.moveTo.apply(context, p12);
    context.lineTo.apply(context, p22);
    context.lineTo.apply(context, p32);
    context.lineTo.apply(context, p42);
    context.lineTo.apply(context, p12);
    if (fillInstruction2) {
      this.alignAndScaleFill_ = /** @type {number} */
      fillInstruction2[2];
      context.fillStyle = /** @type {string} */
      fillInstruction2[1];
      this.fill_(context);
    }
    if (strokeInstruction2) {
      this.setStrokeStyle_(
        context,
        /** @type {Array<*>} */
        strokeInstruction2
      );
      context.stroke();
    }
  }
  /**
   * @private
   * @param {number} sheetWidth Width of the sprite sheet.
   * @param {number} sheetHeight Height of the sprite sheet.
   * @param {number} centerX X.
   * @param {number} centerY Y.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {import("../../size.js").Size} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {Array<number>} padding Padding.
   * @param {boolean} fillStroke Background fill or stroke.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
   */
  calculateImageOrLabelDimensions_(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale4, snapToPixel, padding, fillStroke, feature) {
    anchorX *= scale4[0];
    anchorY *= scale4[1];
    let x = centerX - anchorX;
    let y = centerY - anchorY;
    const w = width + originX > sheetWidth ? sheetWidth - originX : width;
    const h = height + originY > sheetHeight ? sheetHeight - originY : height;
    const boxW = padding[3] + w * scale4[0] + padding[1];
    const boxH = padding[0] + h * scale4[1] + padding[2];
    const boxX = x - padding[3];
    const boxY = y - padding[0];
    if (fillStroke || rotation !== 0) {
      p1[0] = boxX;
      p4[0] = boxX;
      p1[1] = boxY;
      p2[1] = boxY;
      p2[0] = boxX + boxW;
      p3[0] = p2[0];
      p3[1] = boxY + boxH;
      p4[1] = p3[1];
    }
    let transform2;
    if (rotation !== 0) {
      transform2 = compose(
        create(),
        centerX,
        centerY,
        1,
        1,
        rotation,
        -centerX,
        -centerY
      );
      apply(transform2, p1);
      apply(transform2, p2);
      apply(transform2, p3);
      apply(transform2, p4);
      createOrUpdate(
        Math.min(p1[0], p2[0], p3[0], p4[0]),
        Math.min(p1[1], p2[1], p3[1], p4[1]),
        Math.max(p1[0], p2[0], p3[0], p4[0]),
        Math.max(p1[1], p2[1], p3[1], p4[1]),
        tmpExtent
      );
    } else {
      createOrUpdate(
        Math.min(boxX, boxX + boxW),
        Math.min(boxY, boxY + boxH),
        Math.max(boxX, boxX + boxW),
        Math.max(boxY, boxY + boxH),
        tmpExtent
      );
    }
    if (snapToPixel) {
      x = Math.round(x);
      y = Math.round(y);
    }
    return {
      drawImageX: x,
      drawImageY: y,
      drawImageW: w,
      drawImageH: h,
      originX,
      originY,
      declutterBox: {
        minX: tmpExtent[0],
        minY: tmpExtent[1],
        maxX: tmpExtent[2],
        maxY: tmpExtent[3],
        value: feature
      },
      canvasTransform: transform2,
      scale: scale4
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {ImageOrLabelDimensions} dimensions Dimensions.
   * @param {number} opacity Opacity.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   * @return {boolean} The image or label was rendered.
   */
  replayImageOrLabel_(context, scaledCanvasSize, imageOrLabel, dimensions, opacity, fillInstruction2, strokeInstruction2) {
    const fillStroke = !!(fillInstruction2 || strokeInstruction2);
    const box = dimensions.declutterBox;
    const strokePadding = strokeInstruction2 ? strokeInstruction2[2] * dimensions.scale[0] / 2 : 0;
    const intersects3 = box.minX - strokePadding <= scaledCanvasSize[0] && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= scaledCanvasSize[1] && box.maxY + strokePadding >= 0;
    if (intersects3) {
      if (fillStroke) {
        this.replayTextBackground_(
          context,
          p1,
          p2,
          p3,
          p4,
          /** @type {Array<*>} */
          fillInstruction2,
          /** @type {Array<*>} */
          strokeInstruction2
        );
      }
      drawImageOrLabel(
        context,
        dimensions.canvasTransform,
        opacity,
        imageOrLabel,
        dimensions.originX,
        dimensions.originY,
        dimensions.drawImageW,
        dimensions.drawImageH,
        dimensions.drawImageX,
        dimensions.drawImageY,
        dimensions.scale
      );
    }
    return true;
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */
  fill_(context) {
    const alignAndScale = this.alignAndScaleFill_;
    if (alignAndScale) {
      const origin = apply(this.renderedTransform_, [0, 0]);
      const repeatSize = 512 * this.pixelRatio;
      context.save();
      context.translate(origin[0] % repeatSize, origin[1] % repeatSize);
      if (alignAndScale !== 1) {
        context.scale(alignAndScale, alignAndScale);
      }
      context.rotate(this.viewRotation_);
    }
    context.fill();
    if (alignAndScale) {
      context.restore();
    }
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */
  setStrokeStyle_(context, instruction) {
    context.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */
    instruction[1];
    context.lineWidth = /** @type {number} */
    instruction[2];
    context.lineCap = /** @type {CanvasLineCap} */
    instruction[3];
    context.lineJoin = /** @type {CanvasLineJoin} */
    instruction[4];
    context.miterLimit = /** @type {number} */
    instruction[5];
    context.lineDashOffset = /** @type {number} */
    instruction[7];
    context.setLineDash(
      /** @type {Array<number>} */
      instruction[6]
    );
  }
  /**
   * @private
   * @param {string|Array<string>} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */
  drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey) {
    const textState = this.textStates[textKey];
    const label = this.createLabel(text, textKey, fillKey, strokeKey);
    const strokeState = this.strokeStates[strokeKey];
    const pixelRatio = this.pixelRatio;
    const align = horizontalTextAlign(
      Array.isArray(text) ? text[0] : text,
      textState.textAlign || defaultTextAlign
    );
    const baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];
    const strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
    const width = label.width / pixelRatio - 2 * textState.scale[0];
    const anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
    const anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
    return {
      label,
      anchorX,
      anchorY
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @param {import("rbush").default<DeclutterEntry>} [declutterTree] Declutter tree.
   * @return {T|undefined} Callback result.
   * @template T
   */
  execute_(context, scaledCanvasSize, transform2, instructions, snapToPixel, featureCallback, hitExtent, declutterTree) {
    const zIndexContext = this.zIndexContext_;
    let pixelCoordinates;
    if (this.pixelCoordinates_ && equals(transform2, this.renderedTransform_)) {
      pixelCoordinates = this.pixelCoordinates_;
    } else {
      if (!this.pixelCoordinates_) {
        this.pixelCoordinates_ = [];
      }
      pixelCoordinates = transform2D(
        this.coordinates,
        0,
        this.coordinates.length,
        2,
        transform2,
        this.pixelCoordinates_
      );
      setFromArray(this.renderedTransform_, transform2);
    }
    let i = 0;
    const ii = instructions.length;
    let d = 0;
    let dd;
    let anchorX, anchorY, declutterMode, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;
    let pendingFill = 0;
    let pendingStroke = 0;
    const coordinateCache = this.coordinateCache_;
    const viewRotation = this.viewRotation_;
    const viewRotationFromTransform = Math.round(Math.atan2(-transform2[1], transform2[0]) * 1e12) / 1e12;
    const state = (
      /** @type {import("../../render.js").State} */
      {
        context,
        pixelRatio: this.pixelRatio,
        resolution: this.resolution,
        rotation: viewRotation
      }
    );
    const batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
    let feature;
    let x, y, currentGeometry;
    while (i < ii) {
      const instruction = instructions[i];
      const type = (
        /** @type {import("./Instruction.js").default} */
        instruction[0]
      );
      switch (type) {
        case Instruction_default.BEGIN_GEOMETRY:
          feature = /** @type {import("../../Feature.js").FeatureLike} */
          instruction[1];
          currentGeometry = instruction[3];
          if (!feature.getGeometry()) {
            i = /** @type {number} */
            instruction[2];
          } else if (hitExtent !== void 0 && !intersects(hitExtent, currentGeometry.getExtent())) {
            i = /** @type {number} */
            instruction[2] + 1;
          } else {
            ++i;
          }
          if (zIndexContext) {
            zIndexContext.zIndex = instruction[4];
          }
          break;
        case Instruction_default.BEGIN_PATH:
          if (pendingFill > batchSize) {
            this.fill_(context);
            pendingFill = 0;
          }
          if (pendingStroke > batchSize) {
            context.stroke();
            pendingStroke = 0;
          }
          if (!pendingFill && !pendingStroke) {
            context.beginPath();
            prevX = NaN;
            prevY = NaN;
          }
          ++i;
          break;
        case Instruction_default.CIRCLE:
          d = /** @type {number} */
          instruction[1];
          const x1 = pixelCoordinates[d];
          const y1 = pixelCoordinates[d + 1];
          const x2 = pixelCoordinates[d + 2];
          const y2 = pixelCoordinates[d + 3];
          const dx = x2 - x1;
          const dy = y2 - y1;
          const r = Math.sqrt(dx * dx + dy * dy);
          context.moveTo(x1 + r, y1);
          context.arc(x1, y1, r, 0, 2 * Math.PI, true);
          ++i;
          break;
        case Instruction_default.CLOSE_PATH:
          context.closePath();
          ++i;
          break;
        case Instruction_default.CUSTOM:
          d = /** @type {number} */
          instruction[1];
          dd = instruction[2];
          const geometry = (
            /** @type {import("../../geom/SimpleGeometry.js").default} */
            instruction[3]
          );
          const renderer = instruction[4];
          const fn = instruction[5];
          state.geometry = geometry;
          state.feature = feature;
          if (!(i in coordinateCache)) {
            coordinateCache[i] = [];
          }
          const coords = coordinateCache[i];
          if (fn) {
            fn(pixelCoordinates, d, dd, 2, coords);
          } else {
            coords[0] = pixelCoordinates[d];
            coords[1] = pixelCoordinates[d + 1];
            coords.length = 2;
          }
          if (zIndexContext) {
            zIndexContext.zIndex = instruction[6];
          }
          renderer(coords, state);
          ++i;
          break;
        case Instruction_default.DRAW_IMAGE:
          d = /** @type {number} */
          instruction[1];
          dd = /** @type {number} */
          instruction[2];
          image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
          instruction[3];
          anchorX = /** @type {number} */
          instruction[4];
          anchorY = /** @type {number} */
          instruction[5];
          let height = (
            /** @type {number} */
            instruction[6]
          );
          const opacity = (
            /** @type {number} */
            instruction[7]
          );
          const originX = (
            /** @type {number} */
            instruction[8]
          );
          const originY = (
            /** @type {number} */
            instruction[9]
          );
          const rotateWithView = (
            /** @type {boolean} */
            instruction[10]
          );
          let rotation = (
            /** @type {number} */
            instruction[11]
          );
          const scale4 = (
            /** @type {import("../../size.js").Size} */
            instruction[12]
          );
          let width = (
            /** @type {number} */
            instruction[13]
          );
          declutterMode = instruction[14] || "declutter";
          const declutterImageWithText = (
            /** @type {{args: import("../canvas.js").DeclutterImageWithText, declutterMode: import('../../style/Style.js').DeclutterMode}} */
            instruction[15]
          );
          if (!image && instruction.length >= 20) {
            text = /** @type {string} */
            instruction[19];
            textKey = /** @type {string} */
            instruction[20];
            strokeKey = /** @type {string} */
            instruction[21];
            fillKey = /** @type {string} */
            instruction[22];
            const labelWithAnchor = this.drawLabelWithPointPlacement_(
              text,
              textKey,
              strokeKey,
              fillKey
            );
            image = labelWithAnchor.label;
            instruction[3] = image;
            const textOffsetX = (
              /** @type {number} */
              instruction[23]
            );
            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
            instruction[4] = anchorX;
            const textOffsetY = (
              /** @type {number} */
              instruction[24]
            );
            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
            instruction[5] = anchorY;
            height = image.height;
            instruction[6] = height;
            width = image.width;
            instruction[13] = width;
          }
          let geometryWidths;
          if (instruction.length > 25) {
            geometryWidths = /** @type {number} */
            instruction[25];
          }
          let padding, backgroundFillInstruction, backgroundStrokeInstruction;
          if (instruction.length > 17) {
            padding = /** @type {Array<number>} */
            instruction[16];
            backgroundFillInstruction = /** @type {Array<*>} */
            instruction[17];
            backgroundStrokeInstruction = /** @type {Array<*>} */
            instruction[18];
          } else {
            padding = defaultPadding;
            backgroundFillInstruction = null;
            backgroundStrokeInstruction = null;
          }
          if (rotateWithView && viewRotationFromTransform) {
            rotation += viewRotation;
          } else if (!rotateWithView && !viewRotationFromTransform) {
            rotation -= viewRotation;
          }
          let widthIndex = 0;
          for (; d < dd; d += 2) {
            if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {
              continue;
            }
            const dimensions = this.calculateImageOrLabelDimensions_(
              image.width,
              image.height,
              pixelCoordinates[d],
              pixelCoordinates[d + 1],
              width,
              height,
              anchorX,
              anchorY,
              originX,
              originY,
              rotation,
              scale4,
              snapToPixel,
              padding,
              !!backgroundFillInstruction || !!backgroundStrokeInstruction,
              feature
            );
            const args = [
              context,
              scaledCanvasSize,
              image,
              dimensions,
              opacity,
              backgroundFillInstruction,
              backgroundStrokeInstruction
            ];
            if (declutterTree) {
              let imageArgs, imageDeclutterMode, imageDeclutterBox;
              if (declutterImageWithText) {
                const index = dd - d;
                if (!declutterImageWithText[index]) {
                  declutterImageWithText[index] = { args, declutterMode };
                  continue;
                }
                const imageDeclutter = declutterImageWithText[index];
                imageArgs = imageDeclutter.args;
                imageDeclutterMode = imageDeclutter.declutterMode;
                delete declutterImageWithText[index];
                imageDeclutterBox = getDeclutterBox(imageArgs);
              }
              let renderImage, renderText;
              if (imageArgs && (imageDeclutterMode !== "declutter" || !declutterTree.collides(imageDeclutterBox))) {
                renderImage = true;
              }
              if (declutterMode !== "declutter" || !declutterTree.collides(dimensions.declutterBox)) {
                renderText = true;
              }
              if (imageDeclutterMode === "declutter" && declutterMode === "declutter") {
                const render2 = renderImage && renderText;
                renderImage = render2;
                renderText = render2;
              }
              if (renderImage) {
                if (imageDeclutterMode !== "none") {
                  declutterTree.insert(imageDeclutterBox);
                }
                this.replayImageOrLabel_.apply(this, imageArgs);
              }
              if (renderText) {
                if (declutterMode !== "none") {
                  declutterTree.insert(dimensions.declutterBox);
                }
                this.replayImageOrLabel_.apply(this, args);
              }
            } else {
              this.replayImageOrLabel_.apply(this, args);
            }
          }
          ++i;
          break;
        case Instruction_default.DRAW_CHARS:
          const begin = (
            /** @type {number} */
            instruction[1]
          );
          const end = (
            /** @type {number} */
            instruction[2]
          );
          const baseline = (
            /** @type {number} */
            instruction[3]
          );
          const overflow = (
            /** @type {number} */
            instruction[4]
          );
          fillKey = /** @type {string} */
          instruction[5];
          const maxAngle = (
            /** @type {number} */
            instruction[6]
          );
          const measurePixelRatio = (
            /** @type {number} */
            instruction[7]
          );
          const offsetY = (
            /** @type {number} */
            instruction[8]
          );
          strokeKey = /** @type {string} */
          instruction[9];
          const strokeWidth = (
            /** @type {number} */
            instruction[10]
          );
          text = /** @type {string|Array<string>} */
          instruction[11];
          if (Array.isArray(text)) {
            text = text.reduce(richTextToPlainText, "");
          }
          textKey = /** @type {string} */
          instruction[12];
          const pixelRatioScale = [
            /** @type {number} */
            instruction[13],
            /** @type {number} */
            instruction[13]
          ];
          declutterMode = instruction[14] || "declutter";
          const textKeepUpright = (
            /** @type {boolean} */
            instruction[15]
          );
          const textState = this.textStates[textKey];
          const font = textState.font;
          const textScale = [
            textState.scale[0] * measurePixelRatio,
            textState.scale[1] * measurePixelRatio
          ];
          let cachedWidths;
          if (font in this.widths_) {
            cachedWidths = this.widths_[font];
          } else {
            cachedWidths = {};
            this.widths_[font] = cachedWidths;
          }
          const pathLength = lineStringLength(pixelCoordinates, begin, end, 2);
          const textLength = Math.abs(textScale[0]) * measureAndCacheTextWidth(font, text, cachedWidths);
          if (overflow || textLength <= pathLength) {
            const textAlign = this.textStates[textKey].textAlign;
            const startM = (pathLength - textLength) * horizontalTextAlign(text, textAlign);
            const parts = drawTextOnPath(
              pixelCoordinates,
              begin,
              end,
              2,
              text,
              startM,
              maxAngle,
              Math.abs(textScale[0]),
              measureAndCacheTextWidth,
              font,
              cachedWidths,
              viewRotationFromTransform ? 0 : this.viewRotation_,
              textKeepUpright
            );
            drawChars: if (parts) {
              const replayImageOrLabelArgs = [];
              let c, cc, chars, label, part;
              if (strokeKey) {
                for (c = 0, cc = parts.length; c < cc; ++c) {
                  part = parts[c];
                  chars = /** @type {string} */
                  part[4];
                  label = this.createLabel(chars, textKey, "", strokeKey);
                  anchorX = /** @type {number} */
                  part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                  anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;
                  const dimensions = this.calculateImageOrLabelDimensions_(
                    label.width,
                    label.height,
                    part[0],
                    part[1],
                    label.width,
                    label.height,
                    anchorX,
                    anchorY,
                    0,
                    0,
                    part[3],
                    pixelRatioScale,
                    false,
                    defaultPadding,
                    false,
                    feature
                  );
                  if (declutterTree && declutterMode === "declutter" && declutterTree.collides(dimensions.declutterBox)) {
                    break drawChars;
                  }
                  replayImageOrLabelArgs.push([
                    context,
                    scaledCanvasSize,
                    label,
                    dimensions,
                    1,
                    null,
                    null
                  ]);
                }
              }
              if (fillKey) {
                for (c = 0, cc = parts.length; c < cc; ++c) {
                  part = parts[c];
                  chars = /** @type {string} */
                  part[4];
                  label = this.createLabel(chars, textKey, fillKey, "");
                  anchorX = /** @type {number} */
                  part[2];
                  anchorY = baseline * label.height - offsetY;
                  const dimensions = this.calculateImageOrLabelDimensions_(
                    label.width,
                    label.height,
                    part[0],
                    part[1],
                    label.width,
                    label.height,
                    anchorX,
                    anchorY,
                    0,
                    0,
                    part[3],
                    pixelRatioScale,
                    false,
                    defaultPadding,
                    false,
                    feature
                  );
                  if (declutterTree && declutterMode === "declutter" && declutterTree.collides(dimensions.declutterBox)) {
                    break drawChars;
                  }
                  replayImageOrLabelArgs.push([
                    context,
                    scaledCanvasSize,
                    label,
                    dimensions,
                    1,
                    null,
                    null
                  ]);
                }
              }
              if (declutterTree && declutterMode !== "none") {
                declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
              }
              for (let i2 = 0, ii2 = replayImageOrLabelArgs.length; i2 < ii2; ++i2) {
                this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i2]);
              }
            }
          }
          ++i;
          break;
        case Instruction_default.END_GEOMETRY:
          if (featureCallback !== void 0) {
            feature = /** @type {import("../../Feature.js").FeatureLike} */
            instruction[1];
            const result = featureCallback(
              feature,
              currentGeometry,
              declutterMode
            );
            if (result) {
              return result;
            }
          }
          ++i;
          break;
        case Instruction_default.FILL:
          if (batchSize) {
            pendingFill++;
          } else {
            this.fill_(context);
          }
          ++i;
          break;
        case Instruction_default.MOVE_TO_LINE_TO:
          d = /** @type {number} */
          instruction[1];
          dd = /** @type {number} */
          instruction[2];
          x = pixelCoordinates[d];
          y = pixelCoordinates[d + 1];
          context.moveTo(x, y);
          prevX = x + 0.5 | 0;
          prevY = y + 0.5 | 0;
          for (d += 2; d < dd; d += 2) {
            x = pixelCoordinates[d];
            y = pixelCoordinates[d + 1];
            roundX = x + 0.5 | 0;
            roundY = y + 0.5 | 0;
            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
              context.lineTo(x, y);
              prevX = roundX;
              prevY = roundY;
            }
          }
          ++i;
          break;
        case Instruction_default.SET_FILL_STYLE:
          this.alignAndScaleFill_ = instruction[2];
          if (pendingFill) {
            this.fill_(context);
            pendingFill = 0;
            if (pendingStroke) {
              context.stroke();
              pendingStroke = 0;
            }
          }
          context.fillStyle = instruction[1];
          ++i;
          break;
        case Instruction_default.SET_STROKE_STYLE:
          if (pendingStroke) {
            context.stroke();
            pendingStroke = 0;
          }
          this.setStrokeStyle_(
            context,
            /** @type {Array<*>} */
            instruction
          );
          ++i;
          break;
        case Instruction_default.STROKE:
          if (batchSize) {
            pendingStroke++;
          } else {
            context.stroke();
          }
          ++i;
          break;
        default:
          ++i;
          break;
      }
    }
    if (pendingFill) {
      this.fill_(context);
    }
    if (pendingStroke) {
      context.stroke();
    }
    return void 0;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {import("rbush").default<DeclutterEntry>} [declutterTree] Declutter tree.
   */
  execute(context, scaledCanvasSize, transform2, viewRotation, snapToPixel, declutterTree) {
    this.viewRotation_ = viewRotation;
    this.execute_(
      context,
      scaledCanvasSize,
      transform2,
      this.instructions,
      snapToPixel,
      void 0,
      void 0,
      declutterTree
    );
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  executeHitDetection(context, transform2, viewRotation, featureCallback, hitExtent) {
    this.viewRotation_ = viewRotation;
    return this.execute_(
      context,
      [context.canvas.width, context.canvas.height],
      transform2,
      this.hitDetectionInstructions,
      true,
      featureCallback,
      hitExtent
    );
  }
};
var Executor_default = Executor;

// node_modules/ol/render/canvas/ExecutorGroup.js
var ALL = [
  "Polygon",
  "Circle",
  "LineString",
  "Image",
  "Text",
  "Default"
];
var DECLUTTER = ["Image", "Text"];
var NON_DECLUTTER = ALL.filter(
  (builderType) => !DECLUTTER.includes(builderType)
);
var ExecutorGroup = class {
  /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [renderBuffer] Optional rendering buffer.
   * @param {boolean} [deferredRendering] Enable deferred rendering with renderDeferred().
   */
  constructor(maxExtent, resolution, pixelRatio, overlaps, allInstructions, renderBuffer, deferredRendering) {
    this.maxExtent_ = maxExtent;
    this.overlaps_ = overlaps;
    this.pixelRatio_ = pixelRatio;
    this.resolution_ = resolution;
    this.renderBuffer_ = renderBuffer;
    this.executorsByZIndex_ = {};
    this.hitDetectionContext_ = null;
    this.hitDetectionTransform_ = create();
    this.renderedContext_ = null;
    this.deferredZIndexContexts_ = {};
    this.createExecutors_(allInstructions, deferredRendering);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  clip(context, transform2) {
    const flatClipCoords = this.getClipCoords(transform2);
    context.beginPath();
    context.moveTo(flatClipCoords[0], flatClipCoords[1]);
    context.lineTo(flatClipCoords[2], flatClipCoords[3]);
    context.lineTo(flatClipCoords[4], flatClipCoords[5]);
    context.lineTo(flatClipCoords[6], flatClipCoords[7]);
    context.clip();
  }
  /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<string, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
   * @param {boolean} deferredRendering Enable deferred rendering.
   */
  createExecutors_(allInstructions, deferredRendering) {
    for (const zIndex in allInstructions) {
      let executors = this.executorsByZIndex_[zIndex];
      if (executors === void 0) {
        executors = {};
        this.executorsByZIndex_[zIndex] = executors;
      }
      const instructionByZindex = allInstructions[zIndex];
      for (const builderType in instructionByZindex) {
        const instructions = instructionByZindex[builderType];
        executors[builderType] = new Executor_default(
          this.resolution_,
          this.pixelRatio_,
          this.overlaps_,
          instructions,
          deferredRendering
        );
      }
    }
  }
  /**
   * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */
  hasExecutors(executors) {
    for (const zIndex in this.executorsByZIndex_) {
      const candidates = this.executorsByZIndex_[zIndex];
      for (let i = 0, ii = executors.length; i < ii; ++i) {
        if (executors[i] in candidates) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
    hitTolerance = Math.round(hitTolerance);
    const contextSize = hitTolerance * 2 + 1;
    const transform2 = compose(
      this.hitDetectionTransform_,
      hitTolerance + 0.5,
      hitTolerance + 0.5,
      1 / resolution,
      -1 / resolution,
      -rotation,
      -coordinate[0],
      -coordinate[1]
    );
    const newContext = !this.hitDetectionContext_;
    if (newContext) {
      this.hitDetectionContext_ = createCanvasContext2D(
        contextSize,
        contextSize
      );
    }
    const context = this.hitDetectionContext_;
    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
      context.canvas.width = contextSize;
      context.canvas.height = contextSize;
    } else if (!newContext) {
      context.clearRect(0, 0, contextSize, contextSize);
    }
    let hitExtent;
    if (this.renderBuffer_ !== void 0) {
      hitExtent = createEmpty();
      extendCoordinate(hitExtent, coordinate);
      buffer(
        hitExtent,
        resolution * (this.renderBuffer_ + hitTolerance),
        hitExtent
      );
    }
    const indexes = getPixelIndexArray(hitTolerance);
    let builderType;
    function featureCallback(feature, geometry, declutterMode) {
      const imageData = context.getImageData(
        0,
        0,
        contextSize,
        contextSize
      ).data;
      for (let i2 = 0, ii = indexes.length; i2 < ii; i2++) {
        if (imageData[indexes[i2]] > 0) {
          if (!declutteredFeatures || declutterMode === "none" || builderType !== "Image" && builderType !== "Text" || declutteredFeatures.includes(feature)) {
            const idx = (indexes[i2] - 3) / 4;
            const x = hitTolerance - idx % contextSize;
            const y = hitTolerance - (idx / contextSize | 0);
            const result2 = callback(feature, geometry, x * x + y * y);
            if (result2) {
              return result2;
            }
          }
          context.clearRect(0, 0, contextSize, contextSize);
          break;
        }
      }
      return void 0;
    }
    const zs = Object.keys(this.executorsByZIndex_).map(Number);
    zs.sort(ascending);
    let i, j, executors, executor, result;
    for (i = zs.length - 1; i >= 0; --i) {
      const zIndexKey = zs[i].toString();
      executors = this.executorsByZIndex_[zIndexKey];
      for (j = ALL.length - 1; j >= 0; --j) {
        builderType = ALL[j];
        executor = executors[builderType];
        if (executor !== void 0) {
          result = executor.executeHitDetection(
            context,
            transform2,
            rotation,
            featureCallback,
            hitExtent
          );
          if (result) {
            return result;
          }
        }
      }
    }
    return void 0;
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>|null} Clip coordinates.
   */
  getClipCoords(transform2) {
    const maxExtent = this.maxExtent_;
    if (!maxExtent) {
      return null;
    }
    const minX = maxExtent[0];
    const minY = maxExtent[1];
    const maxX = maxExtent[2];
    const maxY = maxExtent[3];
    const flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
    transform2D(flatClipCoords, 0, 8, 2, transform2, flatClipCoords);
    return flatClipCoords;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return isEmpty(this.executorsByZIndex_);
  }
  /**
   * @param {CanvasRenderingContext2D} targetContext Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ALL}
   * @param {import("rbush").default<import('./Executor.js').DeclutterEntry>|null} [declutterTree] Declutter tree.
   *     When set to null, no decluttering is done, even when the executor group has a `ZIndexContext`.
   */
  execute(targetContext, scaledCanvasSize, transform2, viewRotation, snapToPixel, builderTypes, declutterTree) {
    const zs = Object.keys(this.executorsByZIndex_).map(Number);
    zs.sort(declutterTree ? descending : ascending);
    builderTypes = builderTypes ? builderTypes : ALL;
    const maxBuilderTypes = ALL.length;
    for (let i = 0, ii = zs.length; i < ii; ++i) {
      const zIndexKey = zs[i].toString();
      const replays = this.executorsByZIndex_[zIndexKey];
      for (let j = 0, jj = builderTypes.length; j < jj; ++j) {
        const builderType = builderTypes[j];
        const replay = replays[builderType];
        if (replay !== void 0) {
          const zIndexContext = declutterTree === null ? void 0 : replay.getZIndexContext();
          const context = zIndexContext ? zIndexContext.getContext() : targetContext;
          const requireClip = this.maxExtent_ && builderType !== "Image" && builderType !== "Text";
          if (requireClip) {
            context.save();
            this.clip(context, transform2);
          }
          if (!zIndexContext || builderType === "Text" || builderType === "Image") {
            replay.execute(
              context,
              scaledCanvasSize,
              transform2,
              viewRotation,
              snapToPixel,
              declutterTree
            );
          } else {
            zIndexContext.pushFunction(
              (context2) => replay.execute(
                context2,
                scaledCanvasSize,
                transform2,
                viewRotation,
                snapToPixel,
                declutterTree
              )
            );
          }
          if (requireClip) {
            context.restore();
          }
          if (zIndexContext) {
            zIndexContext.offset();
            const index = zs[i] * maxBuilderTypes + j;
            if (!this.deferredZIndexContexts_[index]) {
              this.deferredZIndexContexts_[index] = [];
            }
            this.deferredZIndexContexts_[index].push(zIndexContext);
          }
        }
      }
    }
    this.renderedContext_ = targetContext;
  }
  getDeferredZIndexContexts() {
    return this.deferredZIndexContexts_;
  }
  getRenderedContext() {
    return this.renderedContext_;
  }
  renderDeferred() {
    const deferredZIndexContexts = this.deferredZIndexContexts_;
    const zs = Object.keys(deferredZIndexContexts).map(Number).sort(ascending);
    for (let i = 0, ii = zs.length; i < ii; ++i) {
      deferredZIndexContexts[zs[i]].forEach((zIndexContext) => {
        zIndexContext.draw(this.renderedContext_);
        zIndexContext.clear();
      });
      deferredZIndexContexts[zs[i]].length = 0;
    }
  }
};
var circlePixelIndexArrayCache = {};
function getPixelIndexArray(radius) {
  if (circlePixelIndexArrayCache[radius] !== void 0) {
    return circlePixelIndexArrayCache[radius];
  }
  const size = radius * 2 + 1;
  const maxDistanceSq = radius * radius;
  const distances = new Array(maxDistanceSq + 1);
  for (let i = 0; i <= radius; ++i) {
    for (let j = 0; j <= radius; ++j) {
      const distanceSq = i * i + j * j;
      if (distanceSq > maxDistanceSq) {
        break;
      }
      let distance = distances[distanceSq];
      if (!distance) {
        distance = [];
        distances[distanceSq] = distance;
      }
      distance.push(((radius + i) * size + (radius + j)) * 4 + 3);
      if (i > 0) {
        distance.push(((radius - i) * size + (radius + j)) * 4 + 3);
      }
      if (j > 0) {
        distance.push(((radius + i) * size + (radius - j)) * 4 + 3);
        if (i > 0) {
          distance.push(((radius - i) * size + (radius - j)) * 4 + 3);
        }
      }
    }
  }
  const pixelIndex = [];
  for (let i = 0, ii = distances.length; i < ii; ++i) {
    if (distances[i]) {
      pixelIndex.push(...distances[i]);
    }
  }
  circlePixelIndexArrayCache[radius] = pixelIndex;
  return pixelIndex;
}
var ExecutorGroup_default = ExecutorGroup;

// node_modules/ol/render/canvas/Immediate.js
var CanvasImmediateRenderer = class extends VectorContext_default {
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
   */
  constructor(context, pixelRatio, extent, transform2, viewRotation, squaredTolerance, userTransform) {
    super();
    this.context_ = context;
    this.pixelRatio_ = pixelRatio;
    this.extent_ = extent;
    this.transform_ = transform2;
    this.transformRotation_ = transform2 ? toFixed(Math.atan2(transform2[1], transform2[0]), 10) : 0;
    this.viewRotation_ = viewRotation;
    this.squaredTolerance_ = squaredTolerance;
    this.userTransform_ = userTransform;
    this.contextFillState_ = null;
    this.contextStrokeState_ = null;
    this.contextTextState_ = null;
    this.fillState_ = null;
    this.strokeState_ = null;
    this.image_ = null;
    this.imageAnchorX_ = 0;
    this.imageAnchorY_ = 0;
    this.imageHeight_ = 0;
    this.imageOpacity_ = 0;
    this.imageOriginX_ = 0;
    this.imageOriginY_ = 0;
    this.imageRotateWithView_ = false;
    this.imageRotation_ = 0;
    this.imageScale_ = [0, 0];
    this.imageWidth_ = 0;
    this.text_ = "";
    this.textOffsetX_ = 0;
    this.textOffsetY_ = 0;
    this.textRotateWithView_ = false;
    this.textRotation_ = 0;
    this.textScale_ = [0, 0];
    this.textFillState_ = null;
    this.textStrokeState_ = null;
    this.textState_ = null;
    this.pixelCoordinates_ = [];
    this.tmpLocalTransform_ = create();
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawImages_(flatCoordinates, offset, end, stride) {
    if (!this.image_) {
      return;
    }
    const pixelCoordinates = transform2D(
      flatCoordinates,
      offset,
      end,
      stride,
      this.transform_,
      this.pixelCoordinates_
    );
    const context = this.context_;
    const localTransform = this.tmpLocalTransform_;
    const alpha = context.globalAlpha;
    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha * this.imageOpacity_;
    }
    let rotation = this.imageRotation_;
    if (this.transformRotation_ === 0) {
      rotation -= this.viewRotation_;
    }
    if (this.imageRotateWithView_) {
      rotation += this.viewRotation_;
    }
    for (let i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
      const x = pixelCoordinates[i] - this.imageAnchorX_;
      const y = pixelCoordinates[i + 1] - this.imageAnchorY_;
      if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
        const centerX = x + this.imageAnchorX_;
        const centerY = y + this.imageAnchorY_;
        compose(
          localTransform,
          centerX,
          centerY,
          1,
          1,
          rotation,
          -centerX,
          -centerY
        );
        context.save();
        context.transform.apply(context, localTransform);
        context.translate(centerX, centerY);
        context.scale(this.imageScale_[0], this.imageScale_[1]);
        context.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          -this.imageAnchorX_,
          -this.imageAnchorY_,
          this.imageWidth_,
          this.imageHeight_
        );
        context.restore();
      } else {
        context.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          x,
          y,
          this.imageWidth_,
          this.imageHeight_
        );
      }
    }
    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha;
    }
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawText_(flatCoordinates, offset, end, stride) {
    if (!this.textState_ || this.text_ === "") {
      return;
    }
    if (this.textFillState_) {
      this.setContextFillState_(this.textFillState_);
    }
    if (this.textStrokeState_) {
      this.setContextStrokeState_(this.textStrokeState_);
    }
    this.setContextTextState_(this.textState_);
    const pixelCoordinates = transform2D(
      flatCoordinates,
      offset,
      end,
      stride,
      this.transform_,
      this.pixelCoordinates_
    );
    const context = this.context_;
    let rotation = this.textRotation_;
    if (this.transformRotation_ === 0) {
      rotation -= this.viewRotation_;
    }
    if (this.textRotateWithView_) {
      rotation += this.viewRotation_;
    }
    for (; offset < end; offset += stride) {
      const x = pixelCoordinates[offset] + this.textOffsetX_;
      const y = pixelCoordinates[offset + 1] + this.textOffsetY_;
      if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {
        context.save();
        context.translate(x - this.textOffsetX_, y - this.textOffsetY_);
        context.rotate(rotation);
        context.translate(this.textOffsetX_, this.textOffsetY_);
        context.scale(this.textScale_[0], this.textScale_[1]);
        if (this.textStrokeState_) {
          context.strokeText(this.text_, 0, 0);
        }
        if (this.textFillState_) {
          context.fillText(this.text_, 0, 0);
        }
        context.restore();
      } else {
        if (this.textStrokeState_) {
          context.strokeText(this.text_, x, y);
        }
        if (this.textFillState_) {
          context.fillText(this.text_, x, y);
        }
      }
    }
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */
  moveToLineTo_(flatCoordinates, offset, end, stride, close) {
    const context = this.context_;
    const pixelCoordinates = transform2D(
      flatCoordinates,
      offset,
      end,
      stride,
      this.transform_,
      this.pixelCoordinates_
    );
    context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
    let length = pixelCoordinates.length;
    if (close) {
      length -= 2;
    }
    for (let i = 2; i < length; i += 2) {
      context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
    }
    if (close) {
      context.closePath();
    }
    return end;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawRings_(flatCoordinates, offset, ends, stride) {
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.moveToLineTo_(
        flatCoordinates,
        offset,
        ends[i],
        stride,
        true
      );
    }
    return offset;
  }
  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @api
   * @override
   */
  drawCircle(geometry) {
    if (this.squaredTolerance_) {
      geometry = /** @type {import("../../geom/Circle.js").default} */
      geometry.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      );
    }
    if (!intersects(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.fillState_ || this.strokeState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      const pixelCoordinates = transformGeom2D(
        geometry,
        this.transform_,
        this.pixelCoordinates_
      );
      const dx = pixelCoordinates[2] - pixelCoordinates[0];
      const dy = pixelCoordinates[3] - pixelCoordinates[1];
      const radius = Math.sqrt(dx * dx + dy * dy);
      const context = this.context_;
      context.beginPath();
      context.arc(
        pixelCoordinates[0],
        pixelCoordinates[1],
        radius,
        0,
        2 * Math.PI
      );
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== "") {
      this.drawText_(geometry.getCenter(), 0, 2, 2);
    }
  }
  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @api
   * @override
   */
  setStyle(style) {
    this.setFillStrokeStyle(style.getFill(), style.getStroke());
    this.setImageStyle(style.getImage());
    this.setTextStyle(style.getText());
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  setTransform(transform2) {
    this.transform_ = transform2;
  }
  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @api
   * @override
   */
  drawGeometry(geometry) {
    const type = geometry.getType();
    switch (type) {
      case "Point":
        this.drawPoint(
          /** @type {import("../../geom/Point.js").default} */
          geometry
        );
        break;
      case "LineString":
        this.drawLineString(
          /** @type {import("../../geom/LineString.js").default} */
          geometry
        );
        break;
      case "Polygon":
        this.drawPolygon(
          /** @type {import("../../geom/Polygon.js").default} */
          geometry
        );
        break;
      case "MultiPoint":
        this.drawMultiPoint(
          /** @type {import("../../geom/MultiPoint.js").default} */
          geometry
        );
        break;
      case "MultiLineString":
        this.drawMultiLineString(
          /** @type {import("../../geom/MultiLineString.js").default} */
          geometry
        );
        break;
      case "MultiPolygon":
        this.drawMultiPolygon(
          /** @type {import("../../geom/MultiPolygon.js").default} */
          geometry
        );
        break;
      case "GeometryCollection":
        this.drawGeometryCollection(
          /** @type {import("../../geom/GeometryCollection.js").default} */
          geometry
        );
        break;
      case "Circle":
        this.drawCircle(
          /** @type {import("../../geom/Circle.js").default} */
          geometry
        );
        break;
      default:
    }
  }
  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @api
   * @override
   */
  drawFeature(feature, style) {
    const geometry = style.getGeometryFunction()(feature);
    if (!geometry) {
      return;
    }
    this.setStyle(style);
    this.drawGeometry(geometry);
  }
  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   * @override
   */
  drawGeometryCollection(geometry) {
    const geometries = geometry.getGeometriesArray();
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      this.drawGeometry(geometries[i]);
    }
  }
  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   * @override
   */
  drawPoint(geometry) {
    if (this.squaredTolerance_) {
      geometry = /** @type {import("../../geom/Point.js").default} */
      geometry.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      );
    }
    const flatCoordinates = geometry.getFlatCoordinates();
    const stride = geometry.getStride();
    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    if (this.text_ !== "") {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  }
  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   * @override
   */
  drawMultiPoint(geometry) {
    if (this.squaredTolerance_) {
      geometry = /** @type {import("../../geom/MultiPoint.js").default} */
      geometry.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      );
    }
    const flatCoordinates = geometry.getFlatCoordinates();
    const stride = geometry.getStride();
    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    if (this.text_ !== "") {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  }
  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   * @override
   */
  drawLineString(geometry) {
    if (this.squaredTolerance_) {
      geometry = /** @type {import("../../geom/LineString.js").default} */
      geometry.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      );
    }
    if (!intersects(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      const context = this.context_;
      const flatCoordinates = geometry.getFlatCoordinates();
      context.beginPath();
      this.moveToLineTo_(
        flatCoordinates,
        0,
        flatCoordinates.length,
        geometry.getStride(),
        false
      );
      context.stroke();
    }
    if (this.text_ !== "") {
      const flatMidpoint = geometry.getFlatMidpoint();
      this.drawText_(flatMidpoint, 0, 2, 2);
    }
  }
  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   * @override
   */
  drawMultiLineString(geometry) {
    if (this.squaredTolerance_) {
      geometry = /** @type {import("../../geom/MultiLineString.js").default} */
      geometry.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      );
    }
    const geometryExtent = geometry.getExtent();
    if (!intersects(this.extent_, geometryExtent)) {
      return;
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      const context = this.context_;
      const flatCoordinates = geometry.getFlatCoordinates();
      let offset = 0;
      const ends = (
        /** @type {Array<number>} */
        geometry.getEnds()
      );
      const stride = geometry.getStride();
      context.beginPath();
      for (let i = 0, ii = ends.length; i < ii; ++i) {
        offset = this.moveToLineTo_(
          flatCoordinates,
          offset,
          ends[i],
          stride,
          false
        );
      }
      context.stroke();
    }
    if (this.text_ !== "") {
      const flatMidpoints = geometry.getFlatMidpoints();
      this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
    }
  }
  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   * @override
   */
  drawPolygon(geometry) {
    if (this.squaredTolerance_) {
      geometry = /** @type {import("../../geom/Polygon.js").default} */
      geometry.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      );
    }
    if (!intersects(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      const context = this.context_;
      context.beginPath();
      this.drawRings_(
        geometry.getOrientedFlatCoordinates(),
        0,
        /** @type {Array<number>} */
        geometry.getEnds(),
        geometry.getStride()
      );
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== "") {
      const flatInteriorPoint = geometry.getFlatInteriorPoint();
      this.drawText_(flatInteriorPoint, 0, 2, 2);
    }
  }
  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   * @override
   */
  drawMultiPolygon(geometry) {
    if (this.squaredTolerance_) {
      geometry = /** @type {import("../../geom/MultiPolygon.js").default} */
      geometry.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      );
    }
    if (!intersects(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      const context = this.context_;
      const flatCoordinates = geometry.getOrientedFlatCoordinates();
      let offset = 0;
      const endss = geometry.getEndss();
      const stride = geometry.getStride();
      context.beginPath();
      for (let i = 0, ii = endss.length; i < ii; ++i) {
        const ends = endss[i];
        offset = this.drawRings_(flatCoordinates, offset, ends, stride);
      }
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== "") {
      const flatInteriorPoints = geometry.getFlatInteriorPoints();
      this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
    }
  }
  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */
  setContextFillState_(fillState) {
    const context = this.context_;
    const contextFillState = this.contextFillState_;
    if (!contextFillState) {
      context.fillStyle = fillState.fillStyle;
      this.contextFillState_ = {
        fillStyle: fillState.fillStyle
      };
    } else {
      if (contextFillState.fillStyle != fillState.fillStyle) {
        contextFillState.fillStyle = fillState.fillStyle;
        context.fillStyle = fillState.fillStyle;
      }
    }
  }
  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */
  setContextStrokeState_(strokeState) {
    const context = this.context_;
    const contextStrokeState = this.contextStrokeState_;
    if (!contextStrokeState) {
      context.lineCap = strokeState.lineCap;
      context.setLineDash(strokeState.lineDash);
      context.lineDashOffset = strokeState.lineDashOffset;
      context.lineJoin = strokeState.lineJoin;
      context.lineWidth = strokeState.lineWidth;
      context.miterLimit = strokeState.miterLimit;
      context.strokeStyle = strokeState.strokeStyle;
      this.contextStrokeState_ = {
        lineCap: strokeState.lineCap,
        lineDash: strokeState.lineDash,
        lineDashOffset: strokeState.lineDashOffset,
        lineJoin: strokeState.lineJoin,
        lineWidth: strokeState.lineWidth,
        miterLimit: strokeState.miterLimit,
        strokeStyle: strokeState.strokeStyle
      };
    } else {
      if (contextStrokeState.lineCap != strokeState.lineCap) {
        contextStrokeState.lineCap = strokeState.lineCap;
        context.lineCap = strokeState.lineCap;
      }
      if (!equals(contextStrokeState.lineDash, strokeState.lineDash)) {
        context.setLineDash(
          contextStrokeState.lineDash = strokeState.lineDash
        );
      }
      if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
        contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
        context.lineDashOffset = strokeState.lineDashOffset;
      }
      if (contextStrokeState.lineJoin != strokeState.lineJoin) {
        contextStrokeState.lineJoin = strokeState.lineJoin;
        context.lineJoin = strokeState.lineJoin;
      }
      if (contextStrokeState.lineWidth != strokeState.lineWidth) {
        contextStrokeState.lineWidth = strokeState.lineWidth;
        context.lineWidth = strokeState.lineWidth;
      }
      if (contextStrokeState.miterLimit != strokeState.miterLimit) {
        contextStrokeState.miterLimit = strokeState.miterLimit;
        context.miterLimit = strokeState.miterLimit;
      }
      if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
        contextStrokeState.strokeStyle = strokeState.strokeStyle;
        context.strokeStyle = strokeState.strokeStyle;
      }
    }
  }
  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */
  setContextTextState_(textState) {
    const context = this.context_;
    const contextTextState = this.contextTextState_;
    const textAlign = textState.textAlign ? textState.textAlign : defaultTextAlign;
    if (!contextTextState) {
      context.font = textState.font;
      context.textAlign = textAlign;
      context.textBaseline = textState.textBaseline;
      this.contextTextState_ = {
        font: textState.font,
        textAlign,
        textBaseline: textState.textBaseline
      };
    } else {
      if (contextTextState.font != textState.font) {
        contextTextState.font = textState.font;
        context.font = textState.font;
      }
      if (contextTextState.textAlign != textAlign) {
        contextTextState.textAlign = textAlign;
        context.textAlign = textAlign;
      }
      if (contextTextState.textBaseline != textState.textBaseline) {
        contextTextState.textBaseline = textState.textBaseline;
        context.textBaseline = textState.textBaseline;
      }
    }
  }
  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   * @override
   */
  setFillStrokeStyle(fillStyle, strokeStyle) {
    if (!fillStyle) {
      this.fillState_ = null;
    } else {
      const fillStyleColor = fillStyle.getColor();
      this.fillState_ = {
        fillStyle: asColorLike(
          fillStyleColor ? fillStyleColor : defaultFillStyle
        )
      };
    }
    if (!strokeStyle) {
      this.strokeState_ = null;
    } else {
      const strokeStyleColor = strokeStyle.getColor();
      const strokeStyleLineCap = strokeStyle.getLineCap();
      const strokeStyleLineDash = strokeStyle.getLineDash();
      const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      const strokeStyleLineJoin = strokeStyle.getLineJoin();
      const strokeStyleWidth = strokeStyle.getWidth();
      const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      const lineDash = strokeStyleLineDash ? strokeStyleLineDash : defaultLineDash;
      this.strokeState_ = {
        lineCap: strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap,
        lineDash: this.pixelRatio_ === 1 ? lineDash : lineDash.map((n) => n * this.pixelRatio_),
        lineDashOffset: (strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset) * this.pixelRatio_,
        lineJoin: strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin,
        lineWidth: (strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth) * this.pixelRatio_,
        miterLimit: strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit,
        strokeStyle: asColorLike(
          strokeStyleColor ? strokeStyleColor : defaultStrokeStyle
        )
      };
    }
  }
  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @override
   */
  setImageStyle(imageStyle) {
    let imageSize;
    if (!imageStyle || !(imageSize = imageStyle.getSize())) {
      this.image_ = null;
      return;
    }
    const imagePixelRatio = imageStyle.getPixelRatio(this.pixelRatio_);
    const imageAnchor = imageStyle.getAnchor();
    const imageOrigin = imageStyle.getOrigin();
    this.image_ = imageStyle.getImage(this.pixelRatio_);
    this.imageAnchorX_ = imageAnchor[0] * imagePixelRatio;
    this.imageAnchorY_ = imageAnchor[1] * imagePixelRatio;
    this.imageHeight_ = imageSize[1] * imagePixelRatio;
    this.imageOpacity_ = imageStyle.getOpacity();
    this.imageOriginX_ = imageOrigin[0];
    this.imageOriginY_ = imageOrigin[1];
    this.imageRotateWithView_ = imageStyle.getRotateWithView();
    this.imageRotation_ = imageStyle.getRotation();
    const imageScale = imageStyle.getScaleArray();
    this.imageScale_ = [
      imageScale[0] * this.pixelRatio_ / imagePixelRatio,
      imageScale[1] * this.pixelRatio_ / imagePixelRatio
    ];
    this.imageWidth_ = imageSize[0] * imagePixelRatio;
  }
  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @override
   */
  setTextStyle(textStyle) {
    if (!textStyle) {
      this.text_ = "";
    } else {
      const textFillStyle = textStyle.getFill();
      if (!textFillStyle) {
        this.textFillState_ = null;
      } else {
        const textFillStyleColor = textFillStyle.getColor();
        this.textFillState_ = {
          fillStyle: asColorLike(
            textFillStyleColor ? textFillStyleColor : defaultFillStyle
          )
        };
      }
      const textStrokeStyle = textStyle.getStroke();
      if (!textStrokeStyle) {
        this.textStrokeState_ = null;
      } else {
        const textStrokeStyleColor = textStrokeStyle.getColor();
        const textStrokeStyleLineCap = textStrokeStyle.getLineCap();
        const textStrokeStyleLineDash = textStrokeStyle.getLineDash();
        const textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
        const textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
        const textStrokeStyleWidth = textStrokeStyle.getWidth();
        const textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: textStrokeStyleLineCap !== void 0 ? textStrokeStyleLineCap : defaultLineCap,
          lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : defaultLineDash,
          lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : defaultLineDashOffset,
          lineJoin: textStrokeStyleLineJoin !== void 0 ? textStrokeStyleLineJoin : defaultLineJoin,
          lineWidth: textStrokeStyleWidth !== void 0 ? textStrokeStyleWidth : defaultLineWidth,
          miterLimit: textStrokeStyleMiterLimit !== void 0 ? textStrokeStyleMiterLimit : defaultMiterLimit,
          strokeStyle: asColorLike(
            textStrokeStyleColor ? textStrokeStyleColor : defaultStrokeStyle
          )
        };
      }
      const textFont = textStyle.getFont();
      const textOffsetX = textStyle.getOffsetX();
      const textOffsetY = textStyle.getOffsetY();
      const textRotateWithView = textStyle.getRotateWithView();
      const textRotation = textStyle.getRotation();
      const textScale = textStyle.getScaleArray();
      const textText = textStyle.getText();
      const textTextAlign = textStyle.getTextAlign();
      const textTextBaseline = textStyle.getTextBaseline();
      this.textState_ = {
        font: textFont !== void 0 ? textFont : defaultFont,
        textAlign: textTextAlign !== void 0 ? textTextAlign : defaultTextAlign,
        textBaseline: textTextBaseline !== void 0 ? textTextBaseline : defaultTextBaseline
      };
      this.text_ = textText !== void 0 ? Array.isArray(textText) ? textText.reduce((acc, t, i) => acc += i % 2 ? " " : t, "") : textText : "";
      this.textOffsetX_ = textOffsetX !== void 0 ? this.pixelRatio_ * textOffsetX : 0;
      this.textOffsetY_ = textOffsetY !== void 0 ? this.pixelRatio_ * textOffsetY : 0;
      this.textRotateWithView_ = textRotateWithView !== void 0 ? textRotateWithView : false;
      this.textRotation_ = textRotation !== void 0 ? textRotation : 0;
      this.textScale_ = [
        this.pixelRatio_ * textScale[0],
        this.pixelRatio_ * textScale[1]
      ];
    }
  }
};
var Immediate_default = CanvasImmediateRenderer;

// node_modules/ol/render/canvas/hitdetect.js
var HIT_DETECT_RESOLUTION = 0.5;
function createHitDetectionImageData(size, transforms2, features, styleFunction, extent, resolution, rotation, squaredTolerance, projection) {
  const userExtent = projection ? toUserExtent(extent, projection) : extent;
  const width = size[0] * HIT_DETECT_RESOLUTION;
  const height = size[1] * HIT_DETECT_RESOLUTION;
  const context = createCanvasContext2D(width, height);
  context.imageSmoothingEnabled = false;
  const canvas = context.canvas;
  const renderer = new Immediate_default(
    context,
    HIT_DETECT_RESOLUTION,
    extent,
    null,
    rotation,
    squaredTolerance,
    projection ? getTransformFromProjections(getUserProjection(), projection) : null
  );
  const featureCount = features.length;
  const indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
  const featuresByZIndex = {};
  for (let i = 1; i <= featureCount; ++i) {
    const feature = features[i - 1];
    const featureStyleFunction = feature.getStyleFunction() || styleFunction;
    if (!featureStyleFunction) {
      continue;
    }
    let styles = featureStyleFunction(feature, resolution);
    if (!styles) {
      continue;
    }
    if (!Array.isArray(styles)) {
      styles = [styles];
    }
    const index = i * indexFactor;
    const color = index.toString(16).padStart(7, "#00000");
    for (let j = 0, jj = styles.length; j < jj; ++j) {
      const originalStyle = styles[j];
      const geometry = originalStyle.getGeometryFunction()(feature);
      if (!geometry || !intersects(userExtent, geometry.getExtent())) {
        continue;
      }
      const style = originalStyle.clone();
      const fill = style.getFill();
      if (fill) {
        fill.setColor(color);
      }
      const stroke = style.getStroke();
      if (stroke) {
        stroke.setColor(color);
        stroke.setLineDash(null);
      }
      style.setText(void 0);
      const image = originalStyle.getImage();
      if (image) {
        const imgSize = image.getImageSize();
        if (!imgSize) {
          continue;
        }
        const imgContext = createCanvasContext2D(
          imgSize[0],
          imgSize[1],
          void 0,
          { alpha: false }
        );
        const img = imgContext.canvas;
        imgContext.fillStyle = color;
        imgContext.fillRect(0, 0, img.width, img.height);
        style.setImage(
          new Icon_default({
            img,
            anchor: image.getAnchor(),
            anchorXUnits: "pixels",
            anchorYUnits: "pixels",
            offset: image.getOrigin(),
            opacity: 1,
            size: image.getSize(),
            scale: image.getScale(),
            rotation: image.getRotation(),
            rotateWithView: image.getRotateWithView()
          })
        );
      }
      const zIndex = style.getZIndex() || 0;
      let byGeometryType = featuresByZIndex[zIndex];
      if (!byGeometryType) {
        byGeometryType = {};
        featuresByZIndex[zIndex] = byGeometryType;
        byGeometryType["Polygon"] = [];
        byGeometryType["Circle"] = [];
        byGeometryType["LineString"] = [];
        byGeometryType["Point"] = [];
      }
      const type = geometry.getType();
      if (type === "GeometryCollection") {
        const geometries = (
          /** @type {import("../../geom/GeometryCollection.js").default} */
          geometry.getGeometriesArrayRecursive()
        );
        for (let i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
          const geometry2 = geometries[i2];
          byGeometryType[geometry2.getType().replace("Multi", "")].push(
            geometry2,
            style
          );
        }
      } else {
        byGeometryType[type.replace("Multi", "")].push(geometry, style);
      }
    }
  }
  const zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(ascending);
  for (let i = 0, ii = zIndexKeys.length; i < ii; ++i) {
    const byGeometryType = featuresByZIndex[zIndexKeys[i]];
    for (const type in byGeometryType) {
      const geomAndStyle = byGeometryType[type];
      for (let j = 0, jj = geomAndStyle.length; j < jj; j += 2) {
        renderer.setStyle(geomAndStyle[j + 1]);
        for (let k = 0, kk = transforms2.length; k < kk; ++k) {
          renderer.setTransform(transforms2[k]);
          renderer.drawGeometry(geomAndStyle[j]);
        }
      }
    }
  }
  return context.getImageData(0, 0, canvas.width, canvas.height);
}
function hitDetect(pixel, features, imageData) {
  const resultFeatures = [];
  if (imageData) {
    const x = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
    const y = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);
    const index = (clamp(x, 0, imageData.width - 1) + clamp(y, 0, imageData.height - 1) * imageData.width) * 4;
    const r = imageData.data[index];
    const g = imageData.data[index + 1];
    const b = imageData.data[index + 2];
    const i = b + 256 * (g + 256 * r);
    const indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);
    if (i && i % indexFactor === 0) {
      resultFeatures.push(features[i / indexFactor - 1]);
    }
  }
  return resultFeatures;
}

// node_modules/ol/renderer/vector.js
var SIMPLIFY_TOLERANCE = 0.5;
var GEOMETRY_RENDERERS = {
  "Point": renderPointGeometry,
  "LineString": renderLineStringGeometry,
  "Polygon": renderPolygonGeometry,
  "MultiPoint": renderMultiPointGeometry,
  "MultiLineString": renderMultiLineStringGeometry,
  "MultiPolygon": renderMultiPolygonGeometry,
  "GeometryCollection": renderGeometryCollectionGeometry,
  "Circle": renderCircleGeometry
};
function defaultOrder(feature1, feature2) {
  return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);
}
function getSquaredTolerance(resolution, pixelRatio) {
  const tolerance = getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
}
function getTolerance(resolution, pixelRatio) {
  return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}
function renderCircleGeometry(builderGroup, geometry, style, feature, index) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    const circleReplay = builderGroup.getBuilder(style.getZIndex(), "Circle");
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature, index);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = builderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderFeature(replayGroup, feature, style, squaredTolerance, listener, transform2, declutter, index) {
  const loadingPromises = [];
  const imageStyle = style.getImage();
  if (imageStyle) {
    let loading2 = true;
    const imageState = imageStyle.getImageState();
    if (imageState == ImageState_default.LOADED || imageState == ImageState_default.ERROR) {
      loading2 = false;
    } else {
      if (imageState == ImageState_default.IDLE) {
        imageStyle.load();
      }
    }
    if (loading2) {
      loadingPromises.push(imageStyle.ready());
    }
  }
  const fillStyle = style.getFill();
  if (fillStyle && fillStyle.loading()) {
    loadingPromises.push(fillStyle.ready());
  }
  const loading = loadingPromises.length > 0;
  if (loading) {
    Promise.all(loadingPromises).then(() => listener(null));
  }
  renderFeatureInternal(
    replayGroup,
    feature,
    style,
    squaredTolerance,
    transform2,
    declutter,
    index
  );
  return loading;
}
function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, transform2, declutter, index) {
  const geometry = style.getGeometryFunction()(feature);
  if (!geometry) {
    return;
  }
  const simplifiedGeometry = geometry.simplifyTransformed(
    squaredTolerance,
    transform2
  );
  const renderer = style.getRenderer();
  if (renderer) {
    renderGeometry(replayGroup, simplifiedGeometry, style, feature, index);
  } else {
    const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
    geometryRenderer(
      replayGroup,
      simplifiedGeometry,
      style,
      feature,
      index,
      declutter
    );
  }
}
function renderGeometry(replayGroup, geometry, style, feature, index) {
  if (geometry.getType() == "GeometryCollection") {
    const geometries = (
      /** @type {import("../geom/GeometryCollection.js").default} */
      geometry.getGeometries()
    );
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      renderGeometry(replayGroup, geometries[i], style, feature, index);
    }
    return;
  }
  const replay = replayGroup.getBuilder(style.getZIndex(), "Default");
  replay.drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */
    geometry,
    feature,
    style.getRenderer(),
    style.getHitDetectionRenderer(),
    index
  );
}
function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, declutterBuilderGroup, index) {
  const geometries = geometry.getGeometriesArray();
  let i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    const geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
    geometryRenderer(
      replayGroup,
      geometries[i],
      style,
      feature,
      declutterBuilderGroup,
      index
    );
  }
}
function renderLineStringGeometry(builderGroup, geometry, style, feature, index) {
  const strokeStyle = style.getStroke();
  if (strokeStyle) {
    const lineStringReplay = builderGroup.getBuilder(
      style.getZIndex(),
      "LineString"
    );
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature, index);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = builderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature, index);
  }
}
function renderMultiLineStringGeometry(builderGroup, geometry, style, feature, index) {
  const strokeStyle = style.getStroke();
  if (strokeStyle) {
    const lineStringReplay = builderGroup.getBuilder(
      style.getZIndex(),
      "LineString"
    );
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature, index);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = builderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature, index);
  }
}
function renderMultiPolygonGeometry(builderGroup, geometry, style, feature, index) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (strokeStyle || fillStyle) {
    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), "Polygon");
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature, index);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = builderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature, index);
  }
}
function renderPointGeometry(builderGroup, geometry, style, feature, index, declutter) {
  const imageStyle = style.getImage();
  const textStyle = style.getText();
  const hasText = textStyle && textStyle.getText();
  const declutterImageWithText = declutter && imageStyle && hasText ? {} : void 0;
  if (imageStyle) {
    if (imageStyle.getImageState() != ImageState_default.LOADED) {
      return;
    }
    const imageReplay = builderGroup.getBuilder(style.getZIndex(), "Image");
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawPoint(geometry, feature, index);
  }
  if (hasText) {
    const textReplay = builderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature, index);
  }
}
function renderMultiPointGeometry(builderGroup, geometry, style, feature, index, declutter) {
  const imageStyle = style.getImage();
  const hasImage = imageStyle && imageStyle.getOpacity() !== 0;
  const textStyle = style.getText();
  const hasText = textStyle && textStyle.getText();
  const declutterImageWithText = declutter && hasImage && hasText ? {} : void 0;
  if (hasImage) {
    if (imageStyle.getImageState() != ImageState_default.LOADED) {
      return;
    }
    const imageReplay = builderGroup.getBuilder(style.getZIndex(), "Image");
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawMultiPoint(geometry, feature, index);
  }
  if (hasText) {
    const textReplay = builderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature, index);
  }
}
function renderPolygonGeometry(builderGroup, geometry, style, feature, index) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), "Polygon");
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature, index);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = builderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature, index);
  }
}

// node_modules/ol/renderer/Layer.js
var maxStaleKeys = 5;
var LayerRenderer = class extends Observable_default {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(layer) {
    super();
    this.ready = true;
    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);
    this.layer_ = layer;
    this.staleKeys_ = new Array();
    this.maxStaleKeys = maxStaleKeys;
  }
  /**
   * @return {Array<string>} Get the list of stale keys.
   */
  getStaleKeys() {
    return this.staleKeys_;
  }
  /**
   * @param {string} key The new stale key.
   */
  prependStaleKey(key) {
    this.staleKeys_.unshift(key);
    if (this.staleKeys_.length > this.maxStaleKeys) {
      this.staleKeys_.length = this.maxStaleKeys;
    }
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(pixel) {
    return abstract();
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(pixel) {
    return null;
  }
  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(frameState) {
    return abstract();
  }
  /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(frameState, target) {
    return abstract();
  }
  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
    return void 0;
  }
  /**
   * @return {LayerType} Layer.
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */
  handleFontsChanged() {
  }
  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  handleImageChange_(event) {
    const image = (
      /** @type {import("../Image.js").default} */
      event.target
    );
    if (image.getState() === ImageState_default.LOADED || image.getState() === ImageState_default.ERROR) {
      this.renderIfReadyAndVisible();
    }
  }
  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../Image.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  loadImage(image) {
    let imageState = image.getState();
    if (imageState != ImageState_default.LOADED && imageState != ImageState_default.ERROR) {
      image.addEventListener(EventType_default.CHANGE, this.boundHandleImageChange_);
    }
    if (imageState == ImageState_default.IDLE) {
      image.load();
      imageState = image.getState();
    }
    return imageState == ImageState_default.LOADED;
  }
  /**
   * @protected
   */
  renderIfReadyAndVisible() {
    const layer = this.getLayer();
    if (layer && layer.getVisible() && layer.getSourceState() === "ready") {
      layer.changed();
    }
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  renderDeferred(frameState) {
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    delete this.layer_;
    super.disposeInternal();
  }
};
var Layer_default2 = LayerRenderer;

// node_modules/ol/renderer/canvas/Layer.js
var canvasPool = [];
var pixelContext = null;
function createPixelContext() {
  pixelContext = createCanvasContext2D(1, 1, void 0, {
    willReadFrequently: true
  });
}
var CanvasLayerRenderer = class extends Layer_default2 {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(layer) {
    super(layer);
    this.container = null;
    this.renderedResolution;
    this.tempTransform = create();
    this.pixelTransform = create();
    this.inversePixelTransform = create();
    this.context = null;
    this.deferredContext_ = null;
    this.containerReused = false;
    this.frameState = null;
  }
  /**
   * @param {import('../../DataTile.js').ImageLike} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */
  getImageData(image, col, row) {
    if (!pixelContext) {
      createPixelContext();
    }
    pixelContext.clearRect(0, 0, 1, 1);
    let data;
    try {
      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
      data = pixelContext.getImageData(0, 0, 1, 1).data;
    } catch {
      pixelContext = null;
      return null;
    }
    return data;
  }
  /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */
  getBackground(frameState) {
    const layer = this.getLayer();
    let background = layer.getBackground();
    if (typeof background === "function") {
      background = background(frameState.viewState.resolution);
    }
    return background || void 0;
  }
  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS transform matrix.
   * @param {string} [backgroundColor] Background color.
   */
  useContainer(target, transform2, backgroundColor) {
    const layerClassName = this.getLayer().getClassName();
    let container, context;
    if (target && target.className === layerClassName && (!backgroundColor || target && target.style.backgroundColor && equals(
      asArray(target.style.backgroundColor),
      asArray(backgroundColor)
    ))) {
      const canvas = target.firstElementChild;
      if (canvas instanceof HTMLCanvasElement) {
        context = canvas.getContext("2d");
      }
    }
    if (context && equivalent2(context.canvas.style.transform, transform2)) {
      this.container = target;
      this.context = context;
      this.containerReused = true;
    } else if (this.containerReused) {
      this.container = null;
      this.context = null;
      this.containerReused = false;
    } else if (this.container) {
      this.container.style.backgroundColor = null;
    }
    if (!this.container) {
      container = document.createElement("div");
      container.className = layerClassName;
      let style = container.style;
      style.position = "absolute";
      style.width = "100%";
      style.height = "100%";
      context = createCanvasContext2D();
      const canvas = context.canvas;
      container.appendChild(canvas);
      style = canvas.style;
      style.position = "absolute";
      style.left = "0";
      style.transformOrigin = "top left";
      this.container = container;
      this.context = context;
    }
    if (!this.containerReused && backgroundColor && !this.container.style.backgroundColor) {
      this.container.style.backgroundColor = backgroundColor;
    }
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  clipUnrotated(context, frameState, extent) {
    const topLeft = getTopLeft(extent);
    const topRight = getTopRight(extent);
    const bottomRight = getBottomRight(extent);
    const bottomLeft = getBottomLeft(extent);
    apply(frameState.coordinateToPixelTransform, topLeft);
    apply(frameState.coordinateToPixelTransform, topRight);
    apply(frameState.coordinateToPixelTransform, bottomRight);
    apply(frameState.coordinateToPixelTransform, bottomLeft);
    const inverted = this.inversePixelTransform;
    apply(inverted, topLeft);
    apply(inverted, topRight);
    apply(inverted, bottomRight);
    apply(inverted, bottomLeft);
    context.save();
    context.beginPath();
    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
    context.clip();
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @protected
   */
  prepareContainer(frameState, target) {
    const extent = frameState.extent;
    const resolution = frameState.viewState.resolution;
    const rotation = frameState.viewState.rotation;
    const pixelRatio = frameState.pixelRatio;
    const width = Math.round(getWidth(extent) / resolution * pixelRatio);
    const height = Math.round(getHeight(extent) / resolution * pixelRatio);
    compose(
      this.pixelTransform,
      frameState.size[0] / 2,
      frameState.size[1] / 2,
      1 / pixelRatio,
      1 / pixelRatio,
      rotation,
      -width / 2,
      -height / 2
    );
    makeInverse(this.inversePixelTransform, this.pixelTransform);
    const canvasTransform = toString(this.pixelTransform);
    this.useContainer(target, canvasTransform, this.getBackground(frameState));
    if (!this.containerReused) {
      const canvas = this.context.canvas;
      if (canvas.width != width || canvas.height != height) {
        canvas.width = width;
        canvas.height = height;
      } else {
        this.context.clearRect(0, 0, width, height);
      }
      if (canvasTransform !== canvas.style.transform) {
        canvas.style.transform = canvasTransform;
      }
    }
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(type, context, frameState) {
    const layer = this.getLayer();
    if (layer.hasListener(type)) {
      const event = new Event_default2(
        type,
        this.inversePixelTransform,
        frameState,
        context
      );
      layer.dispatchEvent(event);
    }
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(context, frameState) {
    this.frameState = frameState;
    if (frameState.declutter) {
      return;
    }
    this.dispatchRenderEvent_(EventType_default3.PRERENDER, context, frameState);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(context, frameState) {
    if (frameState.declutter) {
      return;
    }
    this.dispatchRenderEvent_(EventType_default3.POSTRENDER, context, frameState);
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(frameState) {
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
   */
  getRenderContext(frameState) {
    if (frameState.declutter && !this.deferredContext_) {
      this.deferredContext_ = new ZIndexContext_default();
    }
    return frameState.declutter ? this.deferredContext_.getContext() : this.context;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderDeferred(frameState) {
    if (!frameState.declutter) {
      return;
    }
    this.dispatchRenderEvent_(
      EventType_default3.PRERENDER,
      this.context,
      frameState
    );
    if (frameState.declutter && this.deferredContext_) {
      this.deferredContext_.draw(this.context);
      this.deferredContext_.clear();
    }
    this.renderDeferredInternal(frameState);
    this.dispatchRenderEvent_(
      EventType_default3.POSTRENDER,
      this.context,
      frameState
    );
  }
  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX) {
    const dx1 = width / 2;
    const dy1 = height / 2;
    const sx = pixelRatio / resolution;
    const sy = -sx;
    const dx2 = -center[0] + offsetX;
    const dy2 = -center[1];
    return compose(
      this.tempTransform,
      dx1,
      dy1,
      sx,
      sy,
      -rotation,
      dx2,
      dy2
    );
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    delete this.frameState;
    super.disposeInternal();
  }
};
var Layer_default3 = CanvasLayerRenderer;

// node_modules/ol/renderer/canvas/VectorLayer.js
var CanvasVectorLayerRenderer = class extends Layer_default3 {
  /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */
  constructor(vectorLayer) {
    super(vectorLayer);
    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);
    this.animatingOrInteracting_;
    this.hitDetectionImageData_ = null;
    this.clipped_ = false;
    this.renderedFeatures_ = null;
    this.renderedRevision_ = -1;
    this.renderedResolution_ = NaN;
    this.renderedExtent_ = createEmpty();
    this.wrappedRenderedExtent_ = createEmpty();
    this.renderedRotation_;
    this.renderedCenter_ = null;
    this.renderedProjection_ = null;
    this.renderedPixelRatio_ = 1;
    this.renderedRenderOrder_ = null;
    this.renderedFrameDeclutter_;
    this.replayGroup_ = null;
    this.replayGroupChanged = true;
    this.clipping = true;
    this.targetContext_ = null;
    this.opacity_ = 1;
  }
  /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {boolean} [declutterable] `true` to only render declutterable items,
   *     `false` to only render non-declutterable items, `undefined` to render all.
   */
  renderWorlds(executorGroup, frameState, declutterable) {
    const extent = frameState.extent;
    const viewState = frameState.viewState;
    const center = viewState.center;
    const resolution = viewState.resolution;
    const projection = viewState.projection;
    const rotation = viewState.rotation;
    const projectionExtent = projection.getExtent();
    const vectorSource = this.getLayer().getSource();
    const declutter = this.getLayer().getDeclutter();
    const pixelRatio = frameState.pixelRatio;
    const viewHints = frameState.viewHints;
    const snapToPixel = !(viewHints[ViewHint_default.ANIMATING] || viewHints[ViewHint_default.INTERACTING]);
    const context = this.context;
    const width = Math.round(getWidth(extent) / resolution * pixelRatio);
    const height = Math.round(getHeight(extent) / resolution * pixelRatio);
    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();
    const worldWidth = multiWorld ? getWidth(projectionExtent) : null;
    const endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
    let world = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;
    do {
      let transform2 = this.getRenderTransform(
        center,
        resolution,
        0,
        pixelRatio,
        width,
        height,
        world * worldWidth
      );
      if (frameState.declutter) {
        transform2 = transform2.slice(0);
      }
      executorGroup.execute(
        context,
        [context.canvas.width, context.canvas.height],
        transform2,
        rotation,
        snapToPixel,
        declutterable === void 0 ? ALL : declutterable ? DECLUTTER : NON_DECLUTTER,
        declutterable ? declutter && frameState.declutter[declutter] : void 0
      );
    } while (++world < endWorld);
  }
  /**
   * @private
   */
  setDrawContext_() {
    if (this.opacity_ !== 1) {
      this.targetContext_ = this.context;
      this.context = createCanvasContext2D(
        this.context.canvas.width,
        this.context.canvas.height,
        canvasPool
      );
    }
  }
  /**
   * @private
   */
  resetDrawContext_() {
    if (this.opacity_ !== 1) {
      const alpha = this.targetContext_.globalAlpha;
      this.targetContext_.globalAlpha = this.opacity_;
      this.targetContext_.drawImage(this.context.canvas, 0, 0);
      this.targetContext_.globalAlpha = alpha;
      releaseCanvas(this.context);
      canvasPool.push(this.context.canvas);
      this.context = this.targetContext_;
      this.targetContext_ = null;
    }
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(frameState) {
    if (!this.replayGroup_ || !this.getLayer().getDeclutter()) {
      return;
    }
    this.renderWorlds(this.replayGroup_, frameState, true);
  }
  /**
   * Render deferred instructions.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderDeferredInternal(frameState) {
    if (!this.replayGroup_) {
      return;
    }
    this.replayGroup_.renderDeferred();
    if (this.clipped_) {
      this.context.restore();
    }
    this.resetDrawContext_();
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   * @override
   */
  renderFrame(frameState, target) {
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    this.opacity_ = layerState.opacity;
    const viewState = frameState.viewState;
    this.prepareContainer(frameState, target);
    const context = this.context;
    const replayGroup = this.replayGroup_;
    let render2 = replayGroup && !replayGroup.isEmpty();
    if (!render2) {
      const hasRenderListeners = this.getLayer().hasListener(EventType_default3.PRERENDER) || this.getLayer().hasListener(EventType_default3.POSTRENDER);
      if (!hasRenderListeners) {
        return this.container;
      }
    }
    this.setDrawContext_();
    this.preRender(context, frameState);
    const projection = viewState.projection;
    this.clipped_ = false;
    if (render2 && layerState.extent && this.clipping) {
      const layerExtent = fromUserExtent(layerState.extent, projection);
      render2 = intersects(layerExtent, frameState.extent);
      this.clipped_ = render2 && !containsExtent(layerExtent, frameState.extent);
      if (this.clipped_) {
        this.clipUnrotated(context, frameState, layerExtent);
      }
    }
    if (render2) {
      this.renderWorlds(
        replayGroup,
        frameState,
        this.getLayer().getDeclutter() ? false : void 0
      );
    }
    if (!frameState.declutter && this.clipped_) {
      context.restore();
    }
    this.postRender(context, frameState);
    if (this.renderedRotation_ !== viewState.rotation) {
      this.renderedRotation_ = viewState.rotation;
      this.hitDetectionImageData_ = null;
    }
    if (!frameState.declutter) {
      this.resetDrawContext_();
    }
    return this.container;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise
   * that resolves with an array of features.
   * @override
   */
  getFeatures(pixel) {
    return new Promise((resolve) => {
      if (this.frameState && !this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
        const size = this.frameState.size.slice();
        const center = this.renderedCenter_;
        const resolution = this.renderedResolution_;
        const rotation = this.renderedRotation_;
        const projection = this.renderedProjection_;
        const extent = this.wrappedRenderedExtent_;
        const layer = this.getLayer();
        const transforms2 = [];
        const width = size[0] * HIT_DETECT_RESOLUTION;
        const height = size[1] * HIT_DETECT_RESOLUTION;
        transforms2.push(
          this.getRenderTransform(
            center,
            resolution,
            rotation,
            HIT_DETECT_RESOLUTION,
            width,
            height,
            0
          ).slice()
        );
        const source = layer.getSource();
        const projectionExtent = projection.getExtent();
        if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent)) {
          let startX = extent[0];
          const worldWidth = getWidth(projectionExtent);
          let world = 0;
          let offsetX;
          while (startX < projectionExtent[0]) {
            --world;
            offsetX = worldWidth * world;
            transforms2.push(
              this.getRenderTransform(
                center,
                resolution,
                rotation,
                HIT_DETECT_RESOLUTION,
                width,
                height,
                offsetX
              ).slice()
            );
            startX += worldWidth;
          }
          world = 0;
          startX = extent[2];
          while (startX > projectionExtent[2]) {
            ++world;
            offsetX = worldWidth * world;
            transforms2.push(
              this.getRenderTransform(
                center,
                resolution,
                rotation,
                HIT_DETECT_RESOLUTION,
                width,
                height,
                offsetX
              ).slice()
            );
            startX -= worldWidth;
          }
        }
        const userProjection2 = getUserProjection();
        this.hitDetectionImageData_ = createHitDetectionImageData(
          size,
          transforms2,
          this.renderedFeatures_,
          layer.getStyleFunction(),
          extent,
          resolution,
          rotation,
          getSquaredTolerance(resolution, this.renderedPixelRatio_),
          userProjection2 ? projection : null
        );
      }
      resolve(
        hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_)
      );
    });
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   * @override
   */
  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
    if (!this.replayGroup_) {
      return void 0;
    }
    const resolution = frameState.viewState.resolution;
    const rotation = frameState.viewState.rotation;
    const layer = this.getLayer();
    const features = {};
    const featureCallback = function(feature, geometry, distanceSq) {
      const key = getUid(feature);
      const match = features[key];
      if (!match) {
        if (distanceSq === 0) {
          features[key] = true;
          return callback(feature, layer, geometry);
        }
        matches.push(
          features[key] = {
            feature,
            layer,
            geometry,
            distanceSq,
            callback
          }
        );
      } else if (match !== true && distanceSq < match.distanceSq) {
        if (distanceSq === 0) {
          features[key] = true;
          matches.splice(matches.lastIndexOf(match), 1);
          return callback(feature, layer, geometry);
        }
        match.geometry = geometry;
        match.distanceSq = distanceSq;
      }
      return void 0;
    };
    const declutter = this.getLayer().getDeclutter();
    return this.replayGroup_.forEachFeatureAtCoordinate(
      coordinate,
      resolution,
      rotation,
      hitTolerance,
      featureCallback,
      declutter ? frameState.declutter?.[declutter]?.all().map((item) => item.value) : null
    );
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @override
   */
  handleFontsChanged() {
    const layer = this.getLayer();
    if (layer.getVisible() && this.replayGroup_) {
      layer.changed();
    }
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(event) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrame(frameState) {
    const vectorLayer = this.getLayer();
    const vectorSource = vectorLayer.getSource();
    if (!vectorSource) {
      return false;
    }
    const animating = frameState.viewHints[ViewHint_default.ANIMATING];
    const interacting = frameState.viewHints[ViewHint_default.INTERACTING];
    const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
    const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
    if (this.ready && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
      this.animatingOrInteracting_ = true;
      return true;
    }
    this.animatingOrInteracting_ = false;
    const frameStateExtent = frameState.extent;
    const viewState = frameState.viewState;
    const projection = viewState.projection;
    const resolution = viewState.resolution;
    const pixelRatio = frameState.pixelRatio;
    const vectorLayerRevision = vectorLayer.getRevision();
    const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
    let vectorLayerRenderOrder = vectorLayer.getRenderOrder();
    if (vectorLayerRenderOrder === void 0) {
      vectorLayerRenderOrder = defaultOrder;
    }
    const center = viewState.center.slice();
    const extent = buffer(
      frameStateExtent,
      vectorLayerRenderBuffer * resolution
    );
    const renderedExtent = extent.slice();
    const loadExtents = [extent.slice()];
    const projectionExtent = projection.getExtent();
    if (vectorSource.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, frameState.extent)) {
      const worldWidth = getWidth(projectionExtent);
      const gutter = Math.max(getWidth(extent) / 2, worldWidth);
      extent[0] = projectionExtent[0] - gutter;
      extent[2] = projectionExtent[2] + gutter;
      wrapX2(center, projection);
      const loadExtent = wrapX(loadExtents[0], projection);
      if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) {
        loadExtents.push([
          loadExtent[0] + worldWidth,
          loadExtent[1],
          loadExtent[2] + worldWidth,
          loadExtent[3]
        ]);
      } else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) {
        loadExtents.push([
          loadExtent[0] - worldWidth,
          loadExtent[1],
          loadExtent[2] - worldWidth,
          loadExtent[3]
        ]);
      }
    }
    if (this.ready && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && this.renderedFrameDeclutter_ === !!frameState.declutter && containsExtent(this.wrappedRenderedExtent_, extent)) {
      if (!equals(this.renderedExtent_, renderedExtent)) {
        this.hitDetectionImageData_ = null;
        this.renderedExtent_ = renderedExtent;
      }
      this.renderedCenter_ = center;
      this.replayGroupChanged = false;
      return true;
    }
    this.replayGroup_ = null;
    const replayGroup = new BuilderGroup_default(
      getTolerance(resolution, pixelRatio),
      extent,
      resolution,
      pixelRatio
    );
    const userProjection2 = getUserProjection();
    let userTransform;
    if (userProjection2) {
      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {
        const extent2 = loadExtents[i];
        const userExtent2 = toUserExtent(extent2, projection);
        vectorSource.loadFeatures(
          userExtent2,
          toUserResolution(resolution, projection),
          userProjection2
        );
      }
      userTransform = getTransformFromProjections(userProjection2, projection);
    } else {
      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {
        vectorSource.loadFeatures(loadExtents[i], resolution, projection);
      }
    }
    const squaredTolerance = getSquaredTolerance(resolution, pixelRatio);
    let ready = true;
    const render2 = (
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {number} index Index.
       */
      (feature, index) => {
        let styles;
        const styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
        if (styleFunction) {
          styles = styleFunction(feature, resolution);
        }
        if (styles) {
          const dirty = this.renderFeature(
            feature,
            squaredTolerance,
            styles,
            replayGroup,
            userTransform,
            this.getLayer().getDeclutter(),
            index
          );
          ready = ready && !dirty;
        }
      }
    );
    const userExtent = toUserExtent(extent, projection);
    const features = vectorSource.getFeaturesInExtent(userExtent);
    if (vectorLayerRenderOrder) {
      features.sort(vectorLayerRenderOrder);
    }
    for (let i = 0, ii = features.length; i < ii; ++i) {
      render2(features[i], i);
    }
    this.renderedFeatures_ = features;
    this.ready = ready;
    const replayGroupInstructions = replayGroup.finish();
    const executorGroup = new ExecutorGroup_default(
      extent,
      resolution,
      pixelRatio,
      vectorSource.getOverlaps(),
      replayGroupInstructions,
      vectorLayer.getRenderBuffer(),
      !!frameState.declutter
    );
    this.renderedResolution_ = resolution;
    this.renderedRevision_ = vectorLayerRevision;
    this.renderedRenderOrder_ = vectorLayerRenderOrder;
    this.renderedFrameDeclutter_ = !!frameState.declutter;
    this.renderedExtent_ = renderedExtent;
    this.wrappedRenderedExtent_ = extent;
    this.renderedCenter_ = center;
    this.renderedProjection_ = projection;
    this.renderedPixelRatio_ = pixelRatio;
    this.replayGroup_ = executorGroup;
    this.hitDetectionImageData_ = null;
    this.replayGroupChanged = true;
    return true;
  }
  /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
   * @param {boolean} [declutter] Enable decluttering.
   * @param {number} [index] Render order index.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(feature, squaredTolerance, styles, builderGroup, transform2, declutter, index) {
    if (!styles) {
      return false;
    }
    let loading = false;
    if (Array.isArray(styles)) {
      for (let i = 0, ii = styles.length; i < ii; ++i) {
        loading = renderFeature(
          builderGroup,
          feature,
          styles[i],
          squaredTolerance,
          this.boundHandleStyleImageChange_,
          transform2,
          declutter,
          index
        ) || loading;
      }
    } else {
      loading = renderFeature(
        builderGroup,
        feature,
        styles,
        squaredTolerance,
        this.boundHandleStyleImageChange_,
        transform2,
        declutter,
        index
      );
    }
    return loading;
  }
};
var VectorLayer_default = CanvasVectorLayerRenderer;

// node_modules/ol/layer/Vector.js
var VectorLayer = class extends BaseVector_default {
  /**
   * @param {Options<VectorSourceType, FeatureType>} [options] Options.
   */
  constructor(options) {
    super(options);
  }
  /**
   * @override
   */
  createRenderer() {
    return new VectorLayer_default(this);
  }
};
var Vector_default2 = VectorLayer;

// src/control/images/marker.png
var marker_default = "data:image/png;base64,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";

// src/control/images/location_icon.png
var location_icon_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjEuNBNAaMQAAAGTSURBVDhPpZU9LwRRFIaHEAUNv0BDQqHwLxQajVKhUvgNWrUE3UZHo0Ci0kpEQTQSUYsgEtS+nmc4cnN3Zney3uTJzty99+w957yHoqHu4eXn8f8ahkd4hREXetEALMEpvMPXLz6fwTIMQiONwzlEkFs4hAO4gU9w/RImoKMMdgceOIFZyDUDx+CeB6gNappxsw3ohzr1wTq49woq07dmcbM02BxswhbMg8GUn0fgmRUXctkAv0zT3AbXUnYggk6BNb0o3xJpDTtoA0LeLA8WLEDIlD9gtHxDmlafudFuhkwzDxS0ILQHrj2BscoJ0LQuao2QNUuDpJh2aBdce4O/aXICTFmfhWxAHihYhJB+NOWx8i2RE2CB9Zmy8N4kD2aK0ZRJ8Ix1bJPj5AFNm1rDBlgzg3uz+E7tg2dWy7dMmtPru0HTpgertAbuvYYhF6rkGDlObtS0+iyXacbNnmEaOsqg1sQDUR/rZjfNIP44eLOuwUKm7zg5AXbQAOKzP2DNatPsJidA0+qzNmv0qob/AoriG1IyiuleC7udAAAAAElFTkSuQmCC";

// src/control/MyLocation.js
var MyLocation = class extends Control_default {
  constructor(opt) {
    const options = opt || {};
    super({
      element: document.createElement("div"),
      target: options.target
    });
    let cssClassName = options.className !== void 0 ? options.className : "ol-my-location ol-unselectable ol-control";
    cssClassName += options.zoomSlider ? " zoom-slider-exists" : "";
    this.labelNode_ = document.createElement("img");
    this.labelNode_.src = location_icon_default;
    this.button_ = document.createElement("button");
    const tipLabel = options.tipLabel ? options.tipLabel : "Min Lokation";
    this.button_.setAttribute("type", "button");
    this.button_.title = tipLabel;
    this.button_.appendChild(this.labelNode_);
    const _this = this;
    this.button_.onclick = function(e) {
      e.preventDefault();
      _this.showMyPosition();
    };
    const element = this.element;
    element.className = cssClassName;
    element.appendChild(this.button_);
    const myLocationStyle = new Style_default({
      image: new Icon_default({
        anchor: [0.5, 18],
        anchorXUnits: "fraction",
        anchorYUnits: "pixels",
        src: marker_default
      })
    });
    this._myLocationVector = new Vector_default({});
    this._myLocationLayer = new Vector_default2({
      source: this._myLocationVector,
      style: myLocationStyle
    });
  }
  setMap(map) {
    super.setMap(map);
    if (map) {
      map.addLayer(this._myLocationLayer);
    }
  }
  handleNoGeolocation(error_msg) {
    const error_str = error_msg.message ? error_msg.message : "";
    console.error(error_str);
    alert(error_str);
  }
  showMyPosition() {
    const _this = this;
    const showPosition = function(position) {
      const lonlat = [position.coords.longitude, position.coords.latitude];
      const xy = fromLonLat2(lonlat, "EPSG:25832");
      const feature = new Feature_default({
        geometry: new Point_default(xy),
        title: "Min lokation"
      });
      _this._myLocationVector.clear();
      _this._myLocationVector.addFeature(feature);
      _this.getMap().getView().fit(_this._myLocationVector.getExtent());
    };
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        showPosition,
        (err) => {
          this.handleNoGeolocation(err);
        }
      );
    } else {
      this.handleNoGeolocation({ message: "Geolokation er ikke tilg\xE6ngelig." });
    }
  }
};

// src/control/images/dtk_skaermkort_thumb.png
var dtk_skaermkort_thumb_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAMAAACahl6sAAADAFBMVEUAAAD////e7f+T0aD17PT89Pzs5PTf3OTs7Pzk5PT09Pzs7PTc5Pzc5PTk7Py3ub3T3OvU5PzU5PTc7Pzk7PTFxsfK2OLZ4+rS7Pzc7PTn9Pq44fHB7Pzb9PzU7PS58/yhqqrz/PzO0dGcyLSUxKyM1KyUzKyE1KSM3KycxKyMzKWU1Kyb3LSTwaOoyrSM1KSU3KyczKyM3KSE3J2UzKSc1Kym2bWc5rCm5LakwqyLyZqU1KSM1JyU3KSf3Kxli212oH+Fs4+cxKSkzKyczKSc1KSU3JyU1Jyc3KTz/PSYwJyYzJy417qn1KekxKSV1JSd1JyuwK2Yy5SkzKGuzKyU1Izs9OuUzIytzqBbalW41aitvqOpyJO4y6WZmpja29nJ2be1xZq6vbXI1avZ3r3s9Kj0/Jzs9Jz0/KT0/JTc4Jj8/JT8/Jz8/KTp6Zn8/Kzo56b8+7f8/OT8/Oz09OT8/PT09Ox4eHf8+Yz8+sj08azIxqTZ17T89JzZ1Ir07pz076TZ1qv88pTo4IyvqGzHwH/89KT88qzr5bjQx5Pq5cnm15rz7dL79dr755v86aT03JPz3qT03azp5NmfjGTq1an45Lr07Nz89OT52Jz83KS+p4D83azjyJv03LTq17j87NOTjoaFclX01KTYvZbMtpapmIL03Lz55Mj81KT01Kz83LTZxKr8xozLwbbyvIT0zKP81Kz01LT83Lz03MS5qJbYx7bp2cj05NT87NyIgnz89Oyoo57px6j8vIT0vIz8zKT0tIT8vIzqtYz0vZT6xZv0zKz81LT83MTny7bOuamzr6z8tIT8zKz007z03Mz85NT0tIz8vJTpuJjzw6TZzsfzrIP8tIzep4b0vJz8xKTdsJf4zLT81Lzn3Nb8rIPLknT0tJT8vJz01MT83Mzvon/imXnzrIz8tJT0w638rIz5vKT8xKz81MT05N347Of8pIP0s5zypIz8tJ37rJT85N38o4z01Mz43NX81MzyzMT89PT8/Pz09PTp6en///8Cu069AAABAHRSTlP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AU/cHJQAAAAlwSFlzAAAOxAAADsQBlSsOGwAAci9JREFUeJyMvXt82+Z9L/wFSBAAAfAGkhIlSpYl27JkJjadxBZzcxWzDtukTXrJ2jRpz9p1a5113ZqjrZedd+/27l3bbWp6zlnbdD09y87aLOvabeklDevQUZwmoWwnpu3QkmVLsi6UKJEESZEAARAk8P4h27HTJHt/n48/pgiAeL74/Z7nd39A3J7GCOuUax6YAICKzcjirWjUrBnCts+k571ge46UkxGqazVz/SlRV42efPNFnol4Krrl6W2B4Ps+Zby+HChIBIO+aWAIQatwXgDq/o0LFSI0sK07x0EEFG75rFADgGBXZpDpBTlRh0iwh55g0dHV9v5k671JvcTywWVyz6Dnl/s++SHx5TUSEchAjZ5Q9RpJAt6uLQdGoyOIXD/GGJw8NP+BAgCWqeU30HDBg9h1ODxvBj/irBlAKmI8PToLt4aJ8wE0wXD7gntYdmGh0Iawu8tiobLwMNUAKSpNCQokz7AzAL+fnZq/UxQVbQO8qfccAkM056dKNd+Ln/RA2Ccvk8x3HdzkAx/zh9fGSQgRyonMZESWMxMTJEnK4E2XHqWiV0YTAYB6VAYCTlGrWFV0n9K0ESePaiR93bidZOY6hkR1GagmoNn3TESDfbMI7LVQ90MB3PsGVVXv9gfo/mFek/PeCuAAOLZxkVRJSCKGwiX+QG9QBDd/YoCglQgetW9X9jfOXHzovx84yTEn+nvxo692/PjzE/q5c+NNMl3nPZCBbLYTwIQ6IUmrgMvl8oxGN7EIEQBZD+SMm9VWKh1gS4pJg0KDvk4IRzxy9XqGeFxAVkxCGNoSs/Q/ecwQXG0LBKfixAnoAuUt1jpYm2NYh1XxwglozfrqaqlwZgNTwAw7vMzagAsFzLTAEPho45uHI19ZftFo3jgkAcu5wQ7iex/BU6qWwjkykZVNsBEgngIAOZadzEhSjYTT6fKMjo4C6eymmNUg3F4hsO7hSvXjk5MeuSpfN2x9BRkkrpHJCPgKDQA3fPGD27f5/g++T2m9OdavsyfOXThRagkUegGpPoWKF6yti1WdjCdQX62zRiPuB4TS7q0NaCyrqoOuvi9uqTyME67vfRehJ5bKhNzfi+f/9lPP3b5FN53jzSUS4Hk5ByRSCQDIpgGEsxm1troK0zTNRALIAlETBkiRUL2E171UQQImSWtIXB11PObZXhm5niMmlEkA6LIf+qPPfW4OnkveHKEG68D8mXMB9Pg4yYtiUwYqwC1CodlslggEhpeTeCmXU4uEoyGVyPlhETORHCp52xenH1/7EP6RkeotbTk3+Ejzcwh9hGHP4ZzLNh9xUyUzi1nMXh3ALJBb858NvbzoY41WpKt/61aFzVF730eUlxuEz/br9s7aAF98de+8Pxefvzw/Tm3VDXtOWAsWrvxMt4jqjsiR2M0P90DwV37HWNhRXW6XL7q3vpzHCLoW17q5hmFfbcs1lQgOdGimoRJEs27fQvV4arCJ3U6ihGJtI1CiqvTOjeVHZ7gqu9fdYygyt0PG2X97ii/izqbjkTGPRqJh4lpZj1/5kAUBZKokCZhmtQcQBKuqAV7bS9W0ovMyHbfjDeHKwoRHBpC9LFYAHLfv2+6NwdULSbmwgYk+L3fr/hudfGl2zesfXC+GAWg10FYZhOAG23Bbpa5bTi3P964QvdC2B0lJlIuqVQrw6z9a+b27kzgUddUPLHUJIW05PPhI9ukpHPQHUnjIL5FwoqHjDRlJvYEpDSCjVldrJOkBAm5OVCwP4fVuOOJpj0zqSjKRfeP8UZATwBXNko0BjQOPigfs4b4vNpYYtZzCkFBZZvzDdwz/81Lgdn9HMECT0pJByLUGAU+7oKCXxU/OpvaHmXOnpGXbLm1BYuql1h7FUpWtn/Dr7dvuZTw+4tcweliht9TFPP8/AePc+fExs8SSEQrwxJHE25BsZOhq1YlKhbm9VllFF9/MK6lRE9XMdVokal5/XRrY9jAe+2TglnvOSyKIg+NGFRKTr4F94kfg/GLV5XCY3h1MiYPqJQALACGZDUonArt3bTAbdbsLHENiha9t3HDTc9KlO3/b02C6dt7gXa4UydIWPsxM4aA63I24poCEi4c7FYvF8NaUFSKTGQOybSvNOSpWhXW/QgA0SBrpOq4qm7gHAISrkhlBNOoae648Nj72sXv4StP3Z8i21eCZf/9XTbP2B9+tTWc2osXaXL2uaWWU4fO4Rc5ZbXyejt/mWxYiVOCOfQxEti4PFjXBno/+g3ivX86Dk1yuLT3WLqALjf8JGI7zh8YCuX0gRb5RfDqeTqffCgUApDsByCTAVlcBgitVwY+o/ISMGJIdV6CkAHICaVwW0lgW8Kye+LtH+VOPwhG9Kej467EFl7/Igp+no6STDzeNktXvGqivoog8vIAJrBYyM/7KykYiVNWWVYKTzOdX9+UQ1g8kfvwNpi2rkKTe2vx08RVg59dIbQoHVeJ1PDS77VifnYdpIIWoZ+LtkKQwotcAYbeqAiGy9HQkG6VlCEhHkEQGiKcQhYlqJIt4alNI04h6qg1vW566uOUfpDzpA8Z6SbW5D0WfJ+Pux7Rf1+d3IZ+LHHOVLIIVOppL3Po5grd6GkBDJEuuhtRtJ+WCzpY2ZpNOcX57rpeDlK8X6+ye3OCvQHif+OfCTvKxseXwDAq2bkeT7+vz1awh79rbQQm4dHT4Ott1Vgu0M+3phEKTCz073WcjBQCYj88PMRZp0bnEkVguugbEnYWQg3b4W89MCerrjY7I73a+8opLEm10bcR/+lluF0dXm0IXj9ZMwaNLdtXF3tDhVhVxuDIsOxSCkGWhrMLMLbb0niqjv//iXOcdBbPllES50bD114ielPVbWsW+tTz3zJ/J7qqnabsB8x7Col00oYXWgHj//G/giIgcIdP3eut51mffOP8qZgfVtZ0caK9ZABDvT0WZFYGoNm8kZ3MjrwKYH8j12XnryDzg+fUsgx5z+584/3r/3wvYI6z/j+Y9IWPvEru1W5GK9qZZV4s+amuPfSlUFVGhy+R6+fVevjvAO16vNAOr6p3mi4dvfpe/rHGipLipRrPZIAZ3xXqFM81GZ/ADeNS50rvUtKPBTmAUAO3CAZASRuQ3m/GUiZoQ5KqatwLx1Qlg1OROzG0eG52I2ZNANURObKqQTasxPULzqxid2DabBY7f5S/iwsOpxy9+/cu3uJ5pc0OBc1MMmhfbWxbIwVlF9VZ8/AYTMHOr4foZ1lleb6ztbqBZamJooad+5l+TP7igb3QqkNArXZAC/St4Xr/371M/eM1qmHh82QpPs4Nko5qNgZ4oqskaCZguD0tFr7U0YhEAMp0etJAHelomEAGqVw7TUJEYMX6DizpgZAAGCcTuHwB6mFyz6+bvD7iWX0J/AERp3z4UA0TQmgEAwlZhNpov9bRKAvY1EdjbagC5+Xq4RC1t67vrnhZtUeCaoghbk5WXMfgwTnm3iRudgUNGGMgBM3bQkTSAbCSWjnoAVF0uYBTVTQ8pBmTRoZKT9/duKKh4caqeSFLmVb2HJE7H7ZMD4hvQrtBqFhPIIgnTw2j+HMJBnBt0Ma83qJETRe/QFMxBEUJp3yuogLAGcWK7s0o7SwFYPh/DAdoqsGC36PNj61RVKHUBDkk0pwG3v/T88tfMivB+3byI70fPCXRr8LRdOgsgCWSBDDAyiaiLNM2aBzfaDGTTQCIJtrrfU2dUy/JC3eDQzvdfN+QkXCDp674aoZEZnYilAcQ6CN4qYQgFWlnJPTlNPeQtcPsuDJloQ9JRQAVelnEE9wHcCXNX6UTrRgaAlqnDr4RL9/zDUz/gdjraHERJVIwm0z2fG3xhwfXCTdbHiOKnP/36shCexgxI2xW7OwEgMhlB5li1VnOZptcTCIyORrEeXYccur1DyXsJGOtAVAslr1pkESRSgOc3JasWoZFGdCRm0gflEjA9PT3Dl36asWhvUdg5LRc6ukTFqLetMosqG4HN7WaV3a2fNdpND8dJ1RUSgL1UO/yNfv+aSxMlSFDqEgJrToQeq3dMhX6qO73UxDLCOT8LP5m5bOVhA4hlER5FJNOBY7Ua6XQ6TSBaa7vWBdqqqlbFazu1kVY6PLmrOJBFMhGJOjFxrWuYuIoso8M7yAMs/CzLW8+vFYzQJX+YIbEy25Bq9Y1Ygc17wcHdgMSWwN1rbLhrbbZxZroItgSLwPemA+9vU5IoiWKtXGKmNf8e9wd/8b2pH9SZUgptv56jFZUr2cgrd88h/iIw693zCmbXsLYWKjRsFicITFVg7d5d+qxX76Jmy36aMFTvNaYlZgtDeu06HTSLLcCp2VgOWOsJ3OTsCuzoC240M8cW1gKuXQgsSAbXln2t4HpluVGtql3OoB/5jSWt0uUYKsVcxK8vNQFEWhQtFIJK2WYXVVVcalGXtG79FD8UeO1TN1y6NFQL/c5Yr9Sz0vBYNVzFgSjscQBGctPGiNSzhnrsmdUGvzdksgf0Zavcz5VKmaxlsq5U/Npxw+TfJFmjIIF4GohGgpy/uBCcmnrx+M9fzyleO7zCtIp9u+p+iOYG6EYlBLh5BRsleHukyqrr+IJMgmCHcDpYa99zcLVs10WIWBKbMgOi96Y9X7tH+NxRDIfA4JCPWcAeXR0CCYxelgIkN5/zpo2RDSM7CWQmVvNTcAk6CwIdS40Yiqh5Yso1+LdFQ/K1caHRSMTkl3QoMYzCTtwOAU88/dQvMgu/4DqJijm4F+g7MSVCwlwTAJsH0wEJO5r+jnUxIovnUCjC6gtCMAPHnmn330pYABTAOy9jeYnpW/hFuwIMr/RPwmzq6p45WgBrBy4bWZHsZaG/PMArhn0mIpBb7fVVogvBDzTnsBOVKmjE7ckIKGQyEaorr0euUaITiPBgM0gDE9hPF+fyqm4VACEBmL13z4AfXbJDExmUWvteI+BhiX4HCW7vdKnmNUlux7w6BHomN5RbCP7Nu4t+9yAliRInSg2GCCyTP/pHbJz+CYZNXABuOYs9M2o4V1TfEK036fMMEAViALKmf1ehDIJokf4b+mKyoNVcjcG11r0CUMMeKKgR2cQ1l46ooIQYolHE4MSvpysLT/80neZSySR69/j3qQNltPxhBWYQx3RltQxh46Kq5qem7Pp2264OHgiWTqt1KMw//XETJWdQBCDC5kFd6mVUPPndCuBfKnoGcGK9fppjF2h9aBNIHNcL/RUs8TSiiHUOOVGxLOY9F3MBR7o2DxfjdRprv0hnxeCDQ539sid9nWOmh+WNNJAB0qA3KE05Hkc8kUIcdiYyXMCZ8hk4THC1EvwOy0JeYTpfemlZjrwcWFdwDsDGMIDA8IP1eMkCV5HEJVFRp0/Jbn9pZx+cI0dxkGD4ahIghAO62qfQ0ySQSCAF5S2AAKk4MgBhaKtNn5ebe88eoXzAVXVkmN/5QlTcsWMEocRfdals9bIlc4X4mppIR+ABYsmknlQApFqIp1DUiidoAdPgQSjTdQAbFSDUue646+YK1Yj0BzlpQ+aGZk4IpnOm+pFM0Untq6IgAbVcs6U1sMW78AvygTzILtAgx1oKfYwWoAZgIzE7CyD3VjhiuR2zkWCQu6mxaNNcgXZh4eylDVq27fNGBu/o+vSSOjH40Y6kXvBs3fnC1dgJRjjHi7mehYHczlnkED8SQ65/Pp7CfHy+t6ruLoQDpSFno1MjTW+ObDZln2sf73IR9i3bA4oq6DNUd2671NtsCSnuI9poiTBtvWoIymqVYlE/e+PhDkN7xbZlHt3B//Ln+T3zQpuuuJb2kJG383EBpOMABPRzSsjr5Ws//+HTxycUlQv7PtHj6ri/70tb7ln9+h9JWg1A/A1dr/NtRCaiaSSBOFJIc0jF7YgjBY5ce5pBgxci3rZQwgyrm+telqtBmVrXvWgJ7NQMqwKnB3NtX/5fA/eOLA7xDlECUG6ymrN38OGv1Rr3tchLDq+4MolAvw66XqJ1nCaF9NsjiaUQhSmEoK3Cx586V18qY29gY+NgZ6+G8wr/qRsws4g8VZ3YUK7KZraNJLLYDCylkEDCjngqGU8hDjtX0RFclGtleCx3CRyUdnnVQlNzsOtHXyzXpaICFmHMMP3quR93Fi0+7xAhAms0I3T4S0NfWxC0nzaev6MhuHo+jbUqWMXv1+khkG6k3xx5v0p1IINOrmclD0CDkDzuHwYIHO0BJE7T/EMDHl5g7Bmk09qVi6JeGQlEMgDiSMSTSCKRQnwzJmsnlVOFoaEVLWQDDVgN1YIXPQNikPE7wrkz03W+ry+4INg7qnK8SE5ToaACSGK+DBT9+JFjoa99X+t/FgxU5rdQOMLQnBbWEZgGyST2x4S3RhIFdAhKyIJhVQRbFdEovfXklOgwLkmM2AMFuytFuW4T4ok3winwqLUrH1OJZCqOeDIZRyoVTyGeBLc2Y21DHYpCQOZ1wOfzRcSGojLiSDddwM6thdwG78DsD4fypVCQMRVRWhJRn1+QO0q5J3R8jflpY0TpJDdKX4PxzfecaOzO0eHc0B7yxn19jMndG4kAic0IyOUxRaOZLCZiEPq1CuXzmqcWkQFki2D52mN22WwovfilnVLhqadaMDZ9q1gsApZGEtkrzyYVS8WRAmCPI4VkCqbIgD27WHe3b+uylDxbsawGOE0SXb5AkHVRQcxAb73n2b/z1272aWSvhF5ckID+hrbnS66niFTrgYu7Zmf0veP25BNjh197ciVqWdO67WvurZV2B6PUB3OzcXIWwGX7r+9VjC7EoIX3LubhE9wXlloDzpI+XVnkq7kTJ+2trvLp50rO1irPe9W1wo39zu6hnTo2BJZYAFDAjtn4EcTncwju2Lp1a8cL80BiNubZc8vFFbPH2yx3W972KrOKcFCxm8VZG4FyqbXCw2VIdn+kUDTvKNtEoAVnRVctrdkT+t9mx5e++tD/+FVH54LJ/Cxd2xCD3/7110dsXMm1w/bnnZ3c+1TnDgfj7jVyXcHuSEdPDkDMv6P3+ajb6D5ELLGa4F7OlaZ3wsEuAGtdRF6eXKCfeOmCnfbSNQ0IDVnPB80TsztfvNWxdjlENosds/EU4kEnAFCXErPxI+j23rLuYvx+pzMg28unjOVmj3Mo5KhfLErF1nTBT7UWcyGZ+ADu9O91eFRVVUVn5WzNXhPY8h2pv371hfcLo58fKna5/L891g6q0Qqvcd/Y0tXW7Wfqoa71Q3Cfk5ZerzICgDQQ4wBNwbYM9tNivgIwnhN5JyTX5hAzGCkQpwDHFmFDJzvW4YKJ0YmRaCY1CrzhK7aQQiJ5OQIwkoynkADtb/cXGCngaYmoQbUcbEyEYt4xRxSBYQSKaDVs/o8TLen2RYWpGb3QztYDsuDU9hz9+kef/Elo6r1uWivs+nvs8rlCFr9j6iFy/Cn3A/YCb1nk8f4C4eOiHckZXV6OIsMp6YgaIDAiH79LVeAFSgUle5dlklUghjSIfgnte4l/BpQ0ECVhwjxA6lF6KZy/sDnwBJLyXWg07wJQ9VQ9PFKJ5IbbqQ1qobVcJhDaAYLIeyuAJGpesr8pGkOlGFDiVf/drh+vxRcZbonioB2vB0pCb47d8ej9+NPvPYdESIN7dnzsBh+HJdHj1b467tnRsJvDtbNz48DYwIhmvjsqzYULJpapCEWxtMZWPrBvTUPFyx/PU3G7Sm4aUIgDInfvTSVmiuEwMpkBoh53xXSRkqvGbeKIJxNwAs7NlQwepBBPAuTBcH8D9XpN6AGgoGRzWmKpdVzrEJoA8p3B6aFlC78X2kEA4CBWzzBMSejN7dnx6LdhrZuAfUXuKx5DPKBwiqghMOvAvm7Yoxi6DUdufvUQYPzJjQzzycKpUqdaqDKmpnYkB3kLqyB8rNJwKtpmPjqeiqcSyVjXTcwiC+XsZo5ETEXCOkwvavTVpRcAqp6rghZPIYHdPBaq4oBfrjdEuW6BhK2zaleJ0voWNBlr8l3nESxeQpxmIC5JvdDOtAKETuZ+Ovno179dEz73Eww3oRZ7Hxu7+YKj3Q5xyjqNI1XwdrrpQ8b8denn4Ul8Ezjy3Mh9OX8hU1pS6huVGBeuLXvBcvOlGUSoTf8phRTWoxy6cLQGAFnE0jElgiSiHiWAY5ujRjIuoeq5gqPqARCv9A4AJ9DvDBGXxAaymuWTp/7L3yRwB9iCRRTPuKdL7IbWj3wvmXdwIqpnWlunBRJ7Jhee+XbdfKAC+OsawkXEK7mWyrEuxn0T2n+hU/Z1A0eWtLa/0ujKZ7Z89RAwZh7a1VEoLufzSpMbKANVqEs0YprrDV1pZJH4o1be7J6Ip4A00kAE8bWq67LvHE8hnsJdb7DDA6TiKQz5/TkItFZ1VITLMvg3FB4DMPbxXrsmtAh/KQcSnetrPhGonmkJhEBiz3cXnrnn3y3rcz/BQfdiYCdxCMYpGX5iRqCGcaSV7F6xs79EgBWr0x4Z6fCvP/+xAnnksccwNmDdh0K64dyaqZpEj1HAfT+NXuPgA/GNnLFNtsUvZ4MR7Qi3hIpOTmziSCRTQFVsX2VHI5FMxdwEgggWpgU4XFJgnsh7K/3PLucQPneJoZob9TrUoV3nZC+wEfYo3FSxhcCyU9vzXTxTF2iT/yPAsLxWrozkBiMPoVpt9Aq4Y9VhwN5DQiDNjvbpvhwrlTLQmL3PLlwcBx6x/524pbGuduWCuPkpuEcX3ogvIgukMXAx9EbmLQPEmdBKFfEUkIon4/bkXWhvThEDjIZkDEHuVrmAY0C45PeIyzXFAsG5HP35OS4UFtvLEgpbFoJgk8brF1fd/FSxtZXYxLEAof4l8qU4fnxx0cs0Dhs/vuUkiyKp9rPUkdWdrW6vfeprpspBXbvR2D0d1Aitp2hzdd3zhdLkBdthGF8x+Epb8HzLJJOjFK6lFEZ0F5m67qtRk/NcXg2AZFzyXo1vaZiMp2L6bnYfCoDfEh2Atwyi0gUOcHjrwaamSs2hIQSP+QXyywcwPGWCAbEMbc938XXhHuCvPvVxiSsFWH/xbny/awpcrs76a8/gzL2M3DDII/hCH5YwhE7PDm63ySyUiPOBzCtLXZGbvjNGWaB4Wpiue9MwQ7iedFft+i8SqLWrSCGFVBypeMp75QAHBkjFgwLNn5sCEIBLhYKcakH1U6bTgCAUVsqR/n7gmN8CAJwqNptycJkknd/9+mMfxTN9XyI/9yD10l5jq+M2nxFGmC/RQ31YGR/7ICmDkMm//jLT0KBABJROdY/PORQWpktyKbC7V3wwvdVoODvMpVIyGr1+zBHAA0xcG3NAcx02bAYAUol4KtG4csAJrYF4Sue2DAf8C37kiDoYrlIFvGxniJQ9qIg7c1AdxVxOCADjAF0n6qy2TGLl+S9/if73+u9//Wuf+jsleBw3reNVfL+BGUsI55aiv4t+UODLsFPJlgoFNs1F9i5hIbhdcwIL0BZ4f8+yX2vJLr9RAGjW2bgmeJVEhDJBR66NOUStXr2a2Vye40kgedf1shhnQvwpugQVdC7s4lAk8lbF15weIhVqSMK+DRBzYUxP8y5g9ymhHgxoJFaWv/7RZ0B/6csb3cfitcxxl+JcfQ/2X9RRGpqxd0i9Y31/YfqaXieJm0kO4FZmjr+yRvUOiWDMrd2hPgvywgKR09AiUDLTkYp5Jf51mXgPapPZa/wQeKBWM9hkSQqI4ypHNnMODDsAuuRngVJLoJQlDyzAsvVCEgFRNKm5yWYuCCgLiGeC4UBg2YmVRxYczwD4OlztB3zk8Q9SpeUL1JFlpj6I3CBdm0Q/kva6BYM8YgLo5XJyw6ZUqqaE6SWVGW7vtnOAfwM2O+2eTcYFp3rdXI+BNYEErlnIUDUvL88ppBBH6rJ5AgAeG0ZRbAEBtqSygl8FuN66AhBcADAuNM01s2ZgV10+Fti559OGYZWk4DK0PY+40MQ9wJfclktZeBaoltprkLp1/2l/fQ6Ow2N995Ftj83SyUBJkRTOYamqtVA/c2n9ogca0JNDQO3Lra6giy81BgEPuxG/LvYloZZJ4o3cVhzACmKxzTkST43cdRcA2+bBRh10giQZLPB+YR9DsJcTdwgBnMJItnnluKIEAYu1giXq+z4QxWUnWO+X73nmS/c8cw++/KXO96Bcurc1rerjjzrn9paEEqzwc+gfZNYdLdKwSJ4B4AAwVFLlgYX6qrdXRD7TrC8EHNWS4CPIU9kZhXOiitS1KbkeYDSeeCOZkIILDJ2+zJAr1mK7CgCYnPSgZYIf2lIkwu6tw5UwIBkAoUKEttp8fXG6sbiwcJ490Od/9RD2F5vFWVLrIf5q4Rl8/ZncM/XPfNUIPfkzu9bAtofwbk0+hjCGQD42NhKTUaG4lkpqHKf0NptEoCQM4QzgcADwEC0ManOw6tWASwmg3gYySmwSQCQCREfTozJULYWRN7z9Ub5mTibSAOLx+FX94rnMr2Qy1dmvtPrg72va15m6COdMGWAjANYBu19VOftOXCiWX0NSJXvdt21cjuIG70H9o33kfTgaGpmRtOOOsaYlsAemUdw2afS7iwAKK7phFyRFlDzzjOpw5FS2D+Z6SGJsTbCnh2ZLhAVzug5QKx4n0ohmgPA6wGgxANcHSkdMZGJXmPMblIqnoA9waO4s+NtMl+8yPrCQRMRq9eAxsHp4+sA50OOP6johmdqunGPnwS3E1xaeD+v0Ix2fAjy/CpDOkzjoWqFbx8AiePjiw7uu3IFsAFqztqHt3r9/P293dG13SKjNMyoCVgMWsdW9VEmjHWJXR6M3thFDMgNwSFdBTl4XMNYhR9NIxpB4q0By3A4wwBrdjedeeQkCL0EjWBCWJUKsUA4ACC+wWVfvIeMh7ELjl/x5fuqWnvJMsPcu0NXvvAfIb2/I5PL4o7tK4RI3xKr+X+DQ2tUliFQUUWTPNMOmRsoOBFiJEeHZkFkMFxqrPvClKomRHj7PmS4bUAeAhN29aUBe++g9qNEJAEim3oIl9lYsQTOATRwKFGqyCwogq14AkKRK+ULBj8GFQbjrT+J/aYHpoPPA0Zs8lTZjtHvf9d3f//2vOEPAS751vTKPd2f0BehF7CQPj525/2rBGMmBM8+UWttECVxzwwFoUJaDg0BWL6PiRenpNHTIPpCA90BgdGQEySQ8qKq/KUBADEgg/pscSQJgoVEK6QoHA9PPnxZRIioA54JiFI9p0yXoOG2rvTB+pDtXCiwTWFoQD1UbDD+43bhzqzUODL96BJ9+z/ijFYvGHpQGc6cR/7BxNVdGohc2xoslCSAIPw+IChXAzKDdvVHxwofpGACZncyAzLC806T1aHSkuuLC5G+MFkAaSCKViuN6iwZxO5IhhAVtdgNCmAEgAd5KiAB6g44gcwD+wuCBMP2YUfKzJYIThx++9GywtCSFQj0X55WPTAHcr8QDdWAbhxJO02yu97BhDeEN0RIhtXfssM8bnFZkgjIgcZBLmHEsKwDBGaUy4GGoGCYmkJTOk+hyuYq6hwcSuDbWWoVHTwJAAnGkrlWUAGBPIgEebuPSywvM9pEhkQNQgWpRABk9sA9CKThzbimF1JYVedc5VKdL77t3NQBOgtwKveeBYewO22fZ4xjr8TcxKITV7tM4uoNG5Q2OAOvm4GCXVT6zKhOFaaBdb2JQrTVUVEJY1QwklMLPOURGAJmdONYgEXb1F+k4EBHeECIaTkSQSCOJFK6zJVHFCOIAAstVq8kCZ8qaCBQBsGhCQm3qBOrIcdLJ8cddpRZlESY66z+nfCIHBpUi01Aeeve24gatPIeHfOfr/jn6NG8chvXMNTchL0iMITY6u1zCoJ/XLU5kCq1c9wzWFIBggktFIg60YQdkoDMLqFWS5AE9hVE+fU16l7zqfMTRug6IB5Owg35fER7Cwe/rXiyXJXg9AFQ4gOqUjBNDoP3630ihokL1Tol4Yu1el8ABorR2ph28+Ak3ziEQOPSYMZ0DWwqXhrCBI9bvw/vG7S9cMMKAommUsHW3LwRFYntwetBPaXl4uDPT2N4GexZJZLMAEBmZzNBqMX+i44Bq0qM3pmKbUCIyYFKRVgKbSiN6fXFKMgn955DPLEh+6MihqWxKd0RRUG+r3I7gAa122FoM6G7nmqMe+J1zL8YbMEVFu0Sgzvx1QPebKP0aR23su/dhOhDYnjKkWbv7Go6gcebSssaCYaqk0in1alR9qo4Zjc0DXsw0mBa9fuyNqZuVkUjqqEEnScC0RRlp8/vshAzP5sIbTwEZeK5BMgKAHgBKJeQKYAFsCndlrZcDwPr5wrn2cwa1VzFpuuELnjdvvLulXzh+PudpMnZ85HfuvLWH4B2HxgzGX8gKkNE3/n3373evXJ0iIIfs9ekzxze8rCZOKxLMnv7VYRZ9esOyvGjpyGLdNXpl6qaALJJwsTQmAJKsweX0REcAJBCpYSKL5GYEBSO/UaCizwF+FnUsAAI4GCrghQTgkFA6U1jeIJe+M3bowV8WWxX9pmKgcPzSmWaFnEOAfbD18Y8K0VVjAfEGYfl2UKyt9FUYvx9qevk3ll+zX4BmNVcurV/0djMMWTyrnRgUiqrqBbpL01QCUK8+28vLKl+bBCYmJqqZDHnRdOmj0UQSWWDTjUxdb8JvUgIYgD+wD5geVOt1AGABdIoo5l7ZTdRyA4dhhbZ+x3jsQe/PXzzhK06jyNaLq1IPQVc/gdrRscPvmRszMNwNZoBjNsYfv6fY0Nus4woSkrcP3r5/2DFfypeVVVutJOXAzYU3gAp8zWlkWylX9epamkIGGDlw5c8MolWOhMt0rUdH4IFns6EkFcc1ThUAODetslJwA3twmg0IDoACwK61QUJumvSW9yC+TtCB18uIPfph8p8ajXpLY8k8FuoPto65bIG7yhgfMHvWTUiSFU6h7xnFodN6y7rMFdIR6vQ4hZJDgyyVfjk9yxB0YG+hoeThdc6XAGWUb187ptHIJN+ggRhiESCTyUyQJAmXQieceSeACOJIxYE3VaIlQM0Bp9yYG4KqwQsYAFAi4JHUUzX33Tiyuui4wXHhxck/2nb7sS90iKzGcOgbdplPbfl+AXPuS2PYr4EHBDpQHH/U+n1UKNVF2tp2CgDsogRGlHwDc8xK9w8fA8q5YI7OGeWQCudsdQYwNyfnFaKpKKqZy9FFAPHUBKIeKQTIISBaF5BCPIXJa6KMAJCM4X0F7J1CGAKt1ysiKMCrEjVME5ZF0w5jUZVEjtiwToZmf05WAgDsgV1TsPDcR16IbCng7Hjz9R4HhZpCSC/iT6tOQIbsbTlMcPw6T0oioy2JIrnd2UeNJsfge88NKwTbqKhVb63qADS+IVwdThSxpMclX1stZwcimQkbSSZreZibsfoU3sQRGxKwTcF/QvYDYa7W3wMUy6iwlnSGYQRsP4hsVRGW5rUu99ZdFfmfhrs5c0cYJwJECXh3xLYQlh7Gr2ahMhxTLN41/mi1bzPiWiFbNtKmeizSyHMisCRJosDt2/mZI4DjkR/O67aqhyuZxxHrKk4gdkXtZYCYk89NxjGCy40NOSALMJoGlSnyEBIJpBJxXL9oSXcBGlDaB70gCPWBeRkI+ABoy63ufY5tEerx1y+4UTNhp0o2m/YRZ0HY321aWChNHR0OceG+ldupIyZdcGntPMJ/jj+F3Ql4wUOWjaqtbdrsM5bsE5VeCdAUQDiC7/RM/P4vQbUc3ucqGGFkDeIv3hhSegQyixQmcdmK36zFScfS8NY5wEricqHUNQkFzYFkjJnzD51SBauyTV81oQAaEQJDSzN9gaJjzM1F81ZBQ74jVNrtqOYoDUuBSqXPfvCo//VGkfL6IFRkNK2g4CiMj1V3YwWoQAYgowKvRTqIcjXflBhG8gK1zPij3ezNp2anPP4OpUrGJpW8DVdT6IgjqsvXTZmrAAEIVdm1eTAev54jTkTSLORgfQjNDqpZ1GcBtz2UV7EroJ4qH8RNNuJ4qVBkWo6A0ZIJxnCIXC/B7HUcPXqwr4whetkYs+g9aLWLOeY59L+5dqZSte/giquE1GXTLLJX6UrjBjQaa21ipqO6QGsYNa8VdaRA09Cz11ZnvUH1LEbNK+ddRwyQjVXsXaeGinVBspXQs5VkS+aSHTgXeY24m3rcqQeJOVWQbz87ReHFhMSJkghj1WYHvAbDLvecpDJtcmZoAUzX2ceO+Hf/xt1Jym3nveZqmWsV8kxtDrvDyOthEcShRjKdBro9kWuHpYOcSLx1x2U2ARXmyBWOvJlomzdcUobq04VhFgAPfy/K2JV1dDnG3g2Z+FllCMTJEnXDB++XRFGCpBkB6yiG15f9fHhmfIzPdSO3b5+68jpW3MRvAumbbHdt3+FdK6xOzxyfHW9ac3d76NZG729970cxwCRRfWPRQiLyZv1wHUUmyc21OpX6DSRptCsOJwdg4YQKYBk5eAlN6ulL4KFXFHdpVwvMVj7UOmY1REUBPGurOfrv88NyUR9aPIeDWfI0H6ZWo43HjDv75Df/PEgqcdPSagNezecgbNaRo8v49VZ3j+H5V2sQ0VFUkalfczrvAv3W3T8RJFrCyGWUCaTehHgkodvgZgNBgQBYQFEQRsVL7bgxiscvMP3mIO+EUnqie4dLAurLBdHWLTd/sPGJYkMIT/nGx5pNWYDfvk0/gfpfBH7z/vanqp+mYNSd1QLfUSNPohiax5m+4fW24oPHROa6GsF10OQkkHgLKFlASWMEZjQDJOP2qtNzzdEGkgmlRhAOd3gamoWCAOR0byUUbI3tctI9Cz2nwv6S6vjkq/7asuW5pI1Aypp/uuhCTUAx/CQeqpZYqFTVmP7m2ELSWfmN+5ND711MjlE+ZrzNb6hKTyuAxvqWwlxoZqmeBk+OxHBNXJR2YQl4m4asJADU4AEQT7Wud+mF5l1oXpwu2E1RUBkAwPFdQgXFn2UOOEGuMcV6abEnSHf7L3nWKoqklLTAwK/+a+vfljmEtcJjY8IGVPQse0on0b/W/s2mApChtnPn7y4/PjYe3bakXhLu3Ee1JWzvK5rHsyOmsDQJjL4xpkmedwF467qoWDoOPQMTQAr260WrDVQLytN6iNfCgAAPx+0/B1hQZ8ybiOP+QZW17LPVF6f9+zyQFlh2fiU1/QeHf+qOFlFknsOftwIAHB1132PGSK9N9v7G3clpaGZLGr39iTEcuvkenisoDZFw1WdLsZiHnZmLpiPqFbcqjqi8mSR562UrDmAAQAyJeDIBh+3KgSrgqQJNi5jKGWC5MKrA8bAFwmn2kmjtsU45EGRPtna55s5Ye1mPxqGkdty+3bWo7A5rjsfGZiCIQni5+XIJR90jsFtcx5uKpsm8ooF1OW7c8ielJ77s+PVGo7FaWM/v1Ol0XVc7kAGuVicrcGECV72SN1MaKWR6K4jWgRTwPOqwvXHU00yvoZifWV1Q9RJqivf2MroIpzdYn+5HkW1oBPFh6tk1c3vXFF9lSuHALrdS1m/c3tNmnkN/rtxEPdcxFTw0dmaIaNOwqVbHdXe3/Rs33LApNDxNgsu+8ump6Yabo8rlfGu24Ag1fGvYa/VcrtwMB1jCuwbMX6mEehPNx3LwkrTHzM3GO15IvJDbSlYYANBMCtB2+bYG2U7FoG5yLAouOiMbq/BSF7yy7AwxMt2q/vMtNzZv6wq5PYIQKKlLgQM/DHs5o+D+9NiNVqVSZU1P8/a//vipxfZGw27aiRbLvmFzgDTGozd/Tyyz8IIcf9Tv6CiZbkckP70ej3ou8h4AHKJRIA6wMN8SwFXRSseRoUlVB1JpAHi+fdlxdwJVzxrwof5cSbULfLiXcwY2f4xYdvc25qUeWjyTmLPfwqDBqHbOoQRDP3nA5VDRtp/Gn4u7wnWosHp8Y/uTZdkLEESbNNvXCBj51BNjeKznX86sZefWcYPVvz6AFYIpIJNyBdoN5yiS9jQyiClxwFV7c+DtGopuJkYmAU8UiCeAOJ6H+MYJvO6qCnUA82VAaQDwWvAyYX+p3m/OKxJavrVfzUnKkiMUyFk1IG9vc43C8pyhdS+bPlFQS8cRXysCAOSK0rLRNpXt8G5iIW+PjqWTY+OJW7OvHwRTWCGqRd6aYnwYgDxXlenoqD66WVqeAN6UR7yOrkCc4E0AqWQrkQKev+pdeqo8XXMCGOpHLlcFYKEMwNO02kMzBbtqvVvciw/SkMAoRseACTy7QqoKe3J8onTJu33/1n4/+WkE74cX2LR6jVab1lVr0zEhAwPsjbs/+reP4vAj1Bj4dQuETs3kEQGOwVNLwjSXMJLmOLNgwvM2K+9VigG4SCKCBFLXapsGqp6Uc9ushJ2RwS7qsmnsA3hfL6U5IBRbL7o2mPhsLwBoK45pHM3/gLigN8uPQfD2GpKtU8AM9fgazTuDl9WhbBAqS5qqBwDIvF5TSN9DfzibBAbI+Y1VYpv/4tk6hzCQoDPwAC7oo+0mJRDExNutvFcoDaDbRBaIxxJxxPE8qgBsToiAioVpgdDKmgfgAEKtED4Q1orjNHr20jjR+oXgBHo5kIut0FHcX63L0+XTODKgSL1QQN+2hr5ZWV65WvQty/J61UYaAGAvHz08fp9jZZvS3XQoNt2gS9bWVjBNUQCqk5FslZ4cNbHiYZSuVe42y8LbNfXGrzGSI2F9Atg058U2PMse57Jnf9NS2X79Bezf2a8weYBFBcSSAVXwSQR/cMcvkBMhQswvWN96GPnR8vJ8y3YYgoxeCRKnnR8/0vqqt+Ilytfe19g0IEnr00b31MpaUp4ncLC/6hfbHbm6iAwNNTqJLDKTQIXkDImk4CYFPQ3gTUHqTbqKYwkeJGlEEI8nMNJog+P6nVpXZ2cwOOTc0Z2vX+S8kEJAvoI19AAsGgE732LxQWd9SnWigxwIHcVLJ1yDO2gKR7rASWiiZE+gff96BbgOx5W9AUiG+jKr0i8+OLGCI2beuNCxA2emV0bjMh/wXJ4RqlJkfGELFSWkbLkxiuuMrch1/wHxSIB3AoAAxY7EJMR4LPYRkdn3Ae92q7BHbWxhC4V8kwHK8AZ9OAegR1/y5ItHH8jXztdLEs6Xat8dzv+xy6GJvQkIFUkCHCIxiyM7KAC/aTACgP0H6A8UYeHjP6CSU9XAxlTEXacyiVaWctVGJrOxNECwAseXYIiXRKLiRRS0jKte4vX/ASlErzykNIC44977G3Cu1H6PaArDVRaAvXVqCBwAVILuUqDob5ANEOqn/s+c5JeJZkmY8rhr/7dyl7DS0CdxpKvNVkSTLDlSaKPB/6Yncpkjjxl9pUDha483Pz02alYKewfMcyaQTIGuudgo0gDSnZypYmTNEpXVshcul05RoEbfrn+mBnKTZ6NArGFbAd+Wuod8KwAETBvusFqfgoIsa8GuQR4itp4Qu6Zd32NJlPz16fmZYvLPPoEFkTIa5TX42yDFJd7Zmhv/gjXUgTf3pV3lCOruYunY0fiPDo9dWCKCS4We2au8k2xRwFOlFZhOYskEicCkyU+Ouni4yGrUk3prW0Vms0gk05gA0gdRu9BcunR+ZzYHvLYfQ+d38sJ0wMWZUL0VFlvmc4z88gk8bLj9hWGcYNV6z83fKm0hLwpn++258TGr3oTENUwugUMWq5Ltt7ojAHLsZeh7HwMOBx84p6xW+3c3yiQfRQysy91DdXV1ObvotA6DyIN0n5pEdjI6UVttwHR5qtHNjXnepFp6yXUgGQfiQIIy1k7c3Hhp9WJp71ArDOmcB6DQDwDVCgBZDvu5L4SMUq3+mjV1Dio0gq468KrdG8iVfxcoLnlsHDM99xyaOz7OtmFzcW/NkYGuZZwDkfqvhfN2nrfP981spJGI1KPAeXTLpIkaDhDFPYs22V26XB2XiVRrcMEF8I0o3mS2jJo1GoCCRCuRTCbQHqC+g/DBYSyoxGk938nYzxBL3Wg2QiskueOcH6Vg6YD/BKJbckwJOFAsfax1YtkKIlhboMbMg9Qf790u+U7OoT7E2xWeatvecp6QfQbRThkY/9pH0IKb+/BcAUCSojpM8oKvKE3oumGQ9J7SSAdXLEYiKdgTCWQz7BwNEpuuxujoNWb9KIBJJJBG0g5go1U6gvqNH+ubOgEBpCzQ3olSvwCoyHcAEP0L8rJfnLop7t26W+AhFIkf1T7xd/2KAzblyNiXCQp/++GTfYuV8bEqWVmBbNTMt5zvxHN6MRptkpaVzBctYnnw5LlsIolRs7a5m0PcngT2aj4QoTXJ4IDMpuaL25MARnS4AICsZhBPxdIAEiq/amSjm5XOkey9Ntf/cjw1bHku5QH73hPq+62fszd5FLb2z5JJ7uxw6GxgxfTubigikPfkyEWBPvKv5ItrImeeSTxuLH3tKFLjACBVb2DeZukFAPshY+IHY6RJPGnkDN5t2kwBSURNgEYcqU117eacWG7whicAOUqvYWTysiqZjGkVEaBVT9TTHkXUAyd4qOfhAeIpBRTgDH8JHIViB7Wypz6lCWWwakgFVt2Sr7KzotjrJLCtCHGJE0OKL5u6IxT/+4WCyE07ErDs44d0/4GvCF+OB7/wDPP2MAD74xQwZjmQmi51g+6frmNE95jQM3GkEpvq+t265TcUvuk4MWrCBf0AH8Fm5hDcZYPlQFcRqIacKAJsiPVgdCIVBzwxyQYSw04bGLqfojQ+bEkYUlROW6+j6j1153yrfyXsbDCc1CupDabc/sxPpsAoXiB4DEfOLxkpEOZz7Tu0V5LsyjvggN33z767HOM4sq62LGB5vqJkR01ys65hU4HfVWW7jDU0WtmRZYZn4eIFERgFqhmsxbgUALCNaqjC1WrwVMGaqAKj1VQingLuW/OiQIkiNBHkjeLF8xLrIDnJBsPqUn3gZSm8tK8tSb1AQ5TKW6cOHv3uZzKDltaYG7vpZt/AvuVci9MovOdLTe87ccT2sGmd+9DWkfBas6F7meqFX/dvN7Fh5Uafj216uHcZdlJecFpNfj7XJUwueHWBRovTLUsP9W2c7cgB8f4jC720kVnbepI3TZ1jNLg2PFsB566d7fbuZ4doD6vY606b394qqXLUjg1tusFSLY8V9KWcd7iXRbWlMht2a8nOHz34k5/MrFesvfd+XPmnW/t9tWqkqDz80380mqzDTTTfDghJyKtrvQ9+uF3gOvz6yMk6Jk2GpGVUr5i5VSLUYflB2hQg6wYyxmp+FY1areZy0b3RzZo5RDtID8AhK+BstepBzWWaKSULvdXcPjb2/ol5gWUUdbmh7RgcdmC63mRQgddRKi7fBKYBqbcpSqIkbf0nwNt8WW7p+T/HwPPjcTInHZizOvlak0IFFOt5W4585982AneCfNFUbOjLzTdyo5ZZbZ99Q2fnA1p9i7NWpPl5YNssIrCJ9XrjbMhDEBZH9Lu61iKTUVeLqK5hPjGbK2BtbWFtrZ+w+pVbRMG97UPa1lee+d8WZ1i03fA5mXbbGSjnpFUIdk4MysyIVAl5tZKTRbtTWb508N3/XfMbpOf38Q8JPErk2W6p+VGlu+hq282WrUW9DU/sPiC52HydakIKNl/WuFEnpMwIIthcQhHhmxZB5uGcRCwdSyKGugeeiRgySOhkG04zF8EI65QnNmdVIhkDhxQmRnmbYFslnF903rv3Q6cPj48bRzml0stBgbiZCQVHyzbgklVguuZW0V9V1POA9y7REbQCj+Px7wNP3ekvHRuq8pVGh12hbQTab91UDNjli7mNGsPpRov37/qPimAWOT0yeXlTDiBmNXnLutS1Jl7Of6aBqBNIX94laFSGC7TObhoqWSSSqHemEEPaRNuxkMGdLrMRtG6fnH6dAsZ3OJ0Iigq53lThhbOt0VgfPIVyGSDrNqJ+9GDozm+GXIZbfmzMPZh58m+tDwWmzx8wYBB2rwGi9XY4YLunRy7bXRcavXV78EeKpJtwMCdiOSDqL2BkSGeZ9paLfNl88Y1rhqjiGuYBRAqREyEH4xAo6OSJQqEAzCLmqO+Z7an32x1tyZ574Ld3rpScK3xgy+idofSRpxB2V0no67KkagHObetp9r7abO46V+2dVntl/Q9HU2vtlhBc+ddXvh2q+PnQN3aHZbvSXrIRBc1BVbS3wwEy4NyrFudN+bUOjyZdytaAKqJpjI5mEBmxdKvZ7loSNGIzs3IlnO3Z/JBFFpMTYFXTvBrpjaUnM+tIg+XlpIoY2z1V6qq6UGObe9/7szLGo1+z8mSpolR9XrgDZG79Ei8K04tqETj9rR/AO1+PDLEF5/iY2t661ncIv5Ya/YBp6V7A2f22OED8w33VZ+y0+WoH3fvCDPy1GjwmALJqZJFQLKJsdJoodz5/+fzERp304lgsjSiYNDAKDelRJ9C4EimKpQFEsAWrRhb3f/Am41Jxn+QNmQXY/VqpeJCCcXRbKlf1IHzLmsZs2G9k9GmJhRqYvD8aapZedboghFrJUGWodO7EuDSN/GG7YtlaDbyTIrHjQumhfzf1G1DtKiCNe6BPjMKEicAIYBHwhfKFoLgZxI2n0AJsm509mzu3TQBAVfLyVyBcXrUDMjIAXDd2re4MLmi7jBpTd7QaivPfn3idgrFgD+W3EmfcoO0BN+nYQ2j1eWL0W0HOeL7PgSW6hW2VIcXmGm9ueG3rhAIHam/n5F4RrZPrr5CFl12zyj9TGgBSxsREjSQ7TA9dMGCFVkNBQ3kuBgCpGFLp7NXRpoHNOW6crckmromvRLJOHIsC98cpxdPJycykzXZ6tVUDccMt2w48O0YBC4CnI8z0DO6swNZgKCcTxD9JUIYLgPiveFwVwdlTWK83rM+0ZbnyFimRa8jLk4OMu7a2GFz2M8pP6ZHE5n5+mYmqTtpClqGReSLbRYubpcnxOhAdvT7zkUUkkgVdq41Gr/GwogIimWjMab48X5AZvogT59vFFy/6dzdof8A9/HMNDg8vajmPS1gHlhjAsL71kK2V/7sM6SPlbxpdEhT2ufFHFYg2ogLg7Xx1AABvWLY/65+/5KE36IEzylZNtzVfwM7+/nmsLXhtLb9CE7ptIG++kMvtDW0Jv1jA3pDhoV66rXf7JeC24NAlRLua3fMIOJ1gvWevMAT9aqsRPHvj/Tc7zwdPuuoWVbLQst+yTi6aVp9tdQMF+MQWwYRNrgnVseE2ZkL7/7sws1Ew1TVb5QddW3o4h3XAaIfAvPazt6zMvZYcFktWEICOYQdTKCRl8CQS9s2cbKY4N+/o6vxsOb/RBkZ4XreAEb5OM9UoSSp3xUGyyl3w8qI+Es/YWqaTvryoJZCtyBNZxPy3d209NN9sDtsBVYX/1PxyUzqRfnG/vOoF23QyogbAC5GTjI7a1Me9VL1tORKRQ/hkN5YqP8af9EFbHntb++oqWWzLXphhQNNTkWfNdCw9KpNI4kqwze3sZF+FyPsXMOJsQrDu0m0moWg2wYQDxJ0mQSm3NiiYVmO/CcjsZZFb5w+gBgjuWynSbe75NwHhkh96eNpf8nc0HS/1HzeBLtKNxjYPIEoiRFMpF6dCFd8CSBuAIzUg8MphjGpc6V77f4oDjlaLXKAuSYVq1NqoxK/bygwjjjaxOm8gpFRco2yJhElANUkeFnSAgAJCIxzcJEAQ8OJTl1QgkQCAjM6DjsDt/a3WmbIMV3162lL0MKDsdDucxWGNV60K+F7sKSiQ8sCSwjn+JYThu/9ECzgOGYBQAufcwJFBkeuknW8bArpKlapM7rB5BqrF5VVVSXEwQcdikc1soMJv7yCtPflV1Eja7AcJC52kKcOpAoT1PAeLtZqIgrAsZglPDGvVDn0dESDiAikjxlATx8/kpLrXP8QqXCu4wMJS18tkccdi3gKLEjKter4gr0si9NcPAmP/7NVLNoB6lGe4dm0OQyrXrtjeeZ5fIdu+fM7WLWqZqm+HOdlXe7UHpxKzHT252/z650/L5AKLIvfS7GIHumRCK9ps4IoOmLTVKU9usQzu6FqfXYcj0ESr4bSsRhfXs52jtaqZzfVxF5VgYHW+xS16ureuzLaN7d2WtF4RneeUbtlneUV9pbLHZpXmg51ylT+av+O5d1n+2w0KX2m7a40X/vSI07lGxosWV3tHCF7NqwF2qCiZxKyaBhDlEU0jmgSrj9iWfE9kfeAUwglgb92VJ51rAbCNYtPR9PBl4xTahB0jk3bQlqXYvIuEzpogdAdMjcwASCKhU/4ihoKF6dJC3/R6UGQVB33bd+8yrFUv0YFtS0BaG5CZC7MGfxQvfeihZbCgMLZFtGDOYahd7F5u4C1y0dfLVYfqrYAsOzqH33VjXRsBRgDVMzqKkbsMm83sIeGD0e5w89ZdCZ5/Yd2SObNQKlhwMHzOxu2/y3zZZlh3NYqmZVq1Gc7rUSshjterLFkFgPi2NbVXBnAKYPcFERQYgOl5fTjLEvCFMnilDnuxPqOGSfvTQH7VOm81f9gCHuoFmrPjX6ianMyR76zQAd6rogKQoV4fFjNWUb68xaJJgzWbnTY0PGuEwbFKywKapnUDNPMrZgB+3gtCEzotwHmHRdCk7CLAVwwRZlvxNSyL96xvmi+pAE0zwFCJnmYHTxSGhH6HokmnNa1NeC2IN5kQfQ6BVYGeHz98FM+G4k79rl9+5eNZgXSR9gR+S0Opchfwzgzh0UYNALmM9alcphgQAGRkFrV1j+mt582uUNk0uedhhYjW81WiI+AB/oooKj0hq202sEqg8TyaAIiKNdKyC4QFnavh//Ja8E4AacTh9vbv60OwWGI5t30BXd3rKBOHwmLFqvqcArvkH/L27e4TBIL62H0fzlMPVCynuP4Pz772siXbn8ORARGdHy1S3XinVYsHuZlrtu1acO/9WZukHTv6OnJ92KBd67xlJ53Mavm15UvoJeuwvGJbcdgNGwguvFYjyLrlsMg2EbbZLMu24UeuZdgJgHLWmWPBGokFxHbOz2ObcMuWxS0zTVA1p14LhKnmhk9MP6fnBZnZu97TbQsEBaZJ94tf/XOl9cyKZbRfycwPHtMvXepa/gAe8RqB5e+LRkGD421VIi8zsLebAEhs2W75dfpSCgBqaKMlFhtdErlGBG4D0G62CdqmEUSrAkMBU9UNCV4bQVhwOmkQhhIiOBtxymrmedS9TmKJRBVIpwBskIETxWma9fcJJdzimJfEsPS6v1/zAv5KT6+9m1QAqj8UfP5ux8cqR5vhxjj1sQMveD4I+TQe9zq0/D1VvKOdxVMuh2OzF4b0DDBzNjoZjCVTiHp4ymE2vc5V71rRYF9GDJNNptk68wrTnMBxwuvTqgThspMsbBtOq2JSDDFpCc2KjDQXqPpoLComaWIkBgARrr+uYqik7gK0Uh39ojJH9F5s5bHq6e69UNxekTgsKbb1M5Ufhx7UhneUHkZqZVg/UTu4cBh7tIqzouEdg3KgbNCItsUDsHuJn1Xbdmg0UA+sdKhOtCilEORpmQAQT2EC8UQyD2TAo0JejryPQjRrqGQQiThbME8hgecjT9/TYJv0xAGXngYwYvG7eHUIwFRxp6ue6e5WtFJjgF4HW/HqpX5FFqcBiOyluvEJ6wl6GjTl/Fbn1G6RlFZwZMBact+jgJeBt81Sod22N1WSbfAySK5YzE9r8YwchTDBW+/9ypaggGCrOdmZBtIpZBBHC1kegJKCudlBGZmoTtQ8LtfoKAA7BMSTG6CiMjJZIA8WMWASHmAIYKHB1TPctZXkuGY/1iueVSuwndZFKEEwSr1APqgee9aS2ysJ40Of+1bxv937vDk3pjcUpaLxl+thf5M2l7KWrSzLZtNp8Tzp9PmaTCqVoDKRNBzK0hOLss9GWByuliWmoCCqA0hHeUwKQAJZZECDhGlSAbkxUYcdXByuykQ8nh5FbSKRBuDthYzgNMfSqBeb/oqCIiMttSqAjy2xQxo4pyhBuYDSJ378ya+cYVugnvi7E098yDgcHR/YbnLkPW8bMrmiWxoVALLZZDnYPYR9aGUU89s9E1HozXyINBfJBvU8roTiEd/ciQ6ARyZxtcJxEqMkqq6O+moECT2WQpQnI0o66twuxTZbk3qhBqf8ClfCdHA2WMNaUx5YMrtWsUXriZDOMt9aE4WFH7e2fu69q+cax0/aPb/7B699r/MnR97TbF7yNmmj8/+XlQWYTYdFHCdy/2GtIr+9rYbmWTWwQTbaQTsaRWRjb6oNGDVBTlxf8zvSGM6jBmQQoVw4hlg90FF/Zg/rTmJ/733gFK6EoVydhX0/k5fLpV0np70Vb+cthfuD/+5jVyh//qRrCj8qHr7JXtg6MsjdGb9TzNscJ82dG9pH9f+fOADebidl+6zj/DGyu5EEkK8qJOz0RkM2A/zmFnRXKAIAZPVNJRyT4qk8XB5XdIR34RhQp8x8A2wa2Hac43nYFT9KNKupDgfAoAM6AN8tpXAQ9Cv/PXPh9dP/bQogN74yiJ3l9C9X7tpiqc3s0vaN8/mNq7W9b6cPA54rn+RWi3SuXFhsRCdsWkSfYpm2JTf5yUm1BpMdua6gWsDmpvfXUAwjcHq45WNO3qWzqAHgXahNJNIxHbj/dr9fqXMKLPAMhkgQ88AFDRT8IH64kV079xj20+n7DuLDa1/5PlAkgnjmXRzWXi/q/D07e37BX2mWfEvG8HDpb5Qxy1XyrNlDzyCuICub8Pby7kkkEpMZnTU7ryv4S2MC/LU44gD0qMxhHs88g64OYBSjNGp0ZD2RBgIev9DgUerz66XhPlEDGGZYzK13rXc1l4il3Csj40f6vO99OnR0+PZaz4MzDNn+VtTzi5DGYFuIc7nMe+94G0ZcxuGB7VprkpTW+jsTjRTcyGbJmglnNJVMJiAnyQpGo9dfffHaP1KbvRV0BohEcsI8XPToilqjJyEiMbE/vN0/pxThDwbq7DkhSsGcxomzLU/Rwd7Qs/+p490C2oMCed9BDNs+dnvGjvA5q97+La939badImqZBo68o9VLmtfh4MnVhrrX3bW5B/9EpibLnghiyXgYas115cFvUvSKf3M56pNKR2CSrVg80Ym5fDVH2pwhrTYZzy4k9cjxbbsQ1P3AqSAQgCIqc015kAQl+lyofOZBq0AdaXl7Qw8fPfitjn85b0HeeBdOhqSpWldbXcrXGs+PvcPiC7CwXRfpkm13rxZCHbqXVgZ2krMR7qUOo72V2AlzPkA7zE7WLxfi80B0DRhyWJtJkwIQKSS2zUYoj/VCh/vIrNsZoB0cVeVKZ/b3pTAYu2mg97Y9M9uWa9jiUkotvbatsdQ21ztritnrcfimv/U7K9lbPc73608cxU2fTbtabUaVf/ZFr91OrvU2JXgdFP9T4+1NRQdjIyqbh/kmAPBu2wEN697hqrlx+oZywElEVAiNk/P9Sm4twDB1mj+BeQBrwAjF1a9mfwZyPalIdsjE4k5yNkrrLrJ6ags1PxU34SzcdP9v794fuFgpDK75i3k4t9R8QUelG/apoyIxh5up2y88ctt9H+84evrn//iLyPPpvyYc9RuzL31C6rK4FZvPsYFAS/m9lbePAjlYW5O+zLDNs9z/SLKEF2rpxju6oHOMLqmGARdiKTeAau4YnKNXJOm6GvE0aCAKkKP2jQitu1ANjAKuCOwpRD88mrMLosWquhBWQfi39fdDCU4VdU8Elstf3P3qly8IY4eIrzEPPEF++PtEuXf74NTO0KfxYoDNWZB6RfNiTnkHJ4TUzbZ6tZLDyyOQHrG9nyl6CdPezZQIp153lwTqpUjXS5gF1taC/Q6KCpOezdo7r/AGR4DZSHbIxAs7kx40exzPhRgTtrrw4mzU7Ir0rKg+K9dqlZqKrWWtlbudy6VmOd+8pBedYYvfpfYv7f8zcS9xwy+q7sJHf8qX696Fb5u/s36jKYVJ0i3Zrbk/Xn17hngsVlNYwk43Aa9Lcbbdaa+PDIX7sb4yX+q/oZ5Ms1VMcmjzBwYiCcQiWb3akJ2NyzPec81vXX45EhlJIoss5BGPCfL5bBowNNJ9fIlvWeAB0M4hp1wCKW4Ntvv0mjNQdpKyeof902NBz7ZOXPL/+B++wC8ASvPYD8RbRi7prpAmiVpt0+t/O7IpMqq0jeMByvA29X+c843Zvi4UbVWfWnUGa+0+j+nvw8Js2ILzBeQKCSrN20yWX5gHgK3UGxzZNlsI7jLZdqMA9O+Wa20Hji0AAILbgz2kPRtUHYtDxC39fGc4IDCW1Di7UyY6NjSvteWBP1TtO35x7snj7/2AI3Tyv/68Uva+1POA9zv5d/3NrXuadVF1kku/7ay/JQS+CUDTmgBIRjPppqLZ2X9Z/KjhIc81O9sDVa817/1v7gwtkjyAKlxsBKNITiAr63BGo6O4PgavI8IDupoFQAu1uoevRYBEFAgLf8Qye7ecWywhiBPPnGmis6sHjmbldGVl2dPt3jf7bDV0yKjY/4r4g4HYH7x4ywLXS9z5q/EYBkQ80JbgFCVaIPE2lsk1BfEqyVI8OvV/XDxs/EQh/SVyh7+/6rVKM4PRpH1CNkdh6LyZHdlsmxRkUgYQjY5cK1oT4HWTrMoAonxeZUw5gxhARxLehO+WwVN13hoeWm/bBOL4LLhlhEo+R0XH1EaVe9j/kx+gNvM8+cubWo9+a+cotw7+1S8+/0nY8bgJFBoK9+t71JW3tEx4S706CllutWwWLz29eHjsJ70KyfuHSTg9leDq8l2DkVyMhDmCyQZ/j5wD4oCbmtDbLhMAfc2emBiZdPEwBAAuuRYSa7XRLJdIyqAe7BUsdTA8KE5Nmzveu99RP1N1MuySZlkqjWF7TF94af2xI6/s//H2KaHzx//wi081IK38rGYzBt6FPWwHOAm1ty2Ts2z0NW1icouw6U/bDxs3RUDb/sS9ViA9NvuaJbt2r1caAXurYQ60HKRd6i7MI35kDR47S2gQ2rpj4Q0cB9Cqns3F3YP8c32KaLOY+flZdOvBkPbCgI/0O9yr5e2c4KRfDTk4mvTmPedWNhoMt7U1fEf60RHXdycS2pfVkw/Xd+RqLnqil1e/9V8eF3TKVXPVZz7rlN4SR0ebbl1rlzTJ+z8nfRTDPc16gkTb5HFDB9OF9kV1p8cvkzUXBbQoleABKLEYspmJqsdlmli58sKnmH4ApGoAUNQ2Jj0XpUkFkVgcQzeSr43JVTWv17qjNchyfUuF5pXKxcAavJ1YpPtYHo93uPu+9cDDOPoHQeKuti3Y/PknCmLneewJgESvVuytrbxlMItTr8cBXv+jrsN4qqd4JgFS4/hB/kSTY7ttOHdgv9Upk3y7DrtmhNkocPl1ShmQJBAaZUYQwUiUAWoTbDaCdojNxUbNkIJ0tBNrmZ1+YtwwIQVVQi9tr+c19EXrDVjLU5U+2kTUmXkS5S2f/u7X6p87iuGbvp4LhvpdZ79xV3HjswuPU1UXSHCVe+xvaoe/jMNGv+kb/elSAk9FitVHkLQ9KAqOXK3pbi94XF3GubZkOSl34+S2ZJ+ds3XmkNg2CwALnYrOWpbl8NpCgoMjahnsnC1EWJAneuyE5VkYafvU2r4/3vcfr9xWWd1Rrp33u0uGUXd7HVTZ6fblQ7L7vI95aPt7/ljavv3UUaci4MAdn78QpupJ6VfnA6Fv47tOqmUZa/5lc6bJanizQuxow2o5yDeCdbz19OJH8RRjEg8gKZBsXiG3gr3JuwXGy8s7P2t1tZbhGkmCIGHqQDK5KU6TGbpKknB2DQ46IZM00AKoPDkBbqIKoEKDE+40cuNjARRP5Lrq03zXtoLOsJ4mNMKjZo7PDm/bZ6fG7ryl0XR/yRXCwW+BUPO1F28cEn85vgWPvzLX7JHQOPaZX8i/mVDnO1SwLVq/nL7yBnmHPm0/PJbugZ4wynTTvupzobO/fuL2185Ku6y18Mik7FzuyfXPc2iwZJSWs2nEU4gI6UlgBDUAoAEdMSDqUiY2ixsBajLG/MXAhV/jIceOjqXa7OGxW015BxoNkWPqF5fP+btyzIaPwMGwiL+vfuc7UyCfW6761k+DP58akCJGVuli5F7FVzJqbxF/p1SwCooB3eJlABXgf2ybOzR2U7tY/QDq86BJa3pFwU7/vpcIFwqegUpPmWTNRtgNpCZ001NEZHPzjTQATE5mMplMZnJSRiKtwAMGSGK0g6wiC8uxi6XHx6qADHcKf65CEkVRkUSOWWhCIsLU9hmq2U/aOqE6p4Dfo2sVs+eg/f+d6vvCGKgnuTWnqmjrn2HeslCDZhVZhkra7DwA3kfdYz809iGGyH8Syem6UCM190oNZPcpNdi1y3a20N4Z4QhUeVc0FUOVNHtV/o33uV3OEQKjnZkk0qMmqyRSI1FzczdA3We0UniIZ719VHncnt/cw1VUJNPWX902YPWy5hrWKRatrU4OyNdmF9siXPf9e/6Hn/9gEl+L/vvk2eWyQBTeKkxaKa7LAFAlTTvP8/i/p3sOjd25Fqw/gqS/WXg9QbJ10paH4hAWaDbAQr6UsFoMDR5IxzLImzuvbV9PXm5TmLDHER01sT6XhO4C6UEEkd7ttc7xR+0i6qear+MXCiTONCUJnrmpWahT1PLd7xsfW4QGfsH54/+5+1kBQk3hXvvzZkBHM3QxOzaeeEmhcuY7pRFktEiTBdh75hzGh9rNMwkk9TmH9Mkx4sfhnEPcgbVz6FtfuBR0Vz37/gSELPANDemoxwkZpHrFF4lkgWgGiAjcGuW2avTkqMnLNXQkERF6b6tL48md7rXzTef78EqnxIlSDxpSc0EvVq11+87Qeyl1xqWJmhBtFE/c3jU3xaE2/aBx0gNRgdSXe5J4AsY7JwwBr2XS1XHqsPGq5jjzCDL8hn7md6kk6ci1SNYJIYRchyiuVXuVi6GQTupwWkAHVuWKquiIRhEdGUEWm/Vo2bqS9XB8W4+aPGqZTBIxuB/eS30NRyq6LYAXcaSN3uYSswyTIYJkq4SOrsgFauxUkGNKxh9hdWvcdssv2wAror6NYZwaRGPjA//luPaf4UClSqef3nl47Cc+R/0RJC9srNQeoZIDRLa+oA5xnQppnOQb1SnS2qXjJ7KAqhY6BiChIh+qeUwAIN9oehudGHVCBrBGUfRkIgngY3/WY6fsLRjZJfJ9SNtFll8WJTCSrObW0UHX+hJUxuuoMqywS8m/8HvWd7vbLk3oGXuwzvU6l5XeJeGl0CfV/zS6yPPS0/ZDYx9aA5tAcqCQkx7B474wOTWtIueBZJpbi0yH13Q9T/j/G2eiyWE0GhlZJ8GRXSZIkoTTvDrvqzdClms1skYhIyOJWOTBO61fU4+vyQai7N143CsC6AEUoG6ViWZm+e5lqtl2NBnIjyA/80/a7DabC7YOdNp7RdNqKhJy7h/9pzi8aEvT8UNjB0xPPoGkPxeUHsHjcXHRzvZMAwCHthnQLK/k21WoNrvyipdrm54qADITrQLwgFyF6wCJCSAGizVrmZFJxFOjiSQQTyXeu/eVh8cc59HxkkEBsLEVTdUgNiXXatWAQySP/QznLFuD0XqfdiD/El1rM1gacBiLAvKLG0NeytCdTzz/nwGpoPX03ICRbM0FH0GSXm5OP4KkkLV/mBwC0G1BlBh+uCVv2Tq3HnA7fydkZ1NLMD06PTGBjGFkMhMTE5kMCROj0Wi6rjtDrig7utk2FkcKghl4mLrJmvfZtp1NjuHTfy801lQGUmj7TB2tHOg7b06OtUUooFjc/Dgu6i+rgH0a/8MFJ1fTpZWZov9HnndOUAHgqWn7oUdfbdVvSKDsR1N6BGXBst3tIDUrgBVdNXslwQ3o3SES1ZcLqxwiAZI0PXokAnRmY5dfKlqrVU2PZzTgkus8VCSQ1JKxVAIxZfspNAN9+3vA1EOfSW4f5/9lPbtiMViPNuYldh3nn8TADiyJWqrjvuDIg7g9wDBM+ZBxv8Ur4osLRdCC9e/Uf5KLhkN/eu7Q2LvWgu0IktP1mvSIkZwuLL3oGCN+FsB0wNwpBwoieymH7uw57QZAeMLXeC4SMHH9e8oj4HW4wMtkFa5aJpJFBMiOTsTULd7b72usY7AhKSJQV2oJYOyhhpcpt5I2j+J7t71n7MGQTWIE78BHkP/HLz1oFd3m2cOPv7et0t8df7Sre+vKnn1s452LA0A9vXh47KZe1BNIbui09AiecDrsdzsefYAsIYgiUZ5f7ubUdpghgluomTWaCEml92GCJF306AgARBNRAMhOZlAjV8lqJlNzRRFBNptFdbTOEsTgirZKLylMmJMkYWDop0ljPPofQrl5lilucOtznYizmsQw7Kc+AvzUtnX5eOL0zj9A9yWUz930ODn22rHBoeZK5Z044u2mnrYfHrszgjMHURYctPQIkjsc6oRj7AGOBAosUKozBiRG8E+THE/SeoXrEsqdsYmqF6Y+AiCTzADoBNCRmcioGcDj7coiGkUkggkhOHSfdPzFPXPTlzTeyfUGpLabO5k0xnv+eaZskIVCiKOgM5zIkY7PAcOVvp7Ap2EFW0favVwLzn2B5nhhyQHeW3mHuFyl+TQ5asTV+doj1NjxpS3SI2NJvWD3Pzb2IYoiMT3NYVfRP79S6R226SzpDJoGmvvhVO2IGbMkuvTNBCgAOzZ7MSYTQFUDspkMsshEwHxwuBjEc5JZb19qiGgoUm+3kz/5hPHYxAViIBC8s47HRThBn+YrwOfNPzFZxxi+AGE3zA1dmeXq2DbIy3Ll7TO4QOv5hQRF3XXy1+8BvhZ/be8jiAv77ccONb9UeO683V/ylw6c8OtWQXfLYtle33WOmKN77Pe2nmimY0J6lGy4SIzI2SziqTe2LYyloW921keyEDr6V+ag+EugiUtmbYCUOHCQuhZiZx9lO13P7iFeehhbi131kpJijuLgP375gFnEVyCYPLRAdJ5e7nkNv/XkO4bf0VmZXn4EgAMw8OUvt3c0Hdh34Zlzj429LgwrZeIfINAKp9i7XfVuRmrOEOh+/axdZ7a5/mWpk05GYWQP8A1VzuLq6+AAxBVLd+EYRvQMoplE5/1FP/Q6y+lh5MKF6KLLIUqiwrWPK7mc19HBNs+RH+KqHFH6X/dM4UeFlacDiS//ucORZh1QqGD9vCP+5cN99nfsdPH9gEwY/+MjyJUAoM6F0eeiHsfhR28OicETFokh6FAGQczninkRXQ5IoW2mbVu1QPsbxdEMkx2pySYdGMF1LeBpAOQIdABGzBeXoaPuV0v1adSnm8fLjFMSJc55foggmw6K3O8kvxr27N/6tdFfTQHk7y8M56ivNB2Ptl09QMiG8FGq/y+C71gI1Pk924/wxZ6fvrLUaDTabSdmZlM/GTt82D7KFs/P+wOkAEeYU1do7KrPywjtGNoY3tUdQDXa/gCaztatgG7oJEw2en3f5GQbQCRDRyG479qnIrwLJT/rxzTLtsLNs7rHbC41uk/ON25Aj3sa404/f+wzL5H35ZG/+BWr+Okxt4CP05ABaPWz42N9/9p8h8qsTv5p3tt6Lt72tWVZlhuRYBhrDh4war5yvZVZb9ke7jEZeUctkLuAJroJVJynykXHRsMjGHV33SDTiZeCzRP9lkXz3tDV2O88oh4QLwULudBa99a9xQYCr2KoqDawJ0cNZpvuttcosfYqJXcWJF3Y6/COkLt2F4qPffuzn5kqOSor+29NxdX32iSP0y7JZ7LpX3D/S75mI683Ee+4eOJHfxjnmiS4LcSWXbw+J6kc+8I3xlob51nfvoo9ZO9zuWp+nSsArErWPAh5wi8qLrI1GSJH7f+wbku0kEVkAvcbskeNXu0CHa2CX4UAZNAbl9Wh4DG/Pu1X98yc3jPnBquBXwgvsXS2XNgIoLlRNFH99j1PEc9v+xhGB4Krc8D4eEbhOEnUZKlr2ljqe3upAt/+6SuffOl9Xp9chl5w66dQZ9WdzA33jR1oTZGIVcM5mTRsNs1RYgfq2Ad5eg3t5fr54uFwF0VadRgdbDMFJLLAWoM0aY8Hm/s6RKHw8ABxxO6/m1dRnGJLAygNzexjZ8IFqPWgEqRw5ni7vGH27QzkiMfIwd9//k+e/pDwq8p//LaxPN48hEf5hSVJBIqwjdf/wvO2625HJ/+vU6Xv/SsqlxqwHO6tttE61J3lpxxjB3wEicELp6YHcqSoIMRrK7O8UNijNpmZmdm9fzue3O5s56Tqz//0T/n85U2/5GKVhIMe3SyO85hMUZgAUjA9fgtDRDfnPy0cmOaOcftyOUBgLbPK3SdfMlshq/+2vd34KtD426crhJf5ZbE4b8h3GR9v90JcghG8cGis8i/y23m43S3HuY2jw3/xLstu0/rv3rOT3SYdEHYuToyPfb610thzYG46j0DLrkECF5jHzuC07NdOm6+N44gk0L6B+Zb7rhPnEKjzI0mM6DVXJoZjB3Agz8A44GzrZj0GDYODH5OlIfhPsyq7F1BYHXuPITBYcdH8XKbStcIzXX2BkwX87/3o6HjKdgLOWdfy+KGb7WMfdXCkJGKe3I1dM8G3Cb9DbrdjP3v/mSmJ2nbJ2jFYL4pYnRGi9VOPHdEzKofcaX+dx3N+0ityvWK/wJbOaRyc5QfHxzIh5nze7fdgQ6fu+r1O1pJvxWQmkAE41EiEvDagARarAHDjncEBNogcBtnBY8eG+rhwYWpIHqJd0iorrjrgpdogCmspo2/dKjw1/cDfzX9v//ws8P8i7scSDaw1G4eMjrvf2n7nZZmX70+g7zP4t/dmevvqczYRRmeg+/w/jx8RGwF7iVaEkuCHX7HrrAhQ/Z6pwDJWHgGS/pYj0CENvRauFixivj9xbM5buc1n2GNppo1M1FMFap5i9h7neSadSAztdNZ3Tg9NQ993jFWxretSuw37RndO1DZUYc6yHLfu+OG2ifGBe7oHnO7Pu9COKn0nH33usbGAo9oriVIdp1C/n36rbh0elNdZfqn42QuYdZ5pH840ZreFuItkaejkyb8Z0M/snnP4ycEcY+l+XSUv5QGp0HuqeN489giOnNIpsUiL1glSvN0s5mWd+Ohnuj2k0pI2N8/JTGQymcwEAATqQGe3NRs5Xj8B5ApYZEXWEapvE3oEEvBLCw0rSITfzavtr6KvZK2/Z8rlZc69rtzwxXf/GLvEAiTAMMy/HVsg33qmy5Rz4wThMRlqzfJ+B9EzLposkDmRPvVN3BvYPRMO7KUvhC2lVaJBniWVJaDhCMDz12PPqqp1ieztpZ1Upr9jwGWzgF8uH/rTkKFaq5govvEOyJE2JSPhvslVS1CyzRkADQTtdYnIG3O1LhqitrQsr1vrXaB8689TTatv2wMPT3228sNFslEUOhaM2xdCEJklplZF3K9431oXFjaOrhT83/+HMmUSu8t4ZEfguRM57fw3x0FNF2ed6+WeQ5quDKpDCki+pomKgx3SmMpPDnhxvtg0fM7mmvd9zXm2p9N74YQW8pfgJO38zhGBvdL2RulqJcsJN4ZjcSR3dIuDQ6VpFvR8qWbfHVzZ4ZDAVTc2XD4f55PK5N8YR2d3zf7WURzUVsReDrnjOOroXRIlOOqOw4axulB5qyWLAvsvF3949Neu2C2nXmOL0ncQeVVDt/ec7YhkHJrYZtkm0DxY5CEscILtsYUdhrPltIqWk7IWbTZHQ2c2CjfR4RnLfBeKdbLtqaq9D2XrsFymjhXE5wGsDXGlrZ3vvbmxsaPJNnADRRYpbkuFLlVCEhHYsG0E5BllUfVR6A8f376ji3/o26f3XMIXPxvw9InqyYf/zFaTeyXRZhrnnrlNXtWfE96iYEO0ftx1Pn77qrT0vlduvbW8uuO3/r7b2Fm++723uuvnu7/Bf/zJbzxOXVCaOVet4SI3ghrHiXkiSAdbdtYRpDrwf1b8Nu/KoJ2lrY6BEJOtumZP7Lrn97gmSdE3bG6mHnMWEbyRd/QeGsvmdrmbAEAgXKo3ZS/qIUlhl9EkkPc79xNtwOq21j93FMOVG27bkZdXTlJHlWCvJCpF8sKnsQsWEs23mCXtlM1YwEq9fQ5jf+jvqS/royrP0A7jLluJPzD2mDj+eNcSwdn9uh8lcjWYUSWttVJpSRsNmtIHe9v7y+tOhGpd9tNLoYB/i239NbMqMa3P/F8htI0bgCQiQGHD/dHB+iQGLjrO2S5qZ7DPH1wAW8elRUERd2iVvBoiPI0YUQmPjo28ZLWngOEvDTLV9Vdqj2GbvSpBkZgpL3WkoANPvMUU8f60+tADN66XRj8+/ugH7e0iZ+4S7bEnDz2aNHrIDTYOHNmnla1SHfXSEEjKCmaqRmulYfcMOrrXN+qCz6zXz6qK2NXl5xV7hNseQjuPeu31ife4Sb/3xrvefUMLF7HjYLfgvde4GLbjBLkSxrncqT6Bw3TRHuCkwtleW14FSZHYKFIH3Y9sf2kKB53DAsgiuYAjKssoIscVexIYsozQpzyXp4j38j8e6HwSR9dm60RmkHr8wx7SJThxbHbX+cfsoy1tmiZ8KRwRZ2W2NATdj2m/LdSHZftyq1Oie+xUUWkRtk6uprVtBi1t4ehWc8PpCJBOxXSyZsB5w+quZZ9usBbPe4K7Qw7y9fc8++nei6q+Utq+5Grrdt1lsWaYcq8Vly64oQX7by4tpW6NdQZqH7iEbQQrKht+5SE8EpI3xLra9K7+4HG5KH5qvdnkOVa0HGbTy1a8Gi/D94uVR4Lq652j9//l47t9LKXStg1m55OPjD3VrBIuzfmz8SM7y7p9+1rJX+WcVs324pREG/W2sWFbc7cXAVslF2A8hVwz5FedeiddtUinLdCqyWturWbuccQOHSNCRr/Td2jArdhee7Lp1MxSE1BaDZdedSOa7+6AVKm21pjKgEdYEauf3m+xj/2a/fwXn7rZobYU4uIzRzqt1kCZ4YWZQ4/u6N5+sOJlNc6wW7Rh8k7CUeHR5P/3SuieR16lJ+83+oO9WncVWG5ve/KxsQdPFGysnzg6/vj2NWILNRdZszylxvaS7SOr6OeIDZarDqw7S8DAiq3hDM6yFi0IbbnlsPu9arhGuBlVlhu2it4Q32XdfuPd+7ferhHc0su3epiqbLcoanDtwLQtMr9lsZcRQBqrBblBhNn8e9iIYtvunh2M/c/G+zWlsVCxPYRvrqsOylqq5Q6N3VxiDip8jRULOF2YcVTtJl3gITtyC82e0uvUqW+MVfe01b6qVlsQ3dH32r+4VHFzfucdr5S5mpdvNjdy8OhN/xJsd9X7+0uL6FtCwJlzNfwVV61RcvqN3fNwmlWzO+Cs9TVqBOt2QCeCBoobiqvBz5dLuQYnLB3+eICX+7cs9W6ft11gkWPlVk8A0iI9vxSqd8fdY9O/E37S9O762w9+eWIn2Whp9kjzB0dcDAkLodyhsZu2Mr/lqTscNVYh3y3ufVkwTFNrOnxHXvrIN12m/773jN25jaLDqtR9Xm3+8h7jPqrg8PidUZSflmWyw1fJC8PFup9oHLB9gOFNsYaOjVapFJtmazEoLehb/aWCBNLyGkaJsTVcjb620+Ow8op7Q6jlfShfbFm1S4334t9UigzYRRfpWR/Ieyx1QAtTCj1HvtylanBph/9UnAv8P64vfcj166MIulwyob37L7+67hQ4Y7UzMnbT1vJvKazikEF8JP39df19zKtNDfB9awXTHyoaH7CNfZZ1ufmc6jotrp785tj26nnW4xKiSDZbZbc+MFtqNNeG1xrOxqLtb/JC14JqSIOKq7Hor/mnS56Gv70mztkUhXY1fIaTXnERWxWiO0g2w7ZVS2kKaqXAb1QqxPnYbZ6u9ZBBLTKW4l50l1qCq0cW7CfDp8oyY5iHg+Lew6XKf/2O0f72Ha5aXauGNXpw7F02jlBW5RvwB+TqJ2xNh2hq/OnQL+o3bHcdUpc1dP70fx/40BdfFx/4f8a+VOM4s+HUFsSVzF+rBxab4Lp3b0Fyo9yutO1rfVP+hr/oajT8DXsB5MxGEAszfdOsqvh1+BUhgNyJIQiOMzkH0xaXOKFGBQraSjhyrIPR8h0rBLwVeCt5R7c+16TW3BAlcB11Glq4uxJCrfW6Ag86P/tlmIeWd/yaWfnI9580a31tkuYXXsYfFhlJXFESSK7uu02nUKGcxumZqdUbfQHMvQvP4KdTv0z8G8UvYOyzMsM567VKXWQ8j5EHfAWS89t4JHVGd/B7ZrpPoOQn6vWARcCe23sCANSh4DQHTh84rQy6T2BwLhellN1nGq9xtl5IIUVp0szCgjOY17ECb7XapbJAZQWOEsGOEix6nUvb6/6SSDkUbbU3DW+Z+EjzoX+yJY5cSP3Fxx+0bfnhb5kgqObG+KMmozHTdAJPbPylzpEEjwI+PjO1cqMP9IyKxIPEVKgWLBofwqN32heGUKxVit2Lp8bHPr98HrTmjGJc725Os3uA0xgKHvPjwDHAb/tgNy8hX4JOcoa1eznnt7Ye89Q2lBhR9iw3FMqoWx5WkbxtdrjQ3Gd0rpllsIwXboohBDtLLZf5C5reJRBNO8G0fFXRwTVeXy0x2kDo9UVu45UfhDy7nly3xe8nmZazs/BB/KvsdhrtH79ypP3LCwRh1+2CPRuaWrnRByXX2mN257TUt96/fs9Lz459mTB7JUuq0RuVD79n7LMLawNWAHdgPFauukqRGYmzNUuNLRXX9J61A9O2/5LbutGl3eKs63rQ9aqnYSnOUgMtdtbrWVurwxMt1mc9lN9h9632scziclmj2DJLoeYkKBtRqgOVClY2eENd7qoGG26YOHmp7K103cS4Ne1P1JFv/PBj0gP2T1jo15uFxg8fHXI6lJXTf/rovfct2kmzVfwr815iafXGwUap5bepim/OPv/EC/82/uzYASLklBite44N/uq9Y59fnXFVOssTrxwxVMZebK15rKrL5ioFXBVXsak0bO+mJVfwJlenWXI4p/0llmsoLQwFgr7s4q6Ks9FoiKx+puJR3JLNRoBebC0zYFm1oFUYiqA8rCAIwjKrXdzoEsCR9ZJdPakseipEp+kt9q7u/7V1+9PL80UhWrKXCp61l175jlRzBuT34c8SDsIyjYefu3nso6+u7LvFKdlcimkSpb/8fs/q72TPqJ9lQ5LKSN1psfyzx77wRynFGRLY2+Jd21umveRp+PW6vzQ8D1RoRfGXhmyf6gj2s4Z+llhplPbkW56S32gNQXRtNJuFpjVAmJ3djoKtyNMGNlwr5oJqB+t2rKDbRRiGjaRsLZUSsFy2r5WNWtMWrJi5SrURdPu42aHCa8cWUWb+A7hTIqpcU176C8N9nquVon/5+B84CNjMjwE3tC7O7hsOMLVGlRIiM38c/5lv49++r35WdjlUpmYR1PqL3xi7ecW2z9kq30Z1dRXaA/mWzaUoe+bZjeaBaZei+ksI2P66rAWwlj2tspGNnGeLamubrZLLz4pG09zS7yyGCRe/vahJ+a2GC3PnLtU1favdxbBYrdupuuokKKaVr3u1CqnVCx7V5m+/uOLW5F3DO5c6737xNnv69leLyO8hWzTZX7yQ/suv/uT2xtQdzfLTtGWZHwNuXGvMfmI3W3G2yJaz+wfj+V6h/fHE2N6yzycxkkuWzV8+Zuw6bbWUsHkbNfbxBbpdhKdd9TQUV83VWDwwvb1ka/qXbF9paWrL7wrqNx+nqKgiObp2FFodLgoiY3e1fIGq7MNK0YRzq6O+Nn3JU7P3h8JDPrtuaVqdZZcshqR8VtWr1SoFvloQVs+odmg+v3XRc/5p48L+/bc+eAnJb905OjXQxufG/iz48k+3yrfuuJe0k/qlwnr3iDLXtYshVTVIWkL5S/cWOvqOJJrbzVyzV2l36/Ji6ptjHrpSdfQO9v7lkX1nidBKJGcLl2yuauPANPwLrRJcDVuTmIaCXrRX58PTGCr5fU25VITg2L/5tsl2rZyjiGYd2N1tzZ2ct5p0f69/yFnWprDYnge6kPd4SZioVNCVD7FoOUpAZcuBG6bJ6NjBHVuEnz2H4Y/b8PienJM6VD5G0AcdRuqRJmytI7VzvMU1EG03RE5i2Hra+r1nVn3vw6OHufkyIbaDM10rxx4b+/wyMS1a2oM4orroojJ42q/TJb+iHjiGPXMtruQv+UusXYQIqFounPOXcmGHIef2bpym9Us+LyB558lSnVUhDLl8jXMZ3QLd37vNgWXxUj+zrWZrV1YJD3spxJAQweY9q/B6Zz2oDgSX1ruAePCGYOdzOPjDwLNHDz/6AL3XeBZ6+fXM43/pgK11JC3sKkLp62aWAMn7/xUELzFNg3EAwP9dX+tjXbu1GQzYgIEElLAQTTSo82DwcfCiCSZqYkjQqEeIBzmaeNOTCYmJ0YsXjx5RD3iYCSRGQZkmMNjYKI923Rhr933tVn8/XF2eu/Ymub8DiwImxYHjH2BFf+FXc5kdojTs8x9gMdpcD9czy4BYI2SozhKoPyG9qSJA3BA57ZMHRcdJUMEiYC3cwuXCEH/YMGyxaWzldWLErkFoTGaqK7nmLhD9iYFOvkExmtigBAXxQgVRwUPQFZ6WSAN8TlcqCJLDZjzGzQZ6326P5oHbubgx+fq6spaN02XgQvxDyqO9xdWWC1e/EUma8Trr0lG7trTxJVtq5s+OuYTTHUJ/caKwNj+XiRAlH59LZme7aqLdlkFPHx6paLCo2plcptDotrqB7nPJp8gsIk5UA8jGoNm4jKFApAvg2IHNDck7A5pNakOsu7LV3AVFSY1HzEA5bISAbzfY3v5KRHQsaCq7FNmiZYWwFI5uRmMRNxjDjCQad2/NPGg/OuzfXrs8n4Unnt+Ozryn/AD6uh5ga551O5Vm6z17rvAsOHnnhWGOn/biYS7h8fjYYvD3l67bskXU4Z2EhUtmfBugqyTpgn8kOzxhF9QcN/g7lfNpjiHvHZMpSWEZ2qcNrtpyLFDtE6sTB55D4KCrqQVkaSOu+yeXpzgUD58XAB2Ye36Lr4StLiuiqS4jAmcpB9WgK9O0rIdoKimgdowQAuzu1ELt5mcFAtNX6rH7755PCGxmChE+4BuxDqnm90y6ow4b3mu0ZOhMGfGP6X26nmQTZtTEZo0PPp6L0TbWJOYCVCyqVaQduSgZXFW2k3yR90/p3OA/2Urpfdan/0wXA3APLfSaAAAAAElFTkSuQmCC";

// src/control/images/dtk_skaermkort_daempet_thumb.png
var dtk_skaermkort_daempet_thumb_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAMAAACahl6sAAADAFBMVEUAAAD////r7OTU5vDp5uf++/3//f/59/n18/Xt6+3d293V09XPzc/Ny83Lycvp5+rl4+bJx8rFw8b9/f/7+/3z8/Xv7/Hb293Nzc/Ly83JycvHx8nDw8W/v8GurrC5ubrq6+3i4+XS09XW2Nr3+Pnf4OHX5fLV5fPV5fHO09fV5/Pq7e/X6PPX5e7S6PXW6vXT5/LV5/HQ4evX5/DO3OTV4+vT3+bK1dvP2d/p8PTR5/LZ6PDa5uzJ0dW+xMe7v8Hy9vjLzc7Jy8zV5+/c6e/EzdHU6fLT5+/c7PPr9fnb4uXCx8nZ3uDj6+6ts7W1u730+/3f5uj6/v79///Nz8/n6OiRkpL9//3Nz83Jy8no7Ofp7+fp+uL5//bz9fLv8e7b3drLzcrDxcLp+9/v+unr9Obr+uLp8OXt+eXr9+Pz/O3o8OPd5df2/fHv/OXq8+Lo7+Hr7+fp7eXt7+vr7enj5eHo8N7m69/r8OPr7+Xp7ePHycT8/vnX2dTr8OHv8evt7+nr7efn6ePp7OHLzcbz9e7j5d7f4drIysLW2NDx8+vv8ent7+fr7eXNzsrz9evx8+nt7+Xr7ePU1dDS087r7eG8vbfKy8XGx8HDxL7q6+Xb3NbAwbrZ2tPQ0crNzsf19u/l5t/h4tvv8Ofx8ufv8OXt7uP19evz8+nz8+vx8ent7eXq6uPx8evv7+nt7ee3t7Oysq729vLy8u7v7+vt7enm5uLi4t7e3trW1tK5ubb+/vv5+fbq6ufZ2dbR0c7Pz8yIiIb///3t7evLy8nJycfAwL69vbuvr63T09KysrGsrKuoqKekpKOgoJ+cnJuYmJfz8env7eXt6+P18+3z8evv7efl493t6+bv7enOy8fv7evx7uz18/Lt6+rl4+Lh397d29rV09LPzczLycjJx8bb2NfFwsL//f39+/vNy8v9/f36+vr29vby8vLu7u7q6urm5ubi4uLe3t7a2trW1tbR0dHPz8/Nzc3Ly8vJycnGxsbCwsK3t7e0tLT////82rDGAAABAHRSTlP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AU/cHJQAAAAlwSFlzAAAOxAAADsQBlSsOGwAAdTFJREFUeJyMfXlgVEW2969u7/ve6U7IHhISSIAkJCCyKMERcBkV4zIK7uKoY5w3Cbw3D2Jk3nskmRnjqCNuo6BvRiPjjBuogLIoS0gCJBCWpLNAkk5635fbfW99f4QlLPN9X/3V3VW3qn59TtVZ6tS5hAHqrfqeOZpj4qSfc6rzxutwvdIC6IZ1GT0pxnMvxFe2zWtd29gUsiS0g/UXW3z0EOoVilF1rH7SY+vl6jCpRQuAmg1prv/wiF+aJuxnAFj1h51lqPiWf7kJY/fm65F7av9coZ7AeXxzbtmPlqjWjht/Kh95+NH3OdUraYORxJw7D5UdpsuUjLzv10XeOjTqi2i0Kvf44bv7umYRBsDaxvU5UdmIWgi4UnT9YEjtdZDUbDKOJtRchcKYgwNdfm/2yBSiHSE1lxtg/dxzUmZwEpDmoJRE1LUNGgCJUDLyx7zXEh0gijBilhe3jEeFPimhDK2QlpjgPVaWRl3UTF3kwFfTY8F1qFcE0zI+2JLziY1Z3ZQ4s8UtebasWFhqOafztUpXN0XMJfGboVHSrkKbmgFaPmpsVXK+fqFzXDaSxvtUhoh5U1NT81VAapq0fIqylsSKxzIOBTOt1lOEC/S/aLzUwN9SD7vX0aOZ9BBfqSsmtYBAAFAR/miYL+ogBGHA+GLzOMkyTidiAaUMawJ8u59XwcSscN+KOXfGCwiaG0KC4tYPEHzXtRpBZQ4ETl7y5SzxmAUH0j3gK5+AELljg6eNmgQYQHCipWMtb1DkMEEnYxyjSKYkqbmOb2y68K9OMBaCcW4k0qTRKG/oopEugV8jJrEwbJcmrQEVxAyhxkk4mukpepgA9RyHmlDZ4+j9M0IKAMDIC6GxUWOwm1mYHsb53QBOZzwzQMYT858+m8MH234kzbWgCys2mR4Zf5hiw1w87RCM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";

// src/control/images/forvaltning_thumb.png
var forvaltning_thumb_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAMAAACahl6sAAADAFBMVEUAAAD////c8v/59/j//f/9+/37+fv18/Xt6+3p5+nX1dfV09XT0dPRz9HPzc/Ny83LycvJx8nHxcfFw8XDwcPBv8G/vb+9u725t7mfnp+cm5y1s7axr7Ld297Z19rk4+Xg3+G3trnr6u3b2t3X1tnDwsX9/f/7+/35+fv39/nV1dfT09XJycu/v8G9vb+7u72zs7Wjo6TKy87m5+nQ0dPd4eXMztDz9PXHyMnFxse1u8Df8f++xszd8f/X4+vBytDCxcfX7PnO4OvBz9je6fC7w8jHz9Ty+v/Y8P7d8//b8PzV6fXf8//S5vHK2+XG1t/h5unr7/G7vb7r7e7b3d7T1dbLzc7AwsPa9P/c8/3e9v+8v8D6/f7d9fvi+f/g+v/9///5+/vV19fR09PJy8vAxMC6vrr6/vr4/PiztrPFyMX9//3X2de9v72mp6bj8OG2vLWyuLH2/fXCyMGgpZ+wta/n7Obe7NvZ5ta4wbbO18zEzcLT39Dm8uPv+uzg6N7S2tDr7+rV2dTW49Lo9uTi797K0cju9ezk6+Lb6tbs+Ojq8+e8wrra4NjHzcXy+PDe5Ny1uLStsKzt8OzT1tLR1NDz/e/X39TY6dHe79fM2MfR3svCzb2/x7vN0cv1+fPI08K/wr3z9vHZ58vKzMjr/NXn99Lf78vj8dHg7s/s+dvj8s7n9dTx/9vm79jr8uD8//XY2dX+/vvQ0M3GxsP///3Dw8G+vbn8+/nc29nIx8XTzMH//Pfd1cnW0szKwrfn3tL++PDi39vw59z68+rz7OPc19HZ0Mbh2M7Oxr3r4tj47+XAurPUzsfIw764tLDKxsLPy8e0sa7MycbEwb/Bvrz8+ffp5uTV09LPzcz//f39/f37+/v5+fn39/f19fXz8/Px8fHu7u7q6urm5ubi4uLe3t7b29vZ2dnX19fV1dXT09PR0dHPz8/Nzc3Ly8vJycnHx8fFxcXDw8PBwcG/v7+9vb27u7u5ubm2traysrKvr6+rq6uhoaGUlJT///9XRU/aAAABAHRSTlP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AU/cHJQAAAAlwSFlzAAAOxAAADsQBlSsOGwAAbEpJREFUeJyNfXdgFGX6/+edndleUneTzfbNJiG0YKF4ds9DTz275jzPggoKiIICioAiRYkKioKCJ2A7sZ933t2Xs5xdQVFq2vaeZDe72WzfmZ35/RFaEL3f88/OvPvOzPuZ533fp77vkGHZ6R8XDQCASFOvHr9KdMMe4dTAWtWDvTqo3/h8aAtCjvzoKl9JZz2bvfD4EvdV/1cPYJZEqha7lly9keyoBuXbclyNVTbK/6T9OyQkxh6T+LaWsOrWxrs4iXXGvAmO8ZbesfkcKB5AWHLpfgKvTfKjGZJI8YrdLt2S1/dYH33wtf3rKY3qX4qaiTVhP2D3lH4dBzi/vSUwk71SxMIn+6p6CyDuHl3jA5H59eIoHJCjAQA2bxiiQsYXnbLe59spvmLeumOvh6bBMPvhaiZlCwn6ZrZxHcm56Wx5rm2i+luW8nTC1QPAx9j+DcAicpmBYt3EtyFb8tR+6zLZgz+tb6FRbADtb63FMH3Cuz0ZeXVDet1wYzCJcbEn3IDPmh1dQZO+6DHZqBJa82n1yNEWYKVZ1HrBUE0GW+N9i+oWjJR31GDo2se7TVJyXssHdGP3v//U88KSZ6uqhk9bLPK1KjW8BU08AJGN5nxWeGUPAoBbqnVX4qwUmHtf+w5+CgC4hpS/TxD9Xq6SS5y/CkRitUCpleTtlPQhsgUQ15xQQWbqVZ01Gjt9HNaMqBDrhROYsaijpm/2SCFHc6lmYoLCh86VTKh5aGjigLVJGkr+ePMdD8wV8qahIA8AlKjPZvbASi0G0Dsmi3WLn3yne5leCG+WMNThJzhMNUP/V2XoT9XLzK5fxEFN6CzNGux0cDCEZCWgl/l0dIWPUsv+Vh5dpOJMR4/n0/fW6nUVRgDAIpwGPPLILJSAMsXCv5zdWd4qrr9uOMV2+CBav+qClNwx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";

// src/control/images/orto_foraar_thumb.png
var orto_foraar_thumb_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAMAAACahl6sAAADAFBMVEUAAAD///+ZZGiFV2FvTVXk4eJ2aG6Ie4JsVmdbTVh+c36Ng42dk52VjJWtpK21rLXVzNXMxMyko6S8tL1aTmdEPFR0bIR0c3yEg4yUlJ2kpK20tL2cnJ68vL7DxM12fJRFTGVNVG1VXHRdZH1lbIRsc408RF49Q1RNVGRma3Y2S3ZGW4RcZHRGTFhsdISGi5UnO16nrLVRa5Q0Q1xkdI1VXGdEVGxUZHx2fIWMk53GzNUrS3U3S2dHW3ZXa4YbOV4bMUwoOlA0QlNnfJZcY2xsc3x8g4wsSGgkRWg5XoVBZ4w8VGxaepw8TFxsiKVEVGRMXGxUZHRcbHxkdISKoLZsfIxMVFzP2uXZ2904WXdKaIVYd5R5kKYsVnguOUKZqbaRnKWwvMZJdZg0VGwrRVlJZHhjhZ9adIc0TFw8VGREXGx4ipeKnqyftcWElJ8bPVJTbHx7nLBifIxrhZYhMjzr8PM0VGQ8XGxchJk8TFREVFxMXGRUZGxcbHRkdHxsfIR0hIxLdYksVmjb5ek0XWw6ZHSDm6SZpKgyTFRjfIQpQklEXWRTbXR7lJuptLe6xMc8XGQ4VFs3R0trhIo0XGRLZGlbdHlVW1zJ1dcsVFrBzM1MdHRTbGxjfHxEVFR0jIxUZGRcbGxkdHR0hIR8jIyElJSMnJxOVFRsdHRGS0t0fHx8hIReZGSirKyEjIyUnJyMlJSzvLxmampDXVxsfXxMXlybtLFMdGw7VExjfHRDXFODnJNTbGJbdGo8RkJzjIB8lIhsfnRMXVNcbGKMnJJHVEtXZFt8jIGirKR4hHpodmqzvLSJlIqbpJuUnZSrtKvDzMO7xLvL1Mt0fXOEjIJVXFLe49l0d2ukpZuMjILMzMOEhIHX19RnZl1+fXOWlYutrKLV1MuenJO2tKvGxLu+vLPp59/VzMiOhICWjIjqzcO1rKnMqJ+vo6DHjoKrkYyonJrFem+qfXl+c3LIu7q+tLPOxMN+fHyWlJTMzMzExMS0tLSsrKyMjIx0dHT///8CMPxvAAABAHRSTlP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AU/cHJQAAAAlwSFlzAAAOxAAADsQBlSsOGwAAjrdJREFUeJw0vGd4XNX1vr32OWd6731Goxlp1IslW25g3HsHk0ILHWxMhxAIHQKBQMAGEkjov4Tm3jA2NsWWu9W7RqOpmt77nPJ+yP/9tD/va13PWs+997M3+hzscxk4QNWXRRnv1fJgaw0ozuu+b65t4I/kR88DoNUtICIzGXydjyATI1MDNCO7V526/Zqar6G8DNtzAzQAv5pjc14D/xKFLNK8gB+sTOpJkDGIFGeEKMPm5Jkop8gK0UK2ZtYhdlQRzX5vJBY0TsP9DObaXf38EIR//nmUAelE1SIXQKEuVuceM5NDdJYmq6eqQTH3ugLv16+KpM/Wfq2g3b67/qfb4FBFWGqlaWm5LXxoA4k+VVXVH1xfZvcKRtf5bliOLtyrR7F/a6vjLU3xzL9TzEoey8qfzsPzgR7g5iA7NvnD89bmQ4ccAf+cc2iBK8A4n9Wz5CVe2cqaqoYReyQhLoTZZZqmMBYZK0CViOFGeWRhtMA3xSdbHrn8JgiStWlwxpvbO6Vsq+qxv54nc/iXvmEAKS4NmbyLjy1KXBxa3sMp3LY/q82Igp3R37WyoqO9mUBV67l1hKUBAOCYcWp9qMKrJNbDNDAqLCKLl1ZNfXqkbdk65uqOutqbGc/4edqSqGHlh6NrtwrdFcArPJnhnakpig/j0+C2M4Krbgt7tfb4POgOLJBk6QDEc7EqvSXj77P3IihFuUUe5q9Me7z9SrmLgThJJiDPyo2OWx+erIC3emlG2YjJ+dkIizEvPKtYr4VZU2kAQOAwuMzUanfgts1VdpP9XAUKLHw2vh5YJcE4itvsMBYLoWM2GAbzVBsOXC5WPznNkNbLWDKROHQUWq+fOn0ZygDwQXUjm5acw7A8tJi1ka0dUgC2BbvLWtRRQdSuydP+ycL4NJo6Ipmbpkg4pp7zr+8i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";

// src/control/images/natur_friluftskort.png
var natur_friluftskort_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAMAAACahl6sAAADAFBMVEUAAAD////S+rGz0v7X0dKrpqfTzc/17fHKxsikm6Kfmp6XkpbX0tbj3eLs5evn4ObDvMPb1dualprf2t/++v769fuSjJSvrbSdnaOamp+Skpelparl5evh4ef19fra2t/6+v7V1tuVlprR0ta70/23zfe20v6yx+i5xtvn7PS20vqyy++60fSy0v6y0fqtw+HI3vu21v65z+q9xtGu1P6y1v631vqvwdax1vq01PW82PTCz9zM1+Gw2v7J3OytucGOkZPY4uiWmpvu8vPa3t+Rlpb5/v71+vrR0tKZn56mrKvV29rR19bl6+rh5+bL1dOeo6LGzcu4wb2ttK/L8dPD78uVmpZrynrh5+J8xIW63b7C4cbL6s6SxpbC7sWRl5Gan5rN0831+/Xa39rS1tLMzcy0tbSen56Njo2mz6OKx4K0zLDFy8SlraPe4t3W2tWRvoSXrpDA1Lq1vLPN+7vm6+TS3s3Z6NL6/vigvpCrv6DO/bLS/rbU/LvO4MLi9Nbu9OqDhoHQ/q7N+q3S/rLS+rbU9LzS+rLW/rbc+sTR/qrS+q7W/rLW6cXR/abW+bbT7LvS+qrW/q7W+rLa/rbc/busravW/qrW+q7a/rLa+rbT8LPW+qrQ8qbL66HU9Kva+rLf/rbO56/C4Zja+67e/rLa9bPJ4qbb8rvm/Mjf+bfb9a3f+bLb+KO604vU7KXE1aTM45uPk4fo/Lfn7NzF15Hb7Ka8xKP2+ezX3b3i493O0rPr7OW+xoTS1MSsraXDxLz9/vOlppf4+N/c3M3b29LMzMS8vLW0tK2fn5mbm5WWlpHm5uHe3tnb29b+/vrW1tK/v736+vns7OukpKOSkpG3tXXU0824tKLx7d2rqaC3rpPn49fz8evHwbK9uK2bkYPk2czUyLrb0cbb1Mzk3dXMxb6zrqnItaPSwbHTzMbgzb7r5eKalpTb1tTm4d/++vmgmpn79fTf2tr+/v709PTm5ubi4uLe3t7a2trW1tbExMS6urqampqWlpb///+maPEqAAABAHRSTlP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AU/cHJQAAAAlwSFlzAAAOxAAADsQBlSsOGwAAfmBJREFUeJx0fXd8FGX+//uZmZ3ZMlvSE9J7slEQlFPvzn7qqQjYKxZsJAFiJcYoRjDGgC1AAjYsnIoNBPGsX9vZUZCSTUIKIYX0bJvdKTszz++PAHqnv88/MPvKzD7v/Xw+z6c/Q17y6IqDjFQ8QIvs4YE61KMWK5bjCDVVAcCK5TUNANAIZ0J4QhWv4PSMXdHCTYoYi4sju+qP/jVW2lSbI3EcI8uBRqAa9RAVtQytcrKhj8Yjb7BtKTFLDabSYBc/9EbO5wUlbdy0rpvsZvyq+Z+f25DSf5EiXWG5L4XG7FG+SzhpwIHEf/QeiHWcEqQgFRtlC5wIw2y768PyljbBRRTHAfPf0UvfaySPcjSVOu2q//CJ6vBY3YrlNbapVQAAqusB1GLF8kZnP0QOOfzkxPDwmvAjL2X+sMGtiMRBmHDVURyN0GnStJjPePjIB/WobSEWCIcDDY3VK0HdxtCq83Na9hWR9EsMR7/5iXNiDv2KucgAO7R/fE+iMnpt8ebeEjqnMQ6H7QojRv6+e26Oq248MXGGPXBV3BPuT4tSSbjtedu/Ip8FS2huL6selD+ZFJkIs/yB2olox64ATswpnhb3GNeU6kZNjVxdXV1dXR2oAVALLIcTgLVa5QwTcXcH2ZcQaP+bjqCeSMJVxzhihWGHHkoix1iEmpjmsUhOAE3MQ3YOpyV8s46eBwzaF7NMol2NJqdgthsM2UXhYDlR/rX927yl/IV93UWn0Iwm+eaZatu7cslJo28Uj1WcIy1YdxtB0sMN13a68o4z0KEoh/BFLHwQLYQB8IiCVKcjHkqU56LDQauYMCxBAkRM4UATLLFhO8MhhxuIWG9QfOcmBD7ZS6OJFk9wglYfW3Zj9VPZ8qgceew3jjRZUgLjqK6vbZStnD1Sll5kMsQEEOOWGM6b0AI6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";

// src/control/images/kommunikation.png
var kommunikation_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAMAAACahl6sAAADAFBMVEUAAAD////c8v/Nzc3I8KD85uesm5z98fKyoKKdk5S7p6q2oqarlZykjZXj19utnKKzpaqynqaYh49QTk+klJ22rrTMxczr5Ov++v6clZ3Y0tnOys/SzdV8e3339PtlZGf6+P6PjZTR0dmEhIbf3+G8vL2mpqecnJ1qbIJ3eZGQkqmFhpWkpriChqO1uNCsr8Ocnq7IydCTlZ2Snb3Cyd2tr7Xg5O21t7vFx8vW2Nzm6/SbrMfK1unv9PzW3urY4u+mweHc5/OwzuxpuO6JyfXO0dPm6evD5/3Z8P3e8v6q3/vn9/71+vzf9v7a9v76/v7S1tbKzs7x8vLQ3dLN+86a4ZuV2JWj5qOh2aG05LTK8sre997s+uz0/PT6/vqNtIzH8sWcvprG58TX7NXJ0cjj7+HH28LB0bnP2cq0v63G8qLK9qHO+qWy0pOQon+HlnmxwqHV4snF8ZnQ/qK85ZLS/qax1Y3K8qLO9abD6J3I7qK94Zm32JbT9q/L7Kirx46wzZOkvYrF4qiasITY9bvQ67S/1ajM37l/inTS+qLW/qbO9qLS+qbW/qrV6b+NlITb/qvKy8OpqZ3k5Nfb29X+/vj+9gL79kb9+H/9/O7q1AXOvBS3qCOqoDqUizmgmVbk24l2ck6enZO9vLT59dyysKPPzsn+9cx1dHDX1tKoo5H867z95anDuqPd1sXy2qXu1qLcxpbu16bn0qPz4LXm1rPm2r7az7aclYbt48zt6eD43aTozpvRuo6KfmWgk3rYx6aOhXPy1Jy+pnvJsYarmXmyooXCsZPNxba8qYmzp5Tpx5PfvIyomYeaiHTt0L+um5KmiX3r08m0rqy1kIm2p6WrpKO7tLOVjIuwp6aGeXi+rKvayciahIOjjo20nJyslZW7pKS2oqKkk5OcjIyPgICUhobv29vi0NClnJzNxMTBubnX0NDEvr7OysqjoqL+/v76+vr29vbs7Ozk5OTc3NzW1tbS0tLOzs7KysrExMS0tLSsrKyUlJSMjIz////e5Z6pAAABAHRSTlP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AU/cHJQAAAAlwSFlzAAAOxAAADsQBlSsOGwAAboBJREFUeJyFfXd8FVX6/nPOtNtLctNoCSk3hJBQxC4iWBFRWSvqCrYlrq5uvOtXY8G+sew1q65r2F0VK/aGLiv2hqJ0SEJuEggtpN86t0w55/dHQgmgv/PJH8lk5sw8877vOW8fcssoPZl4rpYCqscRjzbit8btzNH/7C2+m095tmd+0ban+56u8VninrpDT6l1DDB78JADgeAdjwEIiFLkmMsmtjKTV2HSisSU9ogBV0yeuoXbkTSU6AlL7I9/OcBNMdt+XD+0VWMY99LMhK+4afv9ZxEAntLNyajoR6g0pVNuiQCexJTtiStfPsZ40mZQFk8L9OGM6FNLla6o/TdxgKnMU0s76Tcb+fL891KAVdC1ETgCDUq29VAc8N0n1gAIGnba+uC8ignSrK1NbwCr+2XpWHYuWXOZHbCBnEgfUAfTAInY8en2bXK+XZS75YkrTE5ofoQQwqNwFEz0twChUrOyEoTwiMb0qtWysVrPFIv2KOy2VE46LYThyqj1/SOe4rDhE5W9svX+affhts6n1wsSaJrREWeoN+6z5R56oCbi7AUABIHFtqT324qmzvG6ap/XRH9qMVbNfOF1J5Co+uVB1N3f0mGlQAY8yteScxyvRDa4EhInrldWhTi8KtQugfhDZnkPyfqMc3jTpbJ5UncVROdJs8UggMU25EZ9UtEPLkfEFwB+FUuvY9+4ffYSG2c5Rdbswb/XWsSekUQsHBT0ESSyxhP8wClZr0akzXGzYrMdKxJcQBqRUgIkbRH0m3JzZiprE6UeyrXMOOMt4sD8y6pLQ0akX3LnAZO3hmxMCAECI4OMgKDS0pJ+xlpx69rGe1aLALAUQM34nV02Mliw2w5WmzviWQ6OlOJkdK1iXH5pLKe27emAb49vJB8FBm1J38hLiMs9PNsto6XdFzHZXrwF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";

// src/control/LayerSwitcher.js
var LayerSwitcher = class _LayerSwitcher extends Control_default {
  constructor(opt) {
    const options = opt || {};
    super({
      element: document.createElement("div"),
      target: options.target
    });
    this.visible = typeof options.visible === "undefined" ? true : options.visible;
    const cssClassName = options.className !== void 0 ? options.className : "ol-layer-switcher ol-unselectable ol-control";
    const label = options.label !== void 0 ? options.label : "Skift kort";
    this.labelNode_ = typeof label === "string" ? document.createTextNode(label) : label;
    this.button_ = document.createElement("button");
    const tipLabel = options.tipLabel ? options.tipLabel : "Skift kort";
    this.button_.setAttribute("type", "button");
    this.button_.id = "layer-switcher-button";
    this.button_.title = tipLabel;
    this.button_.appendChild(this.labelNode_);
    const _this = this;
    this.button_.onclick = function(e) {
      e.preventDefault();
      _this.toggleShow();
    };
    this.panel1_ = document.createElement("div");
    this.panel1_.className = "container1";
    this.panel2_ = document.createElement("div");
    this.panel2_.className = "container2";
    this.panel1_.appendChild(this.panel2_);
    const element = this.element;
    element.className = cssClassName;
    if (this.visible) {
      element.appendChild(this.button_);
      element.appendChild(this.panel1_);
    }
  }
  setMap(map) {
    super.setMap(map);
    if (map) {
      this.renderBackgrounds();
    }
  }
  renderBackgrounds() {
    let baseLayers = null;
    if (!this.getMap()) {
      return;
    }
    const lyrs = this.getMap().getLayers().getArray();
    for (let i = 0, l; i < lyrs.length; i++) {
      l = lyrs[i];
      if (l.get("title") === "Base maps") {
        baseLayers = l;
      }
    }
    const this_ = this;
    while (this.panel2_.firstChild) {
      this.panel2_.removeChild(this.panel2_.firstChild);
    }
    baseLayers.getLayers().forEach(function(e) {
      const div = document.createElement("div");
      const image = document.createElement("img");
      const label = document.createElement("label");
      div.className = "wrapper";
      image.className = "image";
      label.className = e.get("color");
      image.appendChild(label);
      div.appendChild(image);
      div.appendChild(label);
      this_.panel2_.appendChild(div);
      if (e.get("visible")) {
        image.classList.add("selected");
      }
      e.image = image;
      label.innerHTML = e.get("title");
      const name = e.get("name");
      let img = dtk_skaermkort_thumb_default;
      if (name === "dtk_skaermkort_daempet") {
        img = dtk_skaermkort_daempet_thumb_default;
      } else if (name === "forvaltning") {
        img = forvaltning_thumb_default;
      } else if (name === "orto_foraar") {
        img = orto_foraar_thumb_default;
      } else if (name === "natur_friluftskort") {
        img = natur_friluftskort_default;
      } else if (name === "kommunikation") {
        img = kommunikation_default;
      }
      image.src = img;
      image.onclick = function(f) {
        f = f || window.event;
        this_.toggleBackground(e.get("name"));
        f.preventDefault();
      };
      label.onclick = image.onclick;
    });
  }
  toggleBackground(background) {
    let baseLayers = null;
    const lyrs = this.getMap().getLayers().getArray();
    for (let i = 0, l; i < lyrs.length; i++) {
      l = lyrs[i];
      if (l.get("title") === "Base maps") {
        baseLayers = l;
      }
    }
    baseLayers.get("layers").getArray().forEach(function(lyr, idx, a) {
      lyr.setVisible(lyr.get("name") === background);
      if (lyr.image.classList.contains("selected")) {
        lyr.image.classList.remove("selected");
      }
      if (lyr.get("name") === background) {
        lyr.image.classList.add("selected");
      }
    });
  }
  setVisible(lyr, visible) {
    const map = this.getMap();
    lyr.setVisible(visible);
    if (visible && lyr.get("type") === "base") {
      _LayerSwitcher.forEachRecursive(map, function(l, idx, a) {
        if (l !== lyr && l.get("type") === "base") {
          l.setVisible(false);
        }
      });
    }
  }
  forEachRecursive(lyr, fn) {
    lyr.getLayers().forEach(function(lyr2, idx, a) {
      fn(lyr2, idx, a);
      if (lyr2.getLayers) {
        this.forEachRecursive(lyr2, fn);
      }
    });
  }
  toggleShow(e) {
    if (this.panel1_.classList.contains("expanded")) {
      this.panel1_.classList.remove("expanded");
      this.button_.classList.remove("expanded");
    } else {
      this.panel1_.classList.add("expanded");
      this.button_.classList.add("expanded");
    }
  }
};

// node_modules/ol/source/Cluster.js
var Cluster = class extends Vector_default {
  /**
   * @param {Options<FeatureType>} [options] Cluster options.
   */
  constructor(options) {
    options = options || {};
    super({
      attributions: options.attributions,
      wrapX: options.wrapX
    });
    this.resolution = void 0;
    this.distance = options.distance !== void 0 ? options.distance : 20;
    this.minDistance = options.minDistance || 0;
    this.interpolationRatio = 0;
    this.features = [];
    this.geometryFunction = options.geometryFunction || function(feature) {
      const geometry = (
        /** @type {Point} */
        feature.getGeometry()
      );
      assert(
        !geometry || geometry.getType() === "Point",
        "The default `geometryFunction` can only handle `Point` or null geometries"
      );
      return geometry;
    };
    this.createCustomCluster_ = options.createCluster;
    this.source = null;
    this.boundRefresh_ = this.refresh.bind(this);
    this.updateDistance(this.distance, this.minDistance);
    this.setSource(options.source || null);
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/VectorEventType~VectorEventType#removefeature} events.
   * @api
   * @override
   */
  clear(fast) {
    this.features.length = 0;
    super.clear(fast);
  }
  /**
   * Get the distance in pixels between clusters.
   * @return {number} Distance.
   * @api
   */
  getDistance() {
    return this.distance;
  }
  /**
   * Get a reference to the wrapped source.
   * @return {VectorSource<FeatureType>|null} Source.
   * @api
   */
  getSource() {
    return this.source;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @override
   */
  loadFeatures(extent, resolution, projection) {
    this.source?.loadFeatures(extent, resolution, projection);
    if (resolution !== this.resolution) {
      this.resolution = resolution;
      this.refresh();
    }
  }
  /**
   * Set the distance within which features will be clusterd together.
   * @param {number} distance The distance in pixels.
   * @api
   */
  setDistance(distance) {
    this.updateDistance(distance, this.minDistance);
  }
  /**
   * Set the minimum distance between clusters. Will be capped at the
   * configured distance.
   * @param {number} minDistance The minimum distance in pixels.
   * @api
   */
  setMinDistance(minDistance) {
    this.updateDistance(this.distance, minDistance);
  }
  /**
   * The configured minimum distance between clusters.
   * @return {number} The minimum distance in pixels.
   * @api
   */
  getMinDistance() {
    return this.minDistance;
  }
  /**
   * Replace the wrapped source.
   * @param {VectorSource<FeatureType>|null} source The new source for this instance.
   * @api
   */
  setSource(source) {
    if (this.source) {
      this.source.removeEventListener(EventType_default.CHANGE, this.boundRefresh_);
    }
    this.source = source;
    if (source) {
      source.addEventListener(EventType_default.CHANGE, this.boundRefresh_);
    }
    this.refresh();
  }
  /**
   * Handle the source changing.
   * @override
   */
  refresh() {
    this.clear();
    this.cluster();
    this.addFeatures(this.features);
  }
  /**
   * Update the distances and refresh the source if necessary.
   * @param {number} distance The new distance.
   * @param {number} minDistance The new minimum distance.
   */
  updateDistance(distance, minDistance) {
    const ratio = distance === 0 ? 0 : Math.min(minDistance, distance) / distance;
    const changed = distance !== this.distance || this.interpolationRatio !== ratio;
    this.distance = distance;
    this.minDistance = minDistance;
    this.interpolationRatio = ratio;
    if (changed) {
      this.refresh();
    }
  }
  /**
   * @protected
   */
  cluster() {
    if (this.resolution === void 0 || !this.source) {
      return;
    }
    const extent = createEmpty();
    const mapDistance = this.distance * this.resolution;
    const features = this.source.getFeatures();
    const clustered = {};
    for (let i = 0, ii = features.length; i < ii; i++) {
      const feature = features[i];
      if (!(getUid(feature) in clustered)) {
        const geometry = this.geometryFunction(feature);
        if (geometry) {
          const coordinates2 = geometry.getCoordinates();
          createOrUpdateFromCoordinate(coordinates2, extent);
          buffer(extent, mapDistance, extent);
          const neighbors = this.source.getFeaturesInExtent(extent).filter(function(neighbor) {
            const uid = getUid(neighbor);
            if (uid in clustered) {
              return false;
            }
            clustered[uid] = true;
            return true;
          });
          this.features.push(this.createCluster(neighbors, extent));
        }
      }
    }
  }
  /**
   * @param {Array<FeatureType>} features Features
   * @param {import("../extent.js").Extent} extent The searched extent for these features.
   * @return {Feature} The cluster feature.
   * @protected
   */
  createCluster(features, extent) {
    const centroid2 = [0, 0];
    for (let i = features.length - 1; i >= 0; --i) {
      const geometry2 = this.geometryFunction(features[i]);
      if (geometry2) {
        add(centroid2, geometry2.getCoordinates());
      } else {
        features.splice(i, 1);
      }
    }
    scale(centroid2, 1 / features.length);
    const searchCenter = getCenter(extent);
    const ratio = this.interpolationRatio;
    const geometry = new Point_default([
      centroid2[0] * (1 - ratio) + searchCenter[0] * ratio,
      centroid2[1] * (1 - ratio) + searchCenter[1] * ratio
    ]);
    if (this.createCustomCluster_) {
      return this.createCustomCluster_(geometry, features);
    }
    return new Feature_default({
      geometry,
      features
    });
  }
};
var Cluster_default = Cluster;

// src/control/images/pin.png
var pin_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAjCAMAAACjKNoqAAAACXBIWXMAAAAcAAAAHAAPAbmPAAAA0lBMVEUAAADmSzHqQzXePzEAAAAAAADqRzzePzEAAADePzHqQzXePzHePzHqQzXePzHmQzUAAADePzHqRzzaQy3ePzXqQznqPz/qRzwAAADqRznqQznvRznaPzHqQzXqQzXqQzXePzHeQzHqRzzePzHaQzHePzHWPDHaPzHqSzzePzXePzHmQzXKOS3ePzHqQzXqQzXaPzXePzHmQzW+OSnePzXePzHmQzXqQzXqSzzqSz/qTz/GKSGyHRnqT0OXCQnaOS3SNSnqU0O+JR3GLSXOMSW2IRnQDRqUAAAANnRSTlMACdaUGAmXsgg1ZMbqgO/vEM7WHVNDDuISR0tHT0NLvlMd3r4lLbDGoIBcxpew3nA5P758bGAX/DEaAAABEElEQVR42u39B3bEIAxEAQgb8PYt6enp6ekCvH3L/a8UEO4+w+Aivmf8nsQFgMRO5Ejr68fjfci0N5oup3FsHwfnCWJdszSKZKZGMoJdE6tMsZGOnekCs2bdsuGgxKz3ncGR0lTP1+M5FVp9gPTfxzOrla8vIPC+GWlBmwCQ3msPJ7TBBI7LcFiMb5J46H++cmzr6wiaPq8Wk4n3KbwEuFEVDW2bqTUV7rrmwxLFiKa00ynCzpUf6GnBik/p5N8yiu3sOG57Kezd5Yf0m1gxzBkw36wKWAHCJ1nxD0qKHGyXGfWFzxXoRhhUGbSUCmuwifhVg41+v1GH3y812BjcPxxWqeA/r1zUnJwP6nkhMvYPs65RdNkbMm4AAAAASUVORK5CYII=";

// src/control/markers/CreateMarkers.js
function createStyleFunction2(icon) {
  const styleCache = {};
  return (feature) => {
    const size = feature.get("features")?.length;
    if (size === 1) {
      return new Style_default({
        image: new Icon_default({
          anchor: [0.5, 1],
          anchorXUnits: "fraction",
          anchorYUnits: "fraction",
          src: icon
        })
      });
    }
    let style = styleCache[size];
    if (!style) {
      style = new Style_default({
        image: new Circle_default({
          radius: 10,
          stroke: new Stroke_default({
            color: "#fff"
          }),
          fill: new Fill_default({
            color: "#C84A38"
          })
        }),
        text: new Text_default({
          text: size.toString(),
          fill: new Fill_default({
            color: "#fff"
          })
        })
      });
      styleCache[size] = style;
    }
    return style;
  };
}
async function createFeature(marker) {
  const dawsUrl = "https://dawa.aws.dk/adresser?format=json&struktur=mini&q=";
  const feature = new Feature_default();
  for (let key in marker) {
    feature.set(key, marker[key]);
  }
  if (marker.lon && marker.lat) {
    feature.set("geometry", new Point_default(fromLonLat2([marker.lon, marker.lat], "EPSG:25832")));
  } else if (marker.address) {
    const response = await fetch(`${dawsUrl}${marker.address}`);
    const data = await response.json();
    feature.set("geometry", new Point_default(fromLonLat2([data[0].x, data[0].y], "EPSG:25832")));
  }
  return feature;
}
async function createFeatures(markers, icons) {
  let featureGroups = { default: [] };
  Object.keys(icons).forEach((i) => {
    featureGroups[i] = [];
  });
  for (const marker of markers) {
    const newFeature = await createFeature(marker);
    if (featureGroups[marker.type]) {
      featureGroups[marker.type].push(newFeature);
    } else {
      featureGroups.default.push(newFeature);
    }
  }
  return featureGroups;
}
function createLayer(features, iconUrl) {
  const styleFunction = createStyleFunction2(iconUrl);
  const vectorSource = new Vector_default({
    features
  });
  const clusterSource = new Cluster_default({
    source: vectorSource
  });
  const vectorLayer = new Vector_default2({
    source: clusterSource,
    style: styleFunction
  });
  return vectorLayer;
}
async function CreateMarkers_default(markerArray, icons) {
  const featuresByType = await createFeatures(markerArray, icons);
  let layers = [];
  for (const [key, value] of Object.entries(featuresByType)) {
    const iconUrl = icons[key] ? icons[key] : pin_default;
    layers.push(createLayer(value, iconUrl));
  }
  return layers;
}

// node_modules/ol/Tile.js
var Tile = class extends Target_default {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  constructor(tileCoord, state, options) {
    super();
    options = options ? options : {};
    this.tileCoord = tileCoord;
    this.state = state;
    this.key = "";
    this.transition_ = options.transition === void 0 ? 250 : options.transition;
    this.transitionStarts_ = {};
    this.interpolate = !!options.interpolate;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(EventType_default.CHANGE);
  }
  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */
  release() {
    this.setState(TileState_default.EMPTY);
  }
  /**
   * @return {string} Key.
   */
  getKey() {
    return this.key + "/" + this.tileCoord;
  }
  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  getTileCoord() {
    return this.tileCoord;
  }
  /**
   * @return {import("./TileState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */
  setState(state) {
    if (this.state === TileState_default.EMPTY) {
      return;
    }
    if (this.state !== TileState_default.ERROR && this.state > state) {
      throw new Error("Tile load sequence violation");
    }
    this.state = state;
    this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  load() {
    abstract();
  }
  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  getAlpha(id, time) {
    if (!this.transition_) {
      return 1;
    }
    let start = this.transitionStarts_[id];
    if (!start) {
      start = time;
      this.transitionStarts_[id] = start;
    } else if (start === -1) {
      return 1;
    }
    const delta = time - start + 1e3 / 60;
    if (delta >= this.transition_) {
      return 1;
    }
    return easeIn(delta / this.transition_);
  }
  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  inTransition(id) {
    if (!this.transition_) {
      return false;
    }
    return this.transitionStarts_[id] !== -1;
  }
  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  endTransition(id) {
    if (this.transition_) {
      this.transitionStarts_[id] = -1;
    }
  }
  /**
   * @override
   */
  disposeInternal() {
    this.release();
    super.disposeInternal();
  }
};
var Tile_default = Tile;

// node_modules/ol/DataTile.js
function asImageLike(data) {
  return data instanceof Image || data instanceof HTMLCanvasElement || data instanceof HTMLVideoElement || data instanceof ImageBitmap ? data : null;
}
var disposedError = new Error("disposed");
var defaultSize = [256, 256];
var DataTile = class extends Tile_default {
  /**
   * @param {Options} options Tile options.
   */
  constructor(options) {
    const state = TileState_default.IDLE;
    super(options.tileCoord, state, {
      transition: options.transition,
      interpolate: options.interpolate
    });
    this.loader_ = options.loader;
    this.data_ = null;
    this.error_ = null;
    this.size_ = options.size || null;
    this.controller_ = options.controller || null;
  }
  /**
   * Get the tile size.
   * @return {import('./size.js').Size} Tile size.
   */
  getSize() {
    if (this.size_) {
      return this.size_;
    }
    const imageData = asImageLike(this.data_);
    if (imageData) {
      return [imageData.width, imageData.height];
    }
    return defaultSize;
  }
  /**
   * Get the data for the tile.
   * @return {Data} Tile data.
   * @api
   */
  getData() {
    return this.data_;
  }
  /**
   * Get any loading error.
   * @return {Error} Loading error.
   * @api
   */
  getError() {
    return this.error_;
  }
  /**
   * Load the tile data.
   * @api
   * @override
   */
  load() {
    if (this.state !== TileState_default.IDLE && this.state !== TileState_default.ERROR) {
      return;
    }
    this.state = TileState_default.LOADING;
    this.changed();
    const self2 = this;
    this.loader_().then(function(data) {
      self2.data_ = data;
      self2.state = TileState_default.LOADED;
      self2.changed();
    }).catch(function(error) {
      self2.error_ = error;
      self2.state = TileState_default.ERROR;
      self2.changed();
    });
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    if (this.controller_) {
      this.controller_.abort(disposedError);
      this.controller_ = null;
    }
    super.disposeInternal();
  }
};
var DataTile_default = DataTile;

// node_modules/ol/ImageTile.js
var ImageTile = class extends Tile_default {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {
    super(tileCoord, state, options);
    this.crossOrigin_ = crossOrigin;
    this.src_ = src;
    this.key = src;
    this.image_ = new Image();
    if (crossOrigin !== null) {
      this.image_.crossOrigin = crossOrigin;
    }
    this.unlisten_ = null;
    this.tileLoadFunction_ = tileLoadFunction;
  }
  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|HTMLImageElement} element Element.
   */
  setImage(element) {
    this.image_ = element;
    this.state = TileState_default.LOADED;
    this.unlistenImage_();
    this.changed();
  }
  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = TileState_default.ERROR;
    this.unlistenImage_();
    this.image_ = getBlankImage();
    this.changed();
  }
  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    const image = (
      /** @type {HTMLImageElement} */
      this.image_
    );
    if (image.naturalWidth && image.naturalHeight) {
      this.state = TileState_default.LOADED;
    } else {
      this.state = TileState_default.EMPTY;
    }
    this.unlistenImage_();
    this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   * @api
   * @override
   */
  load() {
    if (this.state == TileState_default.ERROR) {
      this.state = TileState_default.IDLE;
      this.image_ = new Image();
      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }
    if (this.state == TileState_default.IDLE) {
      this.state = TileState_default.LOADING;
      this.changed();
      this.tileLoadFunction_(this, this.src_);
      this.unlisten_ = listenImage(
        this.image_,
        this.handleImageLoad_.bind(this),
        this.handleImageError_.bind(this)
      );
    }
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  }
  /**
   * @override
   */
  disposeInternal() {
    this.unlistenImage_();
    this.image_ = null;
    super.disposeInternal();
  }
};
function getBlankImage() {
  const ctx = createCanvasContext2D(1, 1);
  ctx.fillStyle = "rgba(0,0,0,0)";
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}
var ImageTile_default = ImageTile;

// node_modules/ol/reproj.js
var brokenDiagonalRendering_;
var canvasPool2 = [];
function drawTestTriangle(ctx, u1, v1, u2, v2) {
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(u1, v1);
  ctx.lineTo(u2, v2);
  ctx.closePath();
  ctx.save();
  ctx.clip();
  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
  ctx.restore();
}
function verifyBrokenDiagonalRendering(data, offset) {
  return Math.abs(data[offset * 4] - 210) > 2 || Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2;
}
function isBrokenDiagonalRendering() {
  if (brokenDiagonalRendering_ === void 0) {
    const ctx = createCanvasContext2D(6, 6, canvasPool2);
    ctx.globalCompositeOperation = "lighter";
    ctx.fillStyle = "rgba(210, 0, 0, 0.75)";
    drawTestTriangle(ctx, 4, 5, 4, 0);
    drawTestTriangle(ctx, 4, 5, 0, 5);
    const data = ctx.getImageData(0, 0, 3, 3).data;
    brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data, 0) || verifyBrokenDiagonalRendering(data, 4) || verifyBrokenDiagonalRendering(data, 8);
    releaseCanvas(ctx);
    canvasPool2.push(ctx.canvas);
  }
  return brokenDiagonalRendering_;
}
function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
  const sourceCenter = transform(targetCenter, targetProj, sourceProj);
  let sourceResolution = getPointResolution(
    targetProj,
    targetResolution,
    targetCenter
  );
  const targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== void 0) {
    sourceResolution *= targetMetersPerUnit;
  }
  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== void 0) {
    sourceResolution /= sourceMetersPerUnit;
  }
  const sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {
    const compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }
  return sourceResolution;
}
function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
  const targetCenter = getCenter(targetExtent);
  let sourceResolution = calculateSourceResolution(
    sourceProj,
    targetProj,
    targetCenter,
    targetResolution
  );
  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    forEachCorner(targetExtent, function(corner) {
      sourceResolution = calculateSourceResolution(
        sourceProj,
        targetProj,
        corner,
        targetResolution
      );
      return isFinite(sourceResolution) && sourceResolution > 0;
    });
  }
  return sourceResolution;
}
function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, renderEdges, interpolate, drawSingle, clipExtent) {
  const context = createCanvasContext2D(
    Math.round(pixelRatio * width),
    Math.round(pixelRatio * height),
    canvasPool2
  );
  if (!interpolate) {
    context.imageSmoothingEnabled = false;
  }
  if (sources.length === 0) {
    return context.canvas;
  }
  context.scale(pixelRatio, pixelRatio);
  function pixelRound(value) {
    return Math.round(value * pixelRatio) / pixelRatio;
  }
  context.globalCompositeOperation = "lighter";
  const sourceDataExtent = createEmpty();
  sources.forEach(function(src, i, arr) {
    extend2(sourceDataExtent, src.extent);
  });
  let stitchContext;
  const stitchScale = pixelRatio / sourceResolution;
  const inverseScale = (interpolate ? 1 : 1 + Math.pow(2, -24)) / stitchScale;
  if (!drawSingle || sources.length !== 1 || gutter !== 0) {
    stitchContext = createCanvasContext2D(
      Math.round(getWidth(sourceDataExtent) * stitchScale),
      Math.round(getHeight(sourceDataExtent) * stitchScale),
      canvasPool2
    );
    if (!interpolate) {
      stitchContext.imageSmoothingEnabled = false;
    }
    if (sourceExtent && clipExtent) {
      const xPos = (sourceExtent[0] - sourceDataExtent[0]) * stitchScale;
      const yPos = -(sourceExtent[3] - sourceDataExtent[3]) * stitchScale;
      const width2 = getWidth(sourceExtent) * stitchScale;
      const height2 = getHeight(sourceExtent) * stitchScale;
      stitchContext.rect(xPos, yPos, width2, height2);
      stitchContext.clip();
    }
    sources.forEach(function(src, i, arr) {
      if (src.image.width > 0 && src.image.height > 0) {
        if (src.clipExtent) {
          stitchContext.save();
          const xPos2 = (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale;
          const yPos2 = -(src.clipExtent[3] - sourceDataExtent[3]) * stitchScale;
          const width2 = getWidth(src.clipExtent) * stitchScale;
          const height2 = getHeight(src.clipExtent) * stitchScale;
          stitchContext.rect(
            interpolate ? xPos2 : Math.round(xPos2),
            interpolate ? yPos2 : Math.round(yPos2),
            interpolate ? width2 : Math.round(xPos2 + width2) - Math.round(xPos2),
            interpolate ? height2 : Math.round(yPos2 + height2) - Math.round(yPos2)
          );
          stitchContext.clip();
        }
        const xPos = (src.extent[0] - sourceDataExtent[0]) * stitchScale;
        const yPos = -(src.extent[3] - sourceDataExtent[3]) * stitchScale;
        const srcWidth = getWidth(src.extent) * stitchScale;
        const srcHeight = getHeight(src.extent) * stitchScale;
        stitchContext.drawImage(
          src.image,
          gutter,
          gutter,
          src.image.width - 2 * gutter,
          src.image.height - 2 * gutter,
          interpolate ? xPos : Math.round(xPos),
          interpolate ? yPos : Math.round(yPos),
          interpolate ? srcWidth : Math.round(xPos + srcWidth) - Math.round(xPos),
          interpolate ? srcHeight : Math.round(yPos + srcHeight) - Math.round(yPos)
        );
        if (src.clipExtent) {
          stitchContext.restore();
        }
      }
    });
  }
  const targetTopLeft = getTopLeft(targetExtent);
  triangulation.getTriangles().forEach(function(triangle, i, arr) {
    const source = triangle.source;
    const target = triangle.target;
    let x0 = source[0][0], y0 = source[0][1];
    let x1 = source[1][0], y1 = source[1][1];
    let x2 = source[2][0], y2 = source[2][1];
    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
    const v0 = pixelRound(
      -(target[0][1] - targetTopLeft[1]) / targetResolution
    );
    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
    const v1 = pixelRound(
      -(target[1][1] - targetTopLeft[1]) / targetResolution
    );
    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
    const v2 = pixelRound(
      -(target[2][1] - targetTopLeft[1]) / targetResolution
    );
    const sourceNumericalShiftX = x0;
    const sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;
    const augmentedMatrix = [
      [x1, y1, 0, 0, u1 - u0],
      [x2, y2, 0, 0, u2 - u0],
      [0, 0, x1, y1, v1 - v0],
      [0, 0, x2, y2, v2 - v0]
    ];
    const affineCoefs = solveLinearSystem(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }
    context.save();
    context.beginPath();
    if (isBrokenDiagonalRendering() || !interpolate) {
      context.moveTo(u1, v1);
      const steps = 4;
      const ud = u0 - u1;
      const vd = v0 - v1;
      for (let step = 0; step < steps; step++) {
        context.lineTo(
          u1 + pixelRound((step + 1) * ud / steps),
          v1 + pixelRound(step * vd / (steps - 1))
        );
        if (step != steps - 1) {
          context.lineTo(
            u1 + pixelRound((step + 1) * ud / steps),
            v1 + pixelRound((step + 1) * vd / (steps - 1))
          );
        }
      }
      context.lineTo(u2, v2);
    } else {
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
    }
    context.clip();
    context.transform(
      affineCoefs[0],
      affineCoefs[2],
      affineCoefs[1],
      affineCoefs[3],
      u0,
      v0
    );
    context.translate(
      sourceDataExtent[0] - sourceNumericalShiftX,
      sourceDataExtent[3] - sourceNumericalShiftY
    );
    let image;
    if (stitchContext) {
      image = stitchContext.canvas;
      context.scale(inverseScale, -inverseScale);
    } else {
      const source2 = sources[0];
      const extent = source2.extent;
      image = source2.image;
      context.scale(
        getWidth(extent) / image.width,
        -getHeight(extent) / image.height
      );
    }
    context.drawImage(image, 0, 0);
    context.restore();
  });
  if (stitchContext) {
    releaseCanvas(stitchContext);
    canvasPool2.push(stitchContext.canvas);
  }
  if (renderEdges) {
    context.save();
    context.globalCompositeOperation = "source-over";
    context.strokeStyle = "black";
    context.lineWidth = 1;
    triangulation.getTriangles().forEach(function(triangle, i, arr) {
      const target = triangle.target;
      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });
    context.restore();
  }
  return context.canvas;
}

// node_modules/ol/reproj/Triangulation.js
var MAX_SUBDIVISION = 10;
var MAX_TRIANGLE_WIDTH = 0.25;
var Triangulation = class {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   * @param {import("../transform.js").Transform} [sourceMatrix] Source transform matrix.
   */
  constructor(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, destinationResolution, sourceMatrix) {
    this.sourceProj_ = sourceProj;
    this.targetProj_ = targetProj;
    let transformInvCache = {};
    const transformInv = sourceMatrix ? createTransformFromCoordinateTransform(
      (input) => apply(
        sourceMatrix,
        transform(input, this.targetProj_, this.sourceProj_)
      )
    ) : getTransform(this.targetProj_, this.sourceProj_);
    this.transformInv_ = function(c) {
      const key = c[0] + "/" + c[1];
      if (!transformInvCache[key]) {
        transformInvCache[key] = transformInv(c);
      }
      return transformInvCache[key];
    };
    this.maxSourceExtent_ = maxSourceExtent;
    this.errorThresholdSquared_ = errorThreshold * errorThreshold;
    this.triangles_ = [];
    this.wrapsXInSource_ = false;
    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());
    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;
    this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;
    const destinationTopLeft = getTopLeft(targetExtent);
    const destinationTopRight = getTopRight(targetExtent);
    const destinationBottomRight = getBottomRight(targetExtent);
    const destinationBottomLeft = getBottomLeft(targetExtent);
    const sourceTopLeft = this.transformInv_(destinationTopLeft);
    const sourceTopRight = this.transformInv_(destinationTopRight);
    const sourceBottomRight = this.transformInv_(destinationBottomRight);
    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);
    const maxSubdivision = MAX_SUBDIVISION + (destinationResolution ? Math.max(
      0,
      Math.ceil(
        Math.log2(
          getArea(targetExtent) / (destinationResolution * destinationResolution * 256 * 256)
        )
      )
    ) : 0);
    this.addQuad_(
      destinationTopLeft,
      destinationTopRight,
      destinationBottomRight,
      destinationBottomLeft,
      sourceTopLeft,
      sourceTopRight,
      sourceBottomRight,
      sourceBottomLeft,
      maxSubdivision
    );
    if (this.wrapsXInSource_) {
      let leftBound = Infinity;
      this.triangles_.forEach(function(triangle, i, arr) {
        leftBound = Math.min(
          leftBound,
          triangle.source[0][0],
          triangle.source[1][0],
          triangle.source[2][0]
        );
      });
      this.triangles_.forEach((triangle) => {
        if (Math.max(
          triangle.source[0][0],
          triangle.source[1][0],
          triangle.source[2][0]
        ) - leftBound > this.sourceWorldWidth_ / 2) {
          const newTriangle = [
            [triangle.source[0][0], triangle.source[0][1]],
            [triangle.source[1][0], triangle.source[1][1]],
            [triangle.source[2][0], triangle.source[2][1]]
          ];
          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[0][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[1][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[2][0] -= this.sourceWorldWidth_;
          }
          const minX = Math.min(
            newTriangle[0][0],
            newTriangle[1][0],
            newTriangle[2][0]
          );
          const maxX = Math.max(
            newTriangle[0][0],
            newTriangle[1][0],
            newTriangle[2][0]
          );
          if (maxX - minX < this.sourceWorldWidth_ / 2) {
            triangle.source = newTriangle;
          }
        }
      });
    }
    transformInvCache = {};
  }
  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */
  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {
    this.triangles_.push({
      source: [aSrc, bSrc, cSrc],
      target: [a, b, c]
    });
  }
  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */
  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);
    const sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
    const sourceWorldWidth = (
      /** @type {number} */
      this.sourceWorldWidth_
    );
    const wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
    let needsSubdivision = false;
    if (maxSubdivision > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const targetQuadExtent = boundingExtent([a, b, c, d]);
        const targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;
        needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
        needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
    }
    if (!needsSubdivision && this.maxSourceExtent_) {
      if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {
        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {
          return;
        }
      }
    }
    let isNotFinite = 0;
    if (!needsSubdivision) {
      if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
        if (maxSubdivision > 0) {
          needsSubdivision = true;
        } else {
          isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
          if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {
            return;
          }
        }
      }
    }
    if (maxSubdivision > 0) {
      if (!needsSubdivision) {
        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
        const centerSrc = this.transformInv_(center);
        let dx;
        if (wrapsX) {
          const centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;
          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);
        } else {
          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
        }
        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
        const centerSrcErrorSquared = dx * dx + dy * dy;
        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
      }
      if (needsSubdivision) {
        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
          const bcSrc = this.transformInv_(bc);
          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
          const daSrc = this.transformInv_(da);
          this.addQuad_(
            a,
            b,
            bc,
            da,
            aSrc,
            bSrc,
            bcSrc,
            daSrc,
            maxSubdivision - 1
          );
          this.addQuad_(
            da,
            bc,
            c,
            d,
            daSrc,
            bcSrc,
            cSrc,
            dSrc,
            maxSubdivision - 1
          );
        } else {
          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
          const abSrc = this.transformInv_(ab);
          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
          const cdSrc = this.transformInv_(cd);
          this.addQuad_(
            a,
            ab,
            cd,
            d,
            aSrc,
            abSrc,
            cdSrc,
            dSrc,
            maxSubdivision - 1
          );
          this.addQuad_(
            ab,
            b,
            c,
            cd,
            abSrc,
            bSrc,
            cSrc,
            cdSrc,
            maxSubdivision - 1
          );
        }
        return;
      }
    }
    if (wrapsX) {
      if (!this.canWrapXInSource_) {
        return;
      }
      this.wrapsXInSource_ = true;
    }
    if ((isNotFinite & 11) == 0) {
      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
    }
    if ((isNotFinite & 14) == 0) {
      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
    }
    if (isNotFinite) {
      if ((isNotFinite & 13) == 0) {
        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
      }
      if ((isNotFinite & 7) == 0) {
        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
      }
    }
  }
  /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */
  calculateSourceExtent() {
    const extent = createEmpty();
    this.triangles_.forEach(function(triangle, i, arr) {
      const src = triangle.source;
      extendCoordinate(extent, src[0]);
      extendCoordinate(extent, src[1]);
      extendCoordinate(extent, src[2]);
    });
    return extent;
  }
  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */
  getTriangles() {
    return this.triangles_;
  }
};
var Triangulation_default = Triangulation;

// node_modules/ol/reproj/common.js
var ERROR_THRESHOLD = 0.5;

// node_modules/ol/reproj/Tile.js
var ReprojTile = class extends Tile_default {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {import("../Tile.js").Options} [options] Tile options.
   */
  constructor(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, errorThreshold, renderEdges, options) {
    super(tileCoord, TileState_default.IDLE, options);
    this.renderEdges_ = renderEdges !== void 0 ? renderEdges : false;
    this.pixelRatio_ = pixelRatio;
    this.gutter_ = gutter;
    this.canvas_ = null;
    this.sourceTileGrid_ = sourceTileGrid;
    this.targetTileGrid_ = targetTileGrid;
    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
    this.sourceTiles_ = [];
    this.sourcesListenerKeys_ = null;
    this.sourceZ_ = 0;
    this.clipExtent_ = sourceProj.canWrapX() ? sourceProj.getExtent() : void 0;
    const targetExtent = targetTileGrid.getTileCoordExtent(
      this.wrappedTileCoord_
    );
    const maxTargetExtent = this.targetTileGrid_.getExtent();
    let maxSourceExtent = this.sourceTileGrid_.getExtent();
    const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
    if (getArea(limitedTargetExtent) === 0) {
      this.state = TileState_default.EMPTY;
      return;
    }
    const sourceProjExtent = sourceProj.getExtent();
    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
      }
    }
    const targetResolution = targetTileGrid.getResolution(
      this.wrappedTileCoord_[0]
    );
    const sourceResolution = calculateSourceExtentResolution(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      targetResolution
    );
    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      this.state = TileState_default.EMPTY;
      return;
    }
    const errorThresholdInPixels = errorThreshold !== void 0 ? errorThreshold : ERROR_THRESHOLD;
    this.triangulation_ = new Triangulation_default(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      maxSourceExtent,
      sourceResolution * errorThresholdInPixels,
      targetResolution
    );
    if (this.triangulation_.getTriangles().length === 0) {
      this.state = TileState_default.EMPTY;
      return;
    }
    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
    let sourceExtent = this.triangulation_.calculateSourceExtent();
    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = clamp(
          sourceExtent[1],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
        sourceExtent[3] = clamp(
          sourceExtent[3],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
      } else {
        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
      }
    }
    if (!getArea(sourceExtent)) {
      this.state = TileState_default.EMPTY;
    } else {
      let worldWidth = 0;
      let worldsAway = 0;
      if (sourceProj.canWrapX()) {
        worldWidth = getWidth(sourceProjExtent);
        worldsAway = Math.floor(
          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth
        );
      }
      const sourceExtents = wrapAndSliceX(
        sourceExtent.slice(),
        sourceProj,
        true
      );
      sourceExtents.forEach((extent) => {
        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(
          extent,
          this.sourceZ_
        );
        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
            const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
            if (tile) {
              const offset = worldsAway * worldWidth;
              this.sourceTiles_.push({ tile, offset });
            }
          }
        }
        ++worldsAway;
      });
      if (this.sourceTiles_.length === 0) {
        this.state = TileState_default.EMPTY;
      }
    }
  }
  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @private
   */
  reproject_() {
    const sources = [];
    this.sourceTiles_.forEach((source) => {
      const tile = source.tile;
      if (tile && tile.getState() == TileState_default.LOADED) {
        const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);
        extent[0] += source.offset;
        extent[2] += source.offset;
        const clipExtent = this.clipExtent_?.slice();
        if (clipExtent) {
          clipExtent[0] += source.offset;
          clipExtent[2] += source.offset;
        }
        sources.push({
          extent,
          clipExtent,
          image: tile.getImage()
        });
      }
    });
    this.sourceTiles_.length = 0;
    if (sources.length === 0) {
      this.state = TileState_default.ERROR;
    } else {
      const z = this.wrappedTileCoord_[0];
      const size = this.targetTileGrid_.getTileSize(z);
      const width = typeof size === "number" ? size : size[0];
      const height = typeof size === "number" ? size : size[1];
      const targetResolution = this.targetTileGrid_.getResolution(z);
      const sourceResolution = this.sourceTileGrid_.getResolution(
        this.sourceZ_
      );
      const targetExtent = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      );
      this.canvas_ = render(
        width,
        height,
        this.pixelRatio_,
        sourceResolution,
        this.sourceTileGrid_.getExtent(),
        targetResolution,
        targetExtent,
        this.triangulation_,
        sources,
        this.gutter_,
        this.renderEdges_,
        this.interpolate
      );
      this.state = TileState_default.LOADED;
    }
    this.changed();
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
    if (this.state == TileState_default.IDLE) {
      this.state = TileState_default.LOADING;
      this.changed();
      let leftToLoad = 0;
      this.sourcesListenerKeys_ = [];
      this.sourceTiles_.forEach(({ tile }) => {
        const state = tile.getState();
        if (state == TileState_default.IDLE || state == TileState_default.LOADING) {
          leftToLoad++;
          const sourceListenKey = listen(tile, EventType_default.CHANGE, (e) => {
            const state2 = tile.getState();
            if (state2 == TileState_default.LOADED || state2 == TileState_default.ERROR || state2 == TileState_default.EMPTY) {
              unlistenByKey(sourceListenKey);
              leftToLoad--;
              if (leftToLoad === 0) {
                this.unlistenSources_();
                this.reproject_();
              }
            }
          });
          this.sourcesListenerKeys_.push(sourceListenKey);
        }
      });
      if (leftToLoad === 0) {
        setTimeout(this.reproject_.bind(this), 0);
      } else {
        this.sourceTiles_.forEach(function({ tile }, i, arr) {
          const state = tile.getState();
          if (state == TileState_default.IDLE) {
            tile.load();
          }
        });
      }
    }
  }
  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(unlistenByKey);
    this.sourcesListenerKeys_ = null;
  }
  /**
   * Remove from the cache due to expiry
   * @override
   */
  release() {
    if (this.canvas_) {
      releaseCanvas(this.canvas_.getContext("2d"));
      canvasPool2.push(this.canvas_);
      this.canvas_ = null;
    }
    super.release();
  }
};
var Tile_default2 = ReprojTile;

// node_modules/ol/structs/LRUCache.js
var LRUCache = class {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  constructor(highWaterMark) {
    this.highWaterMark = highWaterMark !== void 0 ? highWaterMark : 2048;
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  }
  deleteOldest() {
    const entry = this.pop();
    if (entry instanceof Disposable_default) {
      entry.dispose();
    }
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }
  /**
   * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},
   * the entry will be disposed.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */
  expireCache(keep) {
    while (this.canExpireCache()) {
      this.deleteOldest();
    }
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    while (this.oldest_) {
      this.deleteOldest();
    }
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  containsKey(key) {
    return this.entries_.hasOwnProperty(key);
  }
  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */
  forEach(f) {
    let entry = this.oldest_;
    while (entry) {
      f(entry.value_, entry.key_, this);
      entry = entry.newer;
    }
  }
  /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */
  get(key, options) {
    const entry = this.entries_[key];
    assert(
      entry !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    );
    if (entry === this.newest_) {
      return entry.value_;
    }
    if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */
      this.oldest_.newer;
      this.oldest_.older = null;
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    entry.newer = null;
    entry.older = this.newest_;
    this.newest_.newer = entry;
    this.newest_ = entry;
    return entry.value_;
  }
  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  remove(key) {
    const entry = this.entries_[key];
    assert(
      entry !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    );
    if (entry === this.newest_) {
      this.newest_ = /** @type {Entry} */
      entry.older;
      if (this.newest_) {
        this.newest_.newer = null;
      }
    } else if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */
      entry.newer;
      if (this.oldest_) {
        this.oldest_.older = null;
      }
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    delete this.entries_[key];
    --this.count_;
    return entry.value_;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.count_;
  }
  /**
   * @return {Array<string>} Keys.
   */
  getKeys() {
    const keys = new Array(this.count_);
    let i = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      keys[i++] = entry.key_;
    }
    return keys;
  }
  /**
   * @return {Array<T>} Values.
   */
  getValues() {
    const values = new Array(this.count_);
    let i = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      values[i++] = entry.value_;
    }
    return values;
  }
  /**
   * @return {T} Last value.
   */
  peekLast() {
    return this.oldest_.value_;
  }
  /**
   * @return {string} Last key.
   */
  peekLastKey() {
    return this.oldest_.key_;
  }
  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  peekFirstKey() {
    return this.newest_.key_;
  }
  /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T|undefined} Value.
   */
  peek(key) {
    return this.entries_[key]?.value_;
  }
  /**
   * @return {T} value Value.
   */
  pop() {
    const entry = this.oldest_;
    delete this.entries_[entry.key_];
    if (entry.newer) {
      entry.newer.older = null;
    }
    this.oldest_ = /** @type {Entry} */
    entry.newer;
    if (!this.oldest_) {
      this.newest_ = null;
    }
    --this.count_;
    return entry.value_;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  replace(key, value) {
    this.get(key);
    this.entries_[key].value_ = value;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  set(key, value) {
    assert(
      !(key in this.entries_),
      "Tried to set a value for a key that is used already"
    );
    const entry = {
      key_: key,
      newer: null,
      older: this.newest_,
      value_: value
    };
    if (!this.newest_) {
      this.oldest_ = entry;
    } else {
      this.newest_.newer = entry;
    }
    this.newest_ = entry;
    this.entries_[key] = entry;
    ++this.count_;
  }
  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  setSize(size) {
    this.highWaterMark = size;
  }
};
var LRUCache_default = LRUCache;

// node_modules/ol/renderer/canvas/TileLayer.js
function getCacheKey2(sourceKey, z, x, y) {
  return `${sourceKey},${getKeyZXY(z, x, y)}`;
}
function addTileToLookup(tilesByZ, tile, z) {
  if (!(z in tilesByZ)) {
    tilesByZ[z] = /* @__PURE__ */ new Set([tile]);
    return true;
  }
  const set = tilesByZ[z];
  const existing = set.has(tile);
  if (!existing) {
    set.add(tile);
  }
  return !existing;
}
function removeTileFromLookup(tilesByZ, tile, z) {
  const set = tilesByZ[z];
  if (set) {
    return set.delete(tile);
  }
  return false;
}
function getRenderExtent(frameState, extent) {
  const layerState = frameState.layerStatesArray[frameState.layerIndex];
  if (layerState.extent) {
    extent = getIntersection(
      extent,
      fromUserExtent(layerState.extent, frameState.viewState.projection)
    );
  }
  const source = (
    /** @type {import("../../source/Tile.js").default} */
    layerState.layer.getRenderSource()
  );
  if (!source.getWrapX()) {
    const gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();
    if (gridExtent) {
      extent = getIntersection(extent, gridExtent);
    }
  }
  return extent;
}
var CanvasTileLayerRenderer = class extends Layer_default3 {
  /**
   * @param {LayerType} tileLayer Tile layer.
   * @param {Options} [options] Options.
   */
  constructor(tileLayer, options) {
    super(tileLayer);
    options = options || {};
    this.extentChanged = true;
    this.renderComplete = false;
    this.renderedExtent_ = null;
    this.renderedPixelRatio;
    this.renderedProjection = null;
    this.renderedRevision_;
    this.renderedTiles = [];
    this.renderedSourceKey_;
    this.renderedSourceRevision_;
    this.tempExtent = createEmpty();
    this.tempTileRange_ = new TileRange_default(0, 0, 0, 0);
    this.tempTileCoord_ = createOrUpdate3(0, 0, 0);
    const cacheSize2 = options.cacheSize !== void 0 ? options.cacheSize : 512;
    this.tileCache_ = new LRUCache_default(cacheSize2);
    this.maxStaleKeys = cacheSize2 * 0.5;
  }
  /**
   * @return {LRUCache} Tile cache.
   */
  getTileCache() {
    return this.tileCache_;
  }
  /**
   * Get a tile from the cache or create one if needed.
   *
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
   * @protected
   */
  getOrCreateTile(z, x, y, frameState) {
    const tileCache = this.tileCache_;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    const cacheKey = getCacheKey2(tileSource.getKey(), z, x, y);
    let tile;
    if (tileCache.containsKey(cacheKey)) {
      tile = tileCache.get(cacheKey);
    } else {
      tile = tileSource.getTile(
        z,
        x,
        y,
        frameState.pixelRatio,
        frameState.viewState.projection
      );
      if (!tile) {
        return null;
      }
      tileCache.set(cacheKey, tile);
    }
    return tile;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
   * @protected
   */
  getTile(z, x, y, frameState) {
    const tile = this.getOrCreateTile(z, x, y, frameState);
    if (!tile) {
      return null;
    }
    return tile;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   * @override
   */
  getData(pixel) {
    const frameState = this.frameState;
    if (!frameState) {
      return null;
    }
    const layer = this.getLayer();
    const coordinate = apply(
      frameState.pixelToCoordinateTransform,
      pixel.slice()
    );
    const layerExtent = layer.getExtent();
    if (layerExtent) {
      if (!containsCoordinate(layerExtent, coordinate)) {
        return null;
      }
    }
    const viewState = frameState.viewState;
    const source = layer.getRenderSource();
    const tileGrid = source.getTileGridForProjection(viewState.projection);
    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);
    for (let z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {
      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);
      if (!tile || tile.getState() !== TileState_default.LOADED) {
        continue;
      }
      const tileOrigin = tileGrid.getOrigin(z);
      const tileSize = toSize(tileGrid.getTileSize(z));
      const tileResolution = tileGrid.getResolution(z);
      let image;
      if (tile instanceof ImageTile_default || tile instanceof Tile_default2) {
        image = tile.getImage();
      } else if (tile instanceof DataTile_default) {
        image = asImageLike(tile.getData());
        if (!image) {
          continue;
        }
      } else {
        continue;
      }
      const col = Math.floor(
        tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0])
      );
      const row = Math.floor(
        tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1])
      );
      const gutter = Math.round(
        tilePixelRatio * source.getGutterForProjection(viewState.projection)
      );
      return this.getImageData(image, col + gutter, row + gutter);
    }
    return null;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrame(frameState) {
    if (!this.renderedProjection) {
      this.renderedProjection = frameState.viewState.projection;
    } else if (frameState.viewState.projection !== this.renderedProjection) {
      this.tileCache_.clear();
      this.renderedProjection = frameState.viewState.projection;
    }
    const source = this.getLayer().getSource();
    if (!source) {
      return false;
    }
    const sourceRevision = source.getRevision();
    if (!this.renderedRevision_) {
      this.renderedRevision_ = sourceRevision;
    } else if (this.renderedRevision_ !== sourceRevision) {
      this.renderedRevision_ = sourceRevision;
      if (this.renderedSourceKey_ === source.getKey()) {
        this.tileCache_.clear();
      }
    }
    return true;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent The extent to be rendered.
   * @param {number} initialZ The zoom level.
   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
   * @param {number} preload Number of additional levels to load.
   */
  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {
    const viewState = frameState.viewState;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getRenderSource();
    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);
    const tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }
    const wantedTiles = frameState.wantedTiles[tileSourceKey];
    const map = tileLayer.getMapInternal();
    const minZ = Math.max(
      initialZ - preload,
      tileGrid.getMinZoom(),
      tileGrid.getZForResolution(
        Math.min(
          tileLayer.getMaxResolution(),
          map ? map.getView().getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0)) : tileGrid.getResolution(0)
        ),
        tileSource.zDirection
      )
    );
    const rotation = viewState.rotation;
    const viewport = rotation ? getRotatedViewport(
      viewState.center,
      viewState.resolution,
      rotation,
      frameState.size
    ) : void 0;
    for (let z = initialZ; z >= minZ; --z) {
      const tileRange = tileGrid.getTileRangeForExtentAndZ(
        extent,
        z,
        this.tempTileRange_
      );
      const tileResolution = tileGrid.getResolution(z);
      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
          if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {
            continue;
          }
          const tile = this.getTile(z, x, y, frameState);
          if (!tile) {
            continue;
          }
          const added = addTileToLookup(tilesByZ, tile, z);
          if (!added) {
            continue;
          }
          const tileQueueKey = tile.getKey();
          wantedTiles[tileQueueKey] = true;
          if (tile.getState() === TileState_default.IDLE) {
            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {
              const tileCoord = createOrUpdate3(z, x, y, this.tempTileCoord_);
              frameState.tileQueue.enqueue([
                tile,
                tileSourceKey,
                tileGrid.getTileCoordCenter(tileCoord),
                tileResolution
              ]);
            }
          }
        }
      }
    }
  }
  /**
   * Look for tiles covering the provided tile coordinate at an alternate
   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
   * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
   * @private
   */
  findStaleTile_(tileCoord, tilesByZ) {
    const tileCache = this.tileCache_;
    const z = tileCoord[0];
    const x = tileCoord[1];
    const y = tileCoord[2];
    const staleKeys = this.getStaleKeys();
    for (let i = 0; i < staleKeys.length; ++i) {
      const cacheKey = getCacheKey2(staleKeys[i], z, x, y);
      if (tileCache.containsKey(cacheKey)) {
        const tile = tileCache.peek(cacheKey);
        if (tile.getState() === TileState_default.LOADED) {
          tile.endTransition(getUid(this));
          addTileToLookup(tilesByZ, tile, z);
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Look for tiles covering the provided tile coordinate at an alternate
   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
   * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
   * @param {number} altZ The alternate zoom level.
   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
   * @private
   */
  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {
    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(
      tileCoord,
      altZ,
      this.tempTileRange_
    );
    if (!tileRange) {
      return false;
    }
    let covered = true;
    const tileCache = this.tileCache_;
    const source = this.getLayer().getRenderSource();
    const sourceKey = source.getKey();
    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
        const cacheKey = getCacheKey2(sourceKey, altZ, x, y);
        let loaded = false;
        if (tileCache.containsKey(cacheKey)) {
          const tile = tileCache.peek(cacheKey);
          if (tile.getState() === TileState_default.LOADED) {
            addTileToLookup(tilesByZ, tile, altZ);
            loaded = true;
          }
        }
        if (!loaded) {
          covered = false;
        }
      }
    }
    return covered;
  }
  /**
   * Render the layer.
   *
   * The frame rendering logic has three parts:
   *
   *  1. Enqueue tiles
   *  2. Find alt tiles for those that are not yet loaded
   *  3. Render loaded tiles
   *
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   * @override
   */
  renderFrame(frameState, target) {
    this.renderComplete = true;
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const viewState = frameState.viewState;
    const projection = viewState.projection;
    const viewResolution = viewState.resolution;
    const viewCenter = viewState.center;
    const pixelRatio = frameState.pixelRatio;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    const tileGrid = tileSource.getTileGridForProjection(projection);
    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
    const tileResolution = tileGrid.getResolution(z);
    const sourceKey = tileSource.getKey();
    if (!this.renderedSourceKey_) {
      this.renderedSourceKey_ = sourceKey;
    } else if (this.renderedSourceKey_ !== sourceKey) {
      this.prependStaleKey(this.renderedSourceKey_);
      this.renderedSourceKey_ = sourceKey;
    }
    let frameExtent = frameState.extent;
    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
    this.prepareContainer(frameState, target);
    const width = this.context.canvas.width;
    const height = this.context.canvas.height;
    const layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);
    if (layerExtent) {
      frameExtent = getIntersection(
        frameExtent,
        fromUserExtent(layerState.extent, projection)
      );
    }
    const dx = tileResolution * width / 2 / tilePixelRatio;
    const dy = tileResolution * height / 2 / tilePixelRatio;
    const canvasExtent = [
      viewCenter[0] - dx,
      viewCenter[1] - dy,
      viewCenter[0] + dx,
      viewCenter[1] + dy
    ];
    const tilesByZ = {};
    this.renderedTiles.length = 0;
    const preload = tileLayer.getPreload();
    if (frameState.nextExtent) {
      const targetZ = tileGrid.getZForResolution(
        viewState.nextResolution,
        tileSource.zDirection
      );
      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);
      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);
    }
    const renderExtent = getRenderExtent(frameState, frameExtent);
    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);
    if (preload > 0) {
      setTimeout(() => {
        this.enqueueTiles(
          frameState,
          renderExtent,
          z - 1,
          tilesByZ,
          preload - 1
        );
      }, 0);
    }
    if (!(z in tilesByZ)) {
      return this.container;
    }
    const uid = getUid(this);
    const time = frameState.time;
    for (const tile of tilesByZ[z]) {
      const tileState = tile.getState();
      if (tileState === TileState_default.EMPTY) {
        continue;
      }
      const tileCoord = tile.tileCoord;
      if (tileState === TileState_default.LOADED) {
        const alpha = tile.getAlpha(uid, time);
        if (alpha === 1) {
          tile.endTransition(uid);
          continue;
        }
      }
      if (tileState !== TileState_default.ERROR) {
        this.renderComplete = false;
      }
      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);
      if (hasStaleTile) {
        removeTileFromLookup(tilesByZ, tile, z);
        frameState.animate = true;
        continue;
      }
      const coveredByChildren = this.findAltTiles_(
        tileGrid,
        tileCoord,
        z + 1,
        tilesByZ
      );
      if (coveredByChildren) {
        continue;
      }
      const minZoom = tileGrid.getMinZoom();
      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {
        const coveredByParent = this.findAltTiles_(
          tileGrid,
          tileCoord,
          parentZ,
          tilesByZ
        );
        if (coveredByParent) {
          break;
        }
      }
    }
    const canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio;
    const context = this.getRenderContext(frameState);
    compose(
      this.tempTransform,
      width / 2,
      height / 2,
      canvasScale,
      canvasScale,
      0,
      -width / 2,
      -height / 2
    );
    if (layerState.extent) {
      this.clipUnrotated(context, frameState, layerExtent);
    }
    if (!tileSource.getInterpolate()) {
      context.imageSmoothingEnabled = false;
    }
    this.preRender(context, frameState);
    const zs = Object.keys(tilesByZ).map(Number);
    zs.sort(ascending);
    let currentClip;
    const clips = [];
    const clipZs = [];
    for (let i = zs.length - 1; i >= 0; --i) {
      const currentZ = zs[i];
      const currentTilePixelSize = tileSource.getTilePixelSize(
        currentZ,
        pixelRatio,
        projection
      );
      const currentResolution = tileGrid.getResolution(currentZ);
      const currentScale = currentResolution / tileResolution;
      const dx2 = currentTilePixelSize[0] * currentScale * canvasScale;
      const dy2 = currentTilePixelSize[1] * currentScale * canvasScale;
      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(
        getTopLeft(canvasExtent),
        currentZ
      );
      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
      const origin = apply(this.tempTransform, [
        tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution,
        tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution
      ]);
      const tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
      for (const tile of tilesByZ[currentZ]) {
        if (tile.getState() !== TileState_default.LOADED) {
          continue;
        }
        const tileCoord = tile.tileCoord;
        const xIndex = originTileCoord[1] - tileCoord[1];
        const nextX = Math.round(origin[0] - (xIndex - 1) * dx2);
        const yIndex = originTileCoord[2] - tileCoord[2];
        const nextY = Math.round(origin[1] - (yIndex - 1) * dy2);
        const x = Math.round(origin[0] - xIndex * dx2);
        const y = Math.round(origin[1] - yIndex * dy2);
        const w = nextX - x;
        const h = nextY - y;
        const transition = zs.length === 1;
        let contextSaved = false;
        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];
        for (let i2 = 0, ii = clips.length; i2 < ii; ++i2) {
          if (!transition && currentZ < clipZs[i2]) {
            const clip = clips[i2];
            if (intersects(
              [x, y, x + w, y + h],
              [clip[0], clip[3], clip[4], clip[7]]
            )) {
              if (!contextSaved) {
                context.save();
                contextSaved = true;
              }
              context.beginPath();
              context.moveTo(currentClip[0], currentClip[1]);
              context.lineTo(currentClip[2], currentClip[3]);
              context.lineTo(currentClip[4], currentClip[5]);
              context.lineTo(currentClip[6], currentClip[7]);
              context.moveTo(clip[6], clip[7]);
              context.lineTo(clip[4], clip[5]);
              context.lineTo(clip[2], clip[3]);
              context.lineTo(clip[0], clip[1]);
              context.clip();
            }
          }
        }
        clips.push(currentClip);
        clipZs.push(currentZ);
        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);
        if (contextSaved) {
          context.restore();
        }
        this.renderedTiles.unshift(tile);
        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
      }
    }
    this.renderedResolution = tileResolution;
    this.extentChanged = !this.renderedExtent_ || !equals2(this.renderedExtent_, canvasExtent);
    this.renderedExtent_ = canvasExtent;
    this.renderedPixelRatio = pixelRatio;
    this.postRender(this.context, frameState);
    if (layerState.extent) {
      context.restore();
    }
    context.imageSmoothingEnabled = true;
    if (this.renderComplete) {
      const postRenderFunction = (map, frameState2) => {
        const tileSourceKey = getUid(tileSource);
        const wantedTiles = frameState2.wantedTiles[tileSourceKey];
        const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;
        this.updateCacheSize(tilesCount);
        this.tileCache_.expireCache();
      };
      frameState.postRenderFunctions.push(postRenderFunction);
    }
    return this.container;
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   */
  updateCacheSize(tileCount) {
    this.tileCache_.highWaterMark = Math.max(
      this.tileCache_.highWaterMark,
      tileCount * 2
    );
  }
  /**
   * @param {import("../../Tile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   * @protected
   */
  drawTile(tile, frameState, x, y, w, h, gutter, transition) {
    let image;
    if (tile instanceof DataTile_default) {
      image = asImageLike(tile.getData());
      if (!image) {
        throw new Error("Rendering array data is not yet supported");
      }
    } else {
      image = this.getTileImage(
        /** @type {import("../../ImageTile.js").default} */
        tile
      );
    }
    if (!image) {
      return;
    }
    const context = this.getRenderContext(frameState);
    const uid = getUid(this);
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);
    const alphaChanged = alpha !== context.globalAlpha;
    if (alphaChanged) {
      context.save();
      context.globalAlpha = alpha;
    }
    context.drawImage(
      image,
      gutter,
      gutter,
      image.width - 2 * gutter,
      image.height - 2 * gutter,
      x,
      y,
      w,
      h
    );
    if (alphaChanged) {
      context.restore();
    }
    if (alpha !== layerState.opacity) {
      frameState.animate = true;
    } else if (transition) {
      tile.endTransition(uid);
    }
  }
  /**
   * @return {HTMLCanvasElement} Image
   */
  getImage() {
    const context = this.context;
    return context ? context.canvas : null;
  }
  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  getTileImage(tile) {
    return tile.getImage();
  }
  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */
  updateUsedTiles(usedTiles, tileSource, tile) {
    const tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in usedTiles)) {
      usedTiles[tileSourceKey] = {};
    }
    usedTiles[tileSourceKey][tile.getKey()] = true;
  }
};
var TileLayer_default = CanvasTileLayerRenderer;

// node_modules/ol/layer/TileProperty.js
var TileProperty_default = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};

// node_modules/ol/layer/BaseTile.js
var BaseTileLayer = class extends Layer_default {
  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(options) {
    options = options ? options : {};
    const baseOptions = Object.assign({}, options);
    const cacheSize2 = options.cacheSize;
    delete options.cacheSize;
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.cacheSize_ = cacheSize2;
    this.setPreload(options.preload !== void 0 ? options.preload : 0);
    this.setUseInterimTilesOnError(
      options.useInterimTilesOnError !== void 0 ? options.useInterimTilesOnError : true
    );
  }
  /**
   * @return {number|undefined} The suggested cache size
   * @protected
   */
  getCacheSize() {
    return this.cacheSize_;
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(TileProperty_default.PRELOAD)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(preload) {
    this.set(TileProperty_default.PRELOAD, preload);
  }
  /**
   * Deprecated.  Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(TileProperty_default.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Deprecated.  Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(useInterimTilesOnError) {
    this.set(TileProperty_default.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  }
  /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   * @override
   */
  getData(pixel) {
    return super.getData(pixel);
  }
};
var BaseTile_default = BaseTileLayer;

// node_modules/ol/layer/Tile.js
var TileLayer = class extends BaseTile_default {
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(options) {
    super(options);
  }
  /**
   * @override
   */
  createRenderer() {
    return new TileLayer_default(this, {
      cacheSize: this.getCacheSize()
    });
  }
};
var Tile_default3 = TileLayer;

// node_modules/ol/uri.js
function appendParams(uri, params) {
  const keyParams = [];
  Object.keys(params).forEach(function(k) {
    if (params[k] !== null && params[k] !== void 0) {
      keyParams.push(k + "=" + encodeURIComponent(params[k]));
    }
  });
  const qs = keyParams.join("&");
  uri = uri.replace(/[?&]$/, "");
  uri += uri.includes("?") ? "&" : "?";
  return uri + qs;
}
var zRegEx = /\{z\}/g;
var xRegEx = /\{x\}/g;
var yRegEx = /\{y\}/g;
var dashYRegEx = /\{-y\}/g;
function renderXYZTemplate(template, z, x, y, maxY) {
  return template.replace(zRegEx, z.toString()).replace(xRegEx, x.toString()).replace(yRegEx, y.toString()).replace(dashYRegEx, function() {
    if (maxY === void 0) {
      throw new Error(
        "If the URL template has a {-y} placeholder, the grid extent must be known"
      );
    }
    return (maxY - y).toString();
  });
}
function expandUrl(url) {
  const urls = [];
  let match = /\{([a-z])-([a-z])\}/.exec(url);
  if (match) {
    const startCharCode = match[1].charCodeAt(0);
    const stopCharCode = match[2].charCodeAt(0);
    let charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match = /\{(\d+)-(\d+)\}/.exec(url);
  if (match) {
    const stop = parseInt(match[2], 10);
    for (let i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}

// node_modules/ol/tileurlfunction.js
function createFromTemplate(template, tileGrid) {
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      }
      let maxY;
      const z = tileCoord[0];
      if (tileGrid) {
        const range = tileGrid.getFullTileRange(z);
        if (range) {
          maxY = range.getHeight() - 1;
        }
      }
      return renderXYZTemplate(template, z, tileCoord[1], tileCoord[2], maxY);
    }
  );
}
function createFromTemplates(templates, tileGrid) {
  const len = templates.length;
  const tileUrlFunctions = new Array(len);
  for (let i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      }
      const h = hash(tileCoord);
      const index = modulo(h, tileUrlFunctions.length);
      return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
    }
  );
}

// node_modules/ol/tilegrid.js
function getForProjection(projection) {
  let tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}
function wrapX3(tileGrid, tileCoord, projection) {
  const z = tileCoord[0];
  const center = tileGrid.getTileCoordCenter(tileCoord);
  const projectionExtent = extentFromProjection(projection);
  if (!containsCoordinate(projectionExtent, center)) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.ceil(
      (projectionExtent[0] - center[0]) / worldWidth
    );
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  }
  return tileCoord;
}
function createForExtent(extent, maxZoom, tileSize, corner) {
  corner = corner !== void 0 ? corner : "top-left";
  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);
  return new TileGrid_default({
    extent,
    origin: getCorner(extent, corner),
    resolutions,
    tileSize
  });
}
function resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {
  maxZoom = maxZoom !== void 0 ? maxZoom : DEFAULT_MAX_ZOOM;
  tileSize = toSize(tileSize !== void 0 ? tileSize : DEFAULT_TILE_SIZE);
  const height = getHeight(extent);
  const width = getWidth(extent);
  maxResolution = maxResolution > 0 ? maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
  const length = maxZoom + 1;
  const resolutions = new Array(length);
  for (let z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
}
function createForProjection(projection, maxZoom, tileSize, corner) {
  const extent = extentFromProjection(projection);
  return createForExtent(extent, maxZoom, tileSize, corner);
}
function extentFromProjection(projection) {
  projection = get3(projection);
  let extent = projection.getExtent();
  if (!extent) {
    const half = 180 * METERS_PER_UNIT.degrees / projection.getMetersPerUnit();
    extent = createOrUpdate(-half, -half, half, half);
  }
  return extent;
}

// node_modules/ol/source/Tile.js
var TileSource = class extends Source_default {
  /**
   * @param {Options} options SourceTile source options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX,
      interpolate: options.interpolate
    });
    this.on;
    this.once;
    this.un;
    this.tilePixelRatio_ = options.tilePixelRatio !== void 0 ? options.tilePixelRatio : 1;
    this.tileGrid = options.tileGrid !== void 0 ? options.tileGrid : null;
    const tileSize = [256, 256];
    if (this.tileGrid) {
      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);
    }
    this.tmpSize = [0, 0];
    this.key_ = options.key || getUid(this);
    this.tileOptions = {
      transition: options.transition,
      interpolate: options.interpolate
    };
    this.zDirection = options.zDirection ? options.zDirection : 0;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(projection) {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    return this.key_;
  }
  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  setKey(key) {
    if (this.key_ !== key) {
      this.key_ = key;
      this.changed();
    }
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   * @override
   */
  getResolutions(projection) {
    const tileGrid = projection ? this.getTileGridForProjection(projection) : this.tileGrid;
    if (!tileGrid) {
      return null;
    }
    return tileGrid.getResolutions();
  }
  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {TileType|null} Tile.
   */
  getTile(z, x, y, pixelRatio, projection) {
    return abstract();
  }
  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */
  getTileGrid() {
    return this.tileGrid;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(projection) {
    if (!this.tileGrid) {
      return getForProjection(projection);
    }
    return this.tileGrid;
  }
  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(pixelRatio) {
    return this.tilePixelRatio_;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(z, pixelRatio, projection) {
    const tileGrid = this.getTileGridForProjection(projection);
    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);
    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);
    if (tilePixelRatio == 1) {
      return tileSize;
    }
    return scale3(tileSize, tilePixelRatio, this.tmpSize);
  }
  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  getTileCoordForTileUrlFunction(tileCoord, projection) {
    const gridProjection = projection !== void 0 ? projection : this.getProjection();
    const tileGrid = projection !== void 0 ? this.getTileGridForProjection(gridProjection) : this.tileGrid || this.getTileGridForProjection(gridProjection);
    if (this.getWrapX() && gridProjection.isGlobal()) {
      tileCoord = wrapX3(tileGrid, tileCoord, gridProjection);
    }
    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
  }
  /**
   * Remove all cached reprojected tiles from the source. The next render cycle will create new tiles.
   * @api
   */
  clear() {
  }
  /**
   * @override
   */
  refresh() {
    this.clear();
    super.refresh();
  }
};
var TileSourceEvent = class extends Event_default {
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  constructor(type, tile) {
    super(type);
    this.tile = tile;
  }
};
var Tile_default4 = TileSource;

// node_modules/ol/source/TileEventType.js
var TileEventType_default = {
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: "tileloadstart",
  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: "tileloadend",
  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: "tileloaderror"
};

// node_modules/ol/source/UrlTile.js
var UrlTile = class _UrlTile extends Tile_default4 {
  /**
   * @param {Options} options Image tile options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.generateTileUrlFunction_ = this.tileUrlFunction === _UrlTile.prototype.tileUrlFunction;
    this.tileLoadFunction = options.tileLoadFunction;
    if (options.tileUrlFunction) {
      this.tileUrlFunction = options.tileUrlFunction;
    }
    this.urls = null;
    if (options.urls) {
      this.setUrls(options.urls);
    } else if (options.url) {
      this.setUrl(options.url);
    }
    this.tileLoadingKeys_ = {};
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  getUrls() {
    return this.urls;
  }
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(event) {
    const tile = (
      /** @type {import("../Tile.js").default} */
      event.target
    );
    const uid = getUid(tile);
    const tileState = tile.getState();
    let type;
    if (tileState == TileState_default.LOADING) {
      this.tileLoadingKeys_[uid] = true;
      type = TileEventType_default.TILELOADSTART;
    } else if (uid in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid];
      type = tileState == TileState_default.ERROR ? TileEventType_default.TILELOADERROR : tileState == TileState_default.LOADED ? TileEventType_default.TILELOADEND : void 0;
    }
    if (type != void 0) {
      this.dispatchEvent(new TileSourceEvent(type, tile));
    }
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  setTileLoadFunction(tileLoadFunction) {
    this.tileLoadFunction = tileLoadFunction;
    this.changed();
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */
  setTileUrlFunction(tileUrlFunction, key) {
    this.tileUrlFunction = tileUrlFunction;
    if (typeof key !== "undefined") {
      this.setKey(key);
    } else {
      this.changed();
    }
  }
  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  setUrl(url) {
    const urls = expandUrl(url);
    this.urls = urls;
    this.setUrls(urls);
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  setUrls(urls) {
    this.urls = urls;
    const key = urls.join("\n");
    if (this.generateTileUrlFunction_) {
      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);
    } else {
      this.setKey(key);
    }
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */
  tileUrlFunction(tileCoord, pixelRatio, projection) {
    return void 0;
  }
};
var UrlTile_default = UrlTile;

// node_modules/ol/source/TileImage.js
var TileImage = class extends UrlTile_default {
  /**
   * @param {!Options} options Image tile options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate !== void 0 ? options.interpolate : true,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    this.tileClass = options.tileClass !== void 0 ? options.tileClass : ImageTile_default;
    this.tileGridForProjection = {};
    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
    this.renderReprojectionEdges_ = false;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   * @override
   */
  getGutterForProjection(projection) {
    if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
      return 0;
    }
    return this.getGutter();
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   * @override
   */
  getKey() {
    let key = super.getKey();
    if (!this.getInterpolate()) {
      key += ":disable-interpolation";
    }
    return key;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   * @override
   */
  getTileGridForProjection(projection) {
    const thisProj = this.getProjection();
    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {
      return this.tileGrid;
    }
    const projKey = getUid(projection);
    if (!(projKey in this.tileGridForProjection)) {
      this.tileGridForProjection[projKey] = getForProjection(projection);
    }
    return this.tileGridForProjection[projKey];
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */
  createTile_(z, x, y, pixelRatio, projection, key) {
    const tileCoord = [z, x, y];
    const urlTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord,
      projection
    );
    const tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : void 0;
    const tile = new this.tileClass(
      tileCoord,
      tileUrl !== void 0 ? TileState_default.IDLE : TileState_default.EMPTY,
      tileUrl !== void 0 ? tileUrl : "",
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions
    );
    tile.key = key;
    tile.addEventListener(EventType_default.CHANGE, this.handleTileChange.bind(this));
    return tile;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   * @override
   */
  getTile(z, x, y, pixelRatio, projection) {
    const sourceProjection = this.getProjection();
    if (!sourceProjection || !projection || equivalent(sourceProjection, projection)) {
      return this.getTileInternal(
        z,
        x,
        y,
        pixelRatio,
        sourceProjection || projection
      );
    }
    const tileCoord = [z, x, y];
    const key = this.getKey();
    const sourceTileGrid = this.getTileGridForProjection(sourceProjection);
    const targetTileGrid = this.getTileGridForProjection(projection);
    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord,
      projection
    );
    const tile = new Tile_default2(
      sourceProjection,
      sourceTileGrid,
      projection,
      targetTileGrid,
      tileCoord,
      wrappedTileCoord,
      this.getTilePixelRatio(pixelRatio),
      this.getGutter(),
      (z2, x2, y2, pixelRatio2) => this.getTileInternal(z2, x2, y2, pixelRatio2, sourceProjection),
      this.reprojectionErrorThreshold_,
      this.renderReprojectionEdges_,
      this.tileOptions
    );
    tile.key = key;
    return tile;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!ImageTile} Tile.
   * @protected
   */
  getTileInternal(z, x, y, pixelRatio, projection) {
    const key = this.getKey();
    return this.createTile_(z, x, y, pixelRatio, projection, key);
  }
  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  setRenderReprojectionEdges(render2) {
    if (this.renderReprojectionEdges_ == render2) {
      return;
    }
    this.renderReprojectionEdges_ = render2;
    this.changed();
  }
  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  setTileGridForProjection(projection, tilegrid) {
    const proj = get3(projection);
    if (proj) {
      const projKey = getUid(proj);
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = tilegrid;
      }
    }
  }
};
function defaultTileLoadFunction(imageTile, src) {
  imageTile.getImage().src = src;
}
var TileImage_default = TileImage;

// node_modules/ol/source/WMTS.js
var WMTS = class extends TileImage_default {
  /**
   * @param {Options} options WMTS options.
   */
  constructor(options) {
    const requestEncoding = options.requestEncoding !== void 0 ? options.requestEncoding : "KVP";
    const tileGrid = options.tileGrid;
    let urls = options.urls;
    if (urls === void 0 && options.url !== void 0) {
      urls = expandUrl(options.url);
    }
    super({
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: options.tileClass,
      tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      urls,
      wrapX: options.wrapX !== void 0 ? options.wrapX : false,
      transition: options.transition,
      zDirection: options.zDirection
    });
    this.version_ = options.version !== void 0 ? options.version : "1.0.0";
    this.format_ = options.format !== void 0 ? options.format : "image/jpeg";
    this.dimensions_ = options.dimensions !== void 0 ? options.dimensions : {};
    this.layer_ = options.layer;
    this.matrixSet_ = options.matrixSet;
    this.style_ = options.style;
    this.requestEncoding_ = requestEncoding;
    this.setKey(this.getKeyForDimensions_());
    if (urls && urls.length > 0) {
      this.tileUrlFunction = createFromTileUrlFunctions(
        urls.map(this.createFromWMTSTemplate.bind(this))
      );
    }
  }
  /**
   * Set the URLs to use for requests.
   * URLs may contain OGC conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.
   * @param {Array<string>} urls URLs.
   * @override
   */
  setUrls(urls) {
    this.urls = urls;
    const key = urls.join("\n");
    this.setTileUrlFunction(
      createFromTileUrlFunctions(
        urls.map(this.createFromWMTSTemplate.bind(this))
      ),
      key
    );
  }
  /**
   * Get the dimensions, i.e. those passed to the constructor through the
   * "dimensions" option, and possibly updated using the updateDimensions
   * method.
   * @return {!Object} Dimensions.
   * @api
   */
  getDimensions() {
    return this.dimensions_;
  }
  /**
   * Return the image format of the WMTS source.
   * @return {string} Format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * Return the layer of the WMTS source.
   * @return {string} Layer.
   * @api
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Return the matrix set of the WMTS source.
   * @return {string} MatrixSet.
   * @api
   */
  getMatrixSet() {
    return this.matrixSet_;
  }
  /**
   * Return the request encoding, either "KVP" or "REST".
   * @return {RequestEncoding} Request encoding.
   * @api
   */
  getRequestEncoding() {
    return this.requestEncoding_;
  }
  /**
   * Return the style of the WMTS source.
   * @return {string} Style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Return the version of the WMTS source.
   * @return {string} Version.
   * @api
   */
  getVersion() {
    return this.version_;
  }
  /**
   * @private
   * @return {string} The key for the current dimensions.
   */
  getKeyForDimensions_() {
    const res = this.urls ? this.urls.slice(0) : [];
    for (const key in this.dimensions_) {
      res.push(key + "-" + this.dimensions_[key]);
    }
    return res.join("/");
  }
  /**
   * Update the dimensions.
   * @param {Object} dimensions Dimensions.
   * @api
   */
  updateDimensions(dimensions) {
    Object.assign(this.dimensions_, dimensions);
    this.setKey(this.getKeyForDimensions_());
  }
  /**
   * @param {string} template Template.
   * @return {import("../Tile.js").UrlFunction} Tile URL function.
   */
  createFromWMTSTemplate(template) {
    const requestEncoding = this.requestEncoding_;
    const context = {
      "layer": this.layer_,
      "style": this.style_,
      "tilematrixset": this.matrixSet_
    };
    if (requestEncoding == "KVP") {
      Object.assign(context, {
        "Service": "WMTS",
        "Request": "GetTile",
        "Version": this.version_,
        "Format": this.format_
      });
    }
    template = requestEncoding == "KVP" ? appendParams(template, context) : template.replace(/\{(\w+?)\}/g, function(m, p) {
      return p.toLowerCase() in context ? context[p.toLowerCase()] : m;
    });
    const tileGrid = (
      /** @type {import("../tilegrid/WMTS.js").default} */
      this.tileGrid
    );
    const dimensions = this.dimensions_;
    return (
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function(tileCoord, pixelRatio, projection) {
        if (!tileCoord) {
          return void 0;
        }
        const localContext = {
          "TileMatrix": tileGrid.getMatrixId(tileCoord[0]),
          "TileCol": tileCoord[1],
          "TileRow": tileCoord[2]
        };
        Object.assign(localContext, dimensions);
        let url = template;
        if (requestEncoding == "KVP") {
          url = appendParams(url, localContext);
        } else {
          url = url.replace(/\{(\w+?)\}/g, function(m, p) {
            return encodeURIComponent(localContext[p]);
          });
        }
        return url;
      }
    );
  }
};
var WMTS_default2 = WMTS;

// node_modules/ol/source/common.js
var DECIMALS2 = 4;

// node_modules/ol/source/wms.js
var DEFAULT_VERSION = "1.3.0";
function getRequestUrl(baseUrl, extent, size, projection, params) {
  params["WIDTH"] = size[0];
  params["HEIGHT"] = size[1];
  const axisOrientation = projection.getAxisOrientation();
  const v13 = compareVersions(params["VERSION"], "1.3") >= 0;
  params[v13 ? "CRS" : "SRS"] = projection.getCode();
  const bbox = v13 && axisOrientation.startsWith("ne") ? [extent[1], extent[0], extent[3], extent[2]] : extent;
  params["BBOX"] = bbox.join(",");
  return appendParams(baseUrl, params);
}
function getImageSrc(extent, resolution, pixelRatio, projection, url, params, serverType) {
  params = Object.assign({ REQUEST: "GetMap" }, params);
  const imageResolution = resolution / pixelRatio;
  const imageSize = [
    round(getWidth(extent) / imageResolution, DECIMALS2),
    round(getHeight(extent) / imageResolution, DECIMALS2)
  ];
  if (pixelRatio != 1) {
    switch (serverType) {
      case "geoserver":
        const dpi = 90 * pixelRatio + 0.5 | 0;
        if ("FORMAT_OPTIONS" in params) {
          params["FORMAT_OPTIONS"] += ";dpi:" + dpi;
        } else {
          params["FORMAT_OPTIONS"] = "dpi:" + dpi;
        }
        break;
      case "mapserver":
        params["MAP_RESOLUTION"] = 90 * pixelRatio;
        break;
      case "carmentaserver":
      case "qgis":
        params["DPI"] = 90 * pixelRatio;
        break;
      default:
        throw new Error("Unknown `serverType` configured");
    }
  }
  const src = getRequestUrl(url, extent, imageSize, projection, params);
  return src;
}
function getRequestParams(params, request) {
  return Object.assign(
    {
      "REQUEST": request,
      "SERVICE": "WMS",
      "VERSION": DEFAULT_VERSION,
      "FORMAT": "image/png",
      "STYLES": "",
      "TRANSPARENT": "TRUE"
    },
    params
  );
}

// node_modules/ol/source/TileWMS.js
var TileWMS = class extends TileImage_default {
  /**
   * @param {Options} [options] Tile WMS options.
   */
  constructor(options) {
    options = options ? options : (
      /** @type {Options} */
      {}
    );
    const params = Object.assign({}, options.params);
    super({
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: options.tileClass,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== void 0 ? options.wrapX : true,
      transition: options.transition,
      zDirection: options.zDirection
    });
    this.gutter_ = options.gutter !== void 0 ? options.gutter : 0;
    this.params_ = params;
    this.v13_ = true;
    this.serverType_ = options.serverType;
    this.hidpi_ = options.hidpi !== void 0 ? options.hidpi : true;
    this.tmpExtent_ = createEmpty();
    this.updateV13_();
    this.setKey(this.getKeyForParams_());
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  getFeatureInfoUrl(coordinate, resolution, projection, params) {
    const projectionObj = get3(projection);
    const sourceProjectionObj = this.getProjection() || projectionObj;
    let tileGrid = this.getTileGrid();
    if (!tileGrid) {
      tileGrid = this.getTileGridForProjection(sourceProjectionObj);
    }
    const sourceProjCoord = transform(
      coordinate,
      projectionObj,
      sourceProjectionObj
    );
    const sourceResolution = calculateSourceResolution(
      sourceProjectionObj,
      projectionObj,
      coordinate,
      resolution
    );
    const z = tileGrid.getZForResolution(sourceResolution, this.zDirection);
    const tileResolution = tileGrid.getResolution(z);
    const tileCoord = tileGrid.getTileCoordForCoordAndZ(sourceProjCoord, z);
    if (tileGrid.getResolutions().length <= tileCoord[0]) {
      return void 0;
    }
    let tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
    const gutter = this.gutter_;
    if (gutter !== 0) {
      tileExtent = buffer(tileExtent, tileResolution * gutter, tileExtent);
    }
    const baseParams = {
      "QUERY_LAYERS": this.params_["LAYERS"]
    };
    Object.assign(
      baseParams,
      getRequestParams(this.params_, "GetFeatureInfo"),
      params
    );
    const x = Math.floor((sourceProjCoord[0] - tileExtent[0]) / tileResolution);
    const y = Math.floor((tileExtent[3] - sourceProjCoord[1]) / tileResolution);
    baseParams[this.v13_ ? "I" : "X"] = x;
    baseParams[this.v13_ ? "J" : "Y"] = y;
    return this.getRequestUrl_(
      tileCoord,
      tileExtent,
      1,
      sourceProjectionObj || projectionObj,
      baseParams
    );
  }
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */
  getLegendUrl(resolution, params) {
    if (this.urls[0] === void 0) {
      return void 0;
    }
    const baseParams = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_VERSION,
      "REQUEST": "GetLegendGraphic",
      "FORMAT": "image/png"
    };
    if (params === void 0 || params["LAYER"] === void 0) {
      const layers = this.params_.LAYERS;
      const isSingleLayer = !Array.isArray(layers) || layers.length === 1;
      if (!isSingleLayer) {
        return void 0;
      }
      baseParams["LAYER"] = layers;
    }
    if (resolution !== void 0) {
      const mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;
      const pixelSize = 28e-5;
      baseParams["SCALE"] = resolution * mpu / pixelSize;
    }
    Object.assign(baseParams, params);
    return appendParams(
      /** @type {string} */
      this.urls[0],
      baseParams
    );
  }
  /**
   * @return {number} Gutter.
   * @override
   */
  getGutter() {
    return this.gutter_;
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} tileExtent Tile extent.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string|undefined} Request URL.
   * @private
   */
  getRequestUrl_(tileCoord, tileExtent, pixelRatio, projection, params) {
    const urls = this.urls;
    if (!urls) {
      return void 0;
    }
    let url;
    if (urls.length == 1) {
      url = urls[0];
    } else {
      const index = modulo(hash(tileCoord), urls.length);
      url = urls[index];
    }
    return getImageSrc(
      tileExtent,
      (this.tileGrid || this.getTileGridForProjection(projection)).getResolution(tileCoord[0]),
      pixelRatio,
      projection,
      url,
      params,
      this.serverType_
    );
  }
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   * @override
   */
  getTilePixelRatio(pixelRatio) {
    return !this.hidpi_ || this.serverType_ === void 0 ? 1 : pixelRatio;
  }
  /**
   * @private
   * @return {string} The key for the current params.
   */
  getKeyForParams_() {
    let i = 0;
    const res = [];
    for (const key in this.params_) {
      res[i++] = key + "-" + this.params_[key];
    }
    return res.join("/");
  }
  /**
   * @param {Object} params New URL paremeters.
   * @private
   */
  setParams_(params) {
    this.params_ = params;
    this.updateV13_();
    this.setKey(this.getKeyForParams_());
  }
  /**
   * Set the URL parameters passed to the WMS source.
   * @param {Object} params New URL paremeters.
   * @api
   */
  setParams(params) {
    this.setParams_(Object.assign({}, params));
  }
  /**
   * Update the URL parameters. This method can be used to update a subset of the WMS
   * parameters. Call `setParams` to set all of the parameters.
   * @param {Object} params Updated URL parameters.
   * @api
   */
  updateParams(params) {
    this.setParams_(Object.assign(this.params_, params));
  }
  /**
   * @private
   */
  updateV13_() {
    const version = this.params_["VERSION"] || DEFAULT_VERSION;
    this.v13_ = compareVersions(version, "1.3") >= 0;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
   * @param {number} pixelRatio The pixel ratio
   * @param {import("../proj/Projection.js").default} projection The projection
   * @return {string|undefined} The tile URL
   * @override
   */
  tileUrlFunction(tileCoord, pixelRatio, projection) {
    let tileGrid = this.getTileGrid();
    if (!tileGrid) {
      tileGrid = this.getTileGridForProjection(projection);
    }
    if (tileGrid.getResolutions().length <= tileCoord[0]) {
      return void 0;
    }
    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === void 0)) {
      pixelRatio = 1;
    }
    const tileResolution = tileGrid.getResolution(tileCoord[0]);
    let tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
    const gutter = this.gutter_;
    if (gutter !== 0) {
      tileExtent = buffer(tileExtent, tileResolution * gutter, tileExtent);
    }
    const baseParams = Object.assign(
      {},
      getRequestParams(this.params_, "GetMap")
    );
    return this.getRequestUrl_(
      tileCoord,
      tileExtent,
      pixelRatio,
      projection,
      baseParams
    );
  }
};
var TileWMS_default = TileWMS;

// src/constants.js
var Center = [10.61010906, 56.15950977];
var Extent = [12e4, 59e5, 1e6, 65e5];
var Resolutions = [1638.4, 819.2, 409.6, 204.8, 102.4, 51.2, 25.6, 12.8, 6.4, 3.2, 1.6, 0.8, 0.4, 0.2];
var MatrixIds = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13"];
var Size = [256, 256];

// src/CreateLayer.js
var ccbyText = "(CC BY)";
var ccbyLink = "https://creativecommons.org/licenses/by/4.0/deed.da";
var createAttribution = function(link, text) {
  return '<a target="_blank" href="' + ccbyLink + '">' + ccbyText + '</a> <a target="_blank" href="' + link + '">' + text + "</a>";
};
var createUrl = function(service, auth) {
  if (auth.source === "kf") {
    const baseUrl = "https://api.dataforsyningen.dk/";
    return baseUrl + service + "?token=" + auth.token;
  } else if (auth.source === "df") {
    const baseUrl = "https://services.datafordeler.dk/";
    return baseUrl + service + "?username=" + auth.username + "&password=" + auth.password;
  }
  console.error('Unknown source: "' + auth.source + '"');
  return null;
};
var createLayer2 = function(opt) {
  const name = opt.name || "";
  const type = opt.type || "";
  const title = opt.title || name;
  const color = "white";
  const visible = !!opt.visible;
  const auth = opt.auth;
  const service = opt.service || "";
  const layer = opt.layer || "";
  const style = opt.style || "default";
  const version = opt.version || "1.1.1";
  const matrixSet = opt.matrixSet;
  const format = opt.format || "";
  const tileGrid = opt.tileGrid;
  const attributionText = createAttribution(opt.attribution.link, opt.attribution.text);
  let source = null;
  if (type === "WMTS") {
    source = new WMTS_default2({
      attributions: attributionText,
      crossOrigin: "Anonymous",
      url: createUrl(service, auth),
      layer,
      matrixSet,
      format,
      tileGrid,
      style,
      size: Size
    });
  } else if (type === "WMS") {
    source = new TileWMS_default({
      attributions: attributionText,
      crossOrigin: "Anonymous",
      url: createUrl(service, auth),
      params: {
        "LAYERS": layer,
        "VERSION": version,
        "TRANSPARENT": "true",
        "FORMAT": format,
        "STYLES": style
      }
    });
  } else {
    console.error('Unknown service type: "' + type + '"');
    return null;
  }
  return new Tile_default3({
    opacity: 1,
    title,
    name,
    color,
    type: "base",
    visible,
    source,
    preload: Infinity
  });
};

// src/control/markers/CreateMarkerTooltip.js
function markerTooltip(map, custom) {
  const mapDiv = document.getElementById(map.target);
  const popup = document.createElement("div");
  let closer = document.createElement("a");
  const content = document.createElement("div");
  const title = document.createElement("div");
  const description = document.createElement("div");
  title.className = "title";
  description.className = "description";
  popup.className = "ol-popup";
  mapDiv.appendChild(popup);
  if (custom) {
    popup.appendChild(custom);
    closer = custom.getElementsByClassName("closer")[0];
  } else {
    closer.className = "ol-popup-closer";
    content.className = "ol-popup-content";
    popup.appendChild(closer);
    popup.appendChild(content);
    content.appendChild(title);
    content.appendChild(description);
  }
  map.olMap.getOverlays().clear();
  const overlay = new Overlay_default({
    element: popup,
    autoPan: true,
    autoPanAnimation: {
      duration: 250
    }
  });
  map.olMap.addOverlay(overlay);
  if (closer) {
    closer.onclick = function() {
      overlay.setPosition(void 0);
      closer.blur();
      return false;
    };
  }
  map.olMap.on("singleclick", function(evt) {
    const clickedFeature = map.olMap.forEachFeatureAtPixel(
      evt.pixel,
      function(feature) {
        return feature;
      }
    );
    if (!clickedFeature) {
      return;
    }
    const features = clickedFeature.get("features");
    if (features.length > 1) {
      const extent = boundingExtent(features.map((r) => r.getGeometry().getCoordinates()));
      map.olMap.getView().fit(extent, { duration: 1e3, padding: [50, 50, 50, 50] });
    } else {
      const feature = features[0];
      if (custom) {
        custom.childNodes.forEach(function(element) {
          const content2 = feature.get(element.className);
          if (content2) {
            element.innerHTML = content2;
          }
        });
      } else {
        title.innerHTML = feature.get("title") || "";
        description.innerHTML = feature.get("description") || "";
      }
      overlay.setPosition(feature.getGeometry().getCoordinates());
    }
  });
  map.olMap.on("pointermove", function(evt) {
    map.olMap.getTargetElement().style.cursor = map.olMap.hasFeatureAtPixel(evt.pixel) ? "pointer" : "";
  });
}

// src/Map.js
var Map2 = class {
  icons = {};
  markerLayerGroup;
  markerLayers;
  popup;
  showPopup;
  set markers(markers) {
    this.setMarkers(markers);
  }
  constructor(opt) {
    this.icons = opt.icons || {};
    const background = opt.background || "";
    const zoomSlider = typeof opt.zoomSlider === "undefined" ? true : opt.zoomSlider;
    const scaleLine = typeof opt.scaleLine === "undefined" ? true : opt.scaleLine;
    const layerSwitcher = opt.layerSwitcher || false;
    const myLocation = typeof opt.myLocation === "undefined" ? true : opt.myLocation;
    const view = opt.view;
    const autoCenter = view && view.center === "auto";
    const center = view && typeof view.center !== "string" ? view.center || Center : Center;
    const autoZoom = view && view.zoom === "auto";
    const mouseWheelZoom = typeof opt.mouseWheelZoom === "undefined" ? true : opt.mouseWheelZoom;
    const overrideExtent = opt.extent || false;
    this.zoom = view ? view.zoom || 2 : 2;
    const fullScreen = typeof opt.fullScreen === "undefined" ? true : opt.fullScreen;
    this.popup = opt.popup || null;
    this.showPopup = typeof opt.showPopup === "undefined" ? true : opt.showPopup;
    this._target = opt.target || "map";
    this._source = opt.source || "kf";
    this._token = opt.token || "";
    this._username = opt.username || "";
    this._password = opt.password || "";
    this.autocenter = autoCenter;
    this.autoZoom = autoZoom;
    import_proj42.default.defs("EPSG:25832", "+proj=utm +zone=32 +ellps=GRS80 +units=m +no_defs");
    register(import_proj42.default);
    const projection = get3("EPSG:25832");
    projection.setExtent(Extent);
    const kfTileGrid = new WMTS_default({
      extent: Extent,
      resolutions: Resolutions,
      matrixIds: MatrixIds
    });
    const kfTileGrid2 = new WMTS_default({
      extent: Extent,
      resolutions: Resolutions,
      matrixIds: ["L00", "L01", "L02", "L03", "L04", "L05", "L06", "L07", "L08", "L09", "L10", "L11", "L12", "L13"]
    });
    const dfTileGrid = new WMTS_default({
      extent: Extent,
      resolutions: Resolutions,
      matrixIds: ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13"]
    });
    const kfAuth = {
      source: "kf",
      token: this._token
    };
    const dfAuth = {
      source: "df",
      username: this._username,
      password: this._password
    };
    const layers = [];
    if (this._username && this._password) {
      layers.push(createLayer2({
        name: "dtk_skaermkort",
        type: "WMTS",
        title: "Sk\xE6rmkort",
        visible: background === "dtk_skaermkort",
        service: "DKskaermkort/topo_skaermkort_wmts/1.0.0/Wmts",
        layer: "topo_skaermkort",
        matrixSet: "View1",
        format: "image/jpeg",
        tileGrid: dfTileGrid,
        auth: dfAuth,
        attribution: {
          link: "https://dataforsyningen.dk/data/962",
          text: "KDS"
        }
      }));
      layers.push(createLayer2({
        name: "dtk_skaermkort_daempet",
        type: "WMTS",
        title: "Sk\xE6rmkort d\xE6mpet",
        visible: background !== "orto_foraar" && background !== "forvaltning" && background !== "dtk_skaermkort",
        service: "DKskaermkort/topo_skaermkort_daempet/1.0.0/Wmts",
        layer: "topo_skaermkort_daempet",
        matrixSet: "View1",
        format: "image/jpeg",
        tileGrid: dfTileGrid,
        auth: dfAuth,
        attribution: {
          link: "https://dataforsyningen.dk/data/962",
          text: "KDS"
        }
      }));
      layers.push(createLayer2({
        name: "orto_foraar",
        type: "WMTS",
        title: "Ortofoto",
        color: "white",
        visible: background === "orto_foraar",
        service: "GeoDanmarkOrto/orto_foraar_wmts/1.0.0/Wmts",
        layer: "orto_foraar_wmts",
        matrixSet: "KortforsyningTilingDK",
        format: "image/jpeg",
        tileGrid: dfTileGrid,
        auth: dfAuth,
        attribution: {
          link: "https://dataforsyningen.dk/data/981",
          text: "GeoDanmark"
        }
      }));
    } else if (this._token) {
      layers.push(createLayer2({
        name: "dtk_skaermkort",
        type: "WMTS",
        title: "Sk\xE6rmkort",
        visible: background === "dtk_skaermkort",
        service: "topo_skaermkort_wmts_DAF",
        layer: "topo_skaermkort",
        matrixSet: "View1",
        format: "image/jpeg",
        tileGrid: kfTileGrid,
        auth: kfAuth,
        attribution: {
          link: "https://dataforsyningen.dk/data/962",
          text: "KDS"
        }
      }));
      layers.push(createLayer2({
        name: "dtk_skaermkort_daempet",
        type: "WMTS",
        title: "Sk\xE6rmkort d\xE6mpet",
        visible: background !== "orto_foraar" && background !== "forvaltning" && background !== "dtk_skaermkort",
        service: "topo_skaermkort_daempet_DAF",
        layer: "topo_skaermkort_daempet",
        matrixSet: "View1",
        format: "image/jpeg",
        tileGrid: kfTileGrid,
        auth: kfAuth,
        attribution: {
          link: "https://dataforsyningen.dk/data/962",
          text: "KDS"
        }
      }));
      layers.push(createLayer2({
        name: "orto_foraar",
        type: "WMTS",
        title: "Ortofoto",
        color: "white",
        visible: background === "orto_foraar",
        service: "orto_foraar_wmts_DAF",
        layer: "orto_foraar_wmts",
        matrixSet: "KortforsyningTilingDK",
        format: "image/jpeg",
        tileGrid: kfTileGrid,
        auth: kfAuth,
        attribution: {
          link: "https://dataforsyningen.dk/data/981",
          text: "GeoDanmark"
        }
      }));
    }
    if (this._token) {
      layers.push(createLayer2({
        name: "forvaltning",
        type: "WMS",
        title: "Basiskort",
        visible: background === "forvaltning",
        service: "wms/forvaltning2",
        layer: "basis_kort",
        format: "image/png",
        auth: kfAuth,
        attribution: {
          link: "https://dataforsyningen.dk/data/2680",
          text: "KDS"
        }
      }));
      layers.push(createLayer2({
        name: "kommunikation",
        type: "WMS",
        title: "Kommunikation",
        visible: background === "kommunikation",
        service: "wms/kommunikation",
        layer: "Kommunikationskort",
        format: "image/png",
        auth: kfAuth,
        attribution: {
          link: "https://dataforsyningen.dk/data/4690",
          text: "KDS"
        }
      }));
      layers.push(createLayer2({
        name: "natur_friluftskort",
        type: "WMTS",
        title: "Natur og Friluftskort",
        visible: background === "natur_friluftskort",
        service: "wmts/natur_friluftskort",
        layer: "nfkort",
        matrixSet: "View1",
        format: "image/jpeg",
        tileGrid: kfTileGrid2,
        auth: kfAuth,
        attribution: {
          link: "https://dataforsyningen.dk/data/2683",
          text: "KDS"
        }
      }));
    }
    const overlays = [];
    if (opt.overlays) {
      opt.overlays.forEach(function(e) {
        if (e.source === "kf") {
          e.auth = kfAuth;
          e.tileGrid = kfTileGrid;
        } else if (e.source === "df") {
          e.auth = dfAuth;
          e.tileGrid = dfTileGrid;
        }
        overlays.push(createLayer2(e));
      });
    }
    this._map = new Map_default2({
      target: this._target,
      layers: [
        new Group_default({
          "title": "Base maps",
          // This title of the group is shown in the layer switcher
          layers
        }),
        new Group_default({
          "title": "Kort",
          layers: overlays
        }),
        new Group_default({
          "title": "Hidden",
          layers: []
        })
      ],
      controls: defaults({ attribution: false, zoom: zoomSlider }),
      interactions: defaults2({ mouseWheelZoom }),
      view: new View_default({
        center: fromLonLat2(center, "EPSG:25832"),
        zoom: this.zoom,
        resolutions: kfTileGrid.getResolutions(),
        projection,
        extent: overrideExtent ? overrideExtent : Extent
      })
    });
    this._map.addControl(new Attribution_default({ collapsible: false }));
    scaleLine && this._map.addControl(new ScaleLine_default());
    zoomSlider && this._map.addControl(new ZoomSlider_default());
    fullScreen && this._map.addControl(new FullScreen_default());
    myLocation && this._map.addControl(new MyLocation({ zoomSlider }));
    this._layerSwitcher = new LayerSwitcher({ visible: layerSwitcher });
    this._map.addControl(this._layerSwitcher);
    this.setMarkers(opt.markers);
    this._map.on("click", function(evt) {
      const focus2 = document.activeElement;
      focus2.blur();
    });
    if (zoomSlider) {
      this.adjustControlsCss();
    }
    this._map.on("change:size", () => {
      this.adjustControlsCss();
    });
  }
  async setMarkers(markers) {
    if (!markers) {
      return;
    }
    this.markerLayers = await CreateMarkers_default(markers, this.icons);
    this._map.removeLayer(this.markerLayerGroup);
    this.markerLayerGroup = new Group_default({ layers: this.markerLayers });
    this._map.addLayer(this.markerLayerGroup);
    this.autoCenter();
    this.showPopup && markerTooltip(this, this.popup);
  }
  addVectorLayer(vector, styles, name) {
    this._map.addLayer(new Vector_default2({
      name,
      visible: false,
      source: vector,
      style: styles
    }));
  }
  getVectorLayer(name) {
    return this._map.getLayers().getArray().find(function(e) {
      return e.get("name") === name;
    });
  }
  autoCenter() {
    if (!this.autocenter || !this.markerLayers[0]) {
      return;
    }
    const extent = createEmpty();
    this.markerLayers.forEach(function(layer) {
      extend2(extent, layer.getSource().getSource().getExtent());
    });
    if (extent[0] === Infinity) {
      return;
    }
    this._map.getView().fit(extent);
    this._map.getView().setZoom(Math.floor(this._map.getView().getZoom()));
    if (!this.autoZoom) {
      this._map.getView().setZoom(this.zoom);
    }
    this._map.updateSize();
  }
  toggleBackground(background) {
    this._layerSwitcher.toggleBackground(background);
  }
  toggleLayer(layer, value) {
    const layers = this._map.getLayers().getArray();
    const vectorLayer = layers.find(function(e) {
      return e.get("name") === layer;
    });
    if (vectorLayer) {
      vectorLayer.setVisible(value);
      return;
    }
    const overlays = layers.find(function(e) {
      return e.get("title") === "Kort";
    });
    overlays.get("layers").getArray().forEach(function(e, idx, a) {
      if (e.get("name") === layer) {
        e.setVisible(value);
      }
    });
  }
  adjustControlsCss() {
    const findElementBelongingToThisMap = (collection) => {
      const array = Array.from(collection);
      return array.find((el) => {
        return !!el.closest("#" + this.target);
      });
    };
    const slider = findElementBelongingToThisMap(document.getElementsByClassName("ol-zoomslider"));
    const button = findElementBelongingToThisMap(document.getElementsByClassName("ol-zoom-out"));
    const myLoc = findElementBelongingToThisMap(document.getElementsByClassName("ol-my-location"));
    const mapHeight = document.getElementById(this.target).offsetHeight;
    if (mapHeight < 300) {
      if (slider) {
        slider.style.display = none;
      }
      if (myLoc) {
        myLoc.style.bottom = "97px";
      }
    } else {
      if (button) {
        const m = Math.floor(mapHeight * 0.25) + 6 + "px";
        button.style.marginTop = m;
      }
    }
  }
  // calls the given function with the feature as parameter
  addOnFeatureClickFunction(callback) {
    const map = this._map;
    map.on("singleclick", function(evt) {
      const feature = map.forEachFeatureAtPixel(
        evt.pixel,
        function(feature2) {
          return feature2;
        }
      );
      callback(feature);
    });
  }
  get olMap() {
    return this._map;
  }
  get target() {
    return this._target;
  }
};

// src/Initialize.js
function scrapeMarkers() {
  const markerElements = document.querySelectorAll("span.geomarker");
  const markers = [];
  markerElements.forEach(function(element) {
    const dataset = element.dataset;
    let marker = {};
    for (let key in dataset) {
      if (key === "lat" || key === "lon") {
        marker[key] = Number(dataset[key]);
      } else {
        marker[key] = dataset[key];
      }
    }
    markers.push(marker);
  });
  return markers;
}
function initMaps(options, markers) {
  const mapElements = document.querySelectorAll("div.geomap");
  let maps = [];
  mapElements.forEach(function(element) {
    const d = element.dataset;
    const types = typeof d.type === "undefined" ? [""] : d.type.split(",");
    const filteredMarkers = filterMarkers(markers, types);
    const overlays = typeof d.overlays === "undefined" ? [""] : d.overlays.split(",");
    const filteredOverlays = options.overlays ? options.overlays.filter(function(e) {
      return e.name ? e.name.indexOf(overlays) > -1 : true;
    }) : [];
    const map = generateMap({
      element,
      filtered_overlays: filteredOverlays,
      filtered_markers: filteredMarkers,
      opt: options
    });
    maps.push(map);
  });
  return maps;
}
function filterMarkers(markers, types) {
  return markers.filter(function(marker) {
    return marker.type ? marker.type.indexOf(types) > -1 : true;
  });
}
function generateMap(options) {
  const d = options.element.dataset;
  const center = d.centerLon ? [
    Number(d.centerLon),
    Number(d.centerLat)
  ] : "auto";
  const map = new Map2({
    target: options.element.id,
    token: d.token,
    username: d.username,
    password: d.password,
    background: d.background,
    icons: options.opt.icons,
    overlays: options.filtered_overlays,
    markers: options.filtered_markers,
    popup: options.opt.popup,
    showPopup: d.showPopup !== "false",
    zoomSlider: d.zoomslider === "true",
    mouseWheelZoom: d.mousewheelzoom === "false" ? false : true,
    fullScreen: d.fullscreen === "true",
    myLocation: d.mylocation === "true",
    scaleLine: d.scaleline === "true",
    layerSwitcher: d.layerswitcher === "true",
    extent: d.extent ? JSON.parse(d.extent) : null,
    view: {
      center: d.center === "auto" ? "auto" : center,
      zoom: d.zoom
    }
  });
  return map;
}
var Initialize = class {
  //Properties
  maps = [];
  constructor(options) {
    this.init(options);
  }
  // Methods
  init(options) {
    this.maps = initMaps(options, scrapeMarkers());
  }
  refresh() {
    const markers = scrapeMarkers();
    this.maps.forEach(function(map) {
      const t = map.olMap.getTargetElement().dataset.type;
      const types = typeof t === "undefined" ? [""] : t.split(",");
      const filteredMarkers = filterMarkers(markers, types);
      map.setMarkers(filteredMarkers);
    });
  }
};
var Initialize_default = Initialize;
export {
  Initialize_default as Initialize,
  Map2 as Map
};
//# sourceMappingURL=okapi.js.map
